{"meta":{"title":"IT技术博客-郭方超","subtitle":"一个技术人的实验室","description":"全栈工程师/产品经理/游戏开发","author":"郭方超","url":"http://www.guofangchao.com"},"pages":[{"title":"","date":"2018-03-14T07:30:30.000Z","updated":"2018-03-21T11:34:15.201Z","comments":true,"path":"about/index.html","permalink":"http://www.guofangchao.com/about/index.html","excerpt":"","text":"郭方超,生于1986年. 2012年-2015年,在泽旭担任技术工程师. 2015年-2016年,在瑞格传播担任项目经理. 2016年-2017年,在来吧旅行网担任前端架构师. 2017年-2018年,在达令担任前端架构师.","keywords":null},{"title":"分类","date":"2016-11-15T11:11:13.000Z","updated":"2018-03-21T11:26:06.964Z","comments":true,"path":"categories/index.html","permalink":"http://www.guofangchao.com/categories/index.html","excerpt":"","text":""},{"title":"帮助","date":"2018-03-14T14:42:32.000Z","updated":"2018-03-14T14:43:24.718Z","comments":true,"path":"help/index.html","permalink":"http://www.guofangchao.com/help/index.html","excerpt":"","text":"有问题可以在这个下面留言。","keywords":null},{"title":"友情链接","date":"2018-03-14T14:44:49.000Z","updated":"2018-03-14T14:45:25.610Z","comments":true,"path":"links/index.html","permalink":"http://www.guofangchao.com/links/index.html","excerpt":"","text":"个人博客","keywords":null},{"title":"标签","date":"2016-11-15T11:10:05.000Z","updated":"2018-03-21T11:27:30.193Z","comments":true,"path":"tags/index.html","permalink":"http://www.guofangchao.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"react-native:一场APP中的革命","slug":"react-native-一场APP中的革命","date":"2018-03-20T03:35:00.000Z","updated":"2018-03-20T03:35:47.605Z","comments":true,"path":"2018/03/20/react-native-一场APP中的革命/","link":"","permalink":"http://www.guofangchao.com/2018/03/20/react-native-一场APP中的革命/","excerpt":"","text":"记得从2010年开始，前端就逐渐绽放光芒。 在那之前的我还是一个勤恳的后端工程师，每天的工作就是一边干着后端代码一边还要写一点table之类的前端代码。嗯，也算不上前端，仅仅是一个又一个表格的嵌套而已。那个时候的前端真的是个垃圾啊。 也就在那一年，我第一次转做开发web应用，依然记得跟我配合的是一个可爱的前端妹子。从前端妹子身上我学到了基础的前端开发方式，也就是在那一年我认识了锋利的jquery。那是怎样一种不同的语言啊，简单快速、上手就能使用、即时产生效果。一些好看的效果实现出来真的是又快速又简单。我回头看了看无趣的java代码…..嗯，小妹妹教教我好不好？ 从此真可谓一发不可收拾啊。我从jquery入门的前端，又回头研究了原生的各种使用姿势。一座新世界的大门从此向我打开。我开始制作各种有意思的小组件。有改了好几个版本的无限循环的轮播图一个系列。电脑手机上自适应网页宽度的各种姿势。导航等菜单中使用到的下拉列表的各种特效。各种效果的网页加载使用的loading动画。一路走来我深深的喜欢上了这种写完就能看效果，而且效果还日常爆炸的技术。 当我以为这就是前端的全部的时候，我看到了模块化技术。原来我之前骑的是自行车，果然我还是太年轻了。模块解决了大型项目分工合作的问题，顺便让网页加载的更加流畅，一举多得莫不过如此把。 我以为模块化已经非常厉害了，但是牛人的世界我不懂。后面有陆续遇到了gulp、babel、webpack，一个更比一个厉害，它们的思想真正让我知道，世界还可以这样子。至于后来遇到的了SPA应用，嗯，这个spa有点爽。果然，在一个适当的机会，我当机立断转战vueJs。 在不知不觉中前端的触角已经蔓延到了整个世界。尤其是在我们有了nodejs之后。曾经的一个脚本语言，由于各路神仙的加入，再加上它天生的开源基因，一个广阔的世界已经在向各位前端开发者走来。还有什么是我们做不到的呢？ 在之前一直想要做一个自己的APP。但是开发一个APP非常的麻烦，不仅仅是还需要学习安卓的开发语言和模式，同时要开发ios还需要再学习一套oc的东西，如果你还要兼容swift设置wp….我的天，想想就不开心一整天。 仔细想想我还能回忆曾经上手安卓代码的那段艰难岁月。下了一整天的SDK，后来才发现可以找国内的源。搞了一天的编辑器，最后还是屈服于Android studio，那个时候真的很少有好用的IDE。复杂的配置、艰难的界面布局、状况频出的开发过程。。。。。心酸啊。本来好好的学习心态也只剩下了无尽的挣扎。 我在想facebook的开发者们也肯定是这么想的，不然不会出现react-native。这真的是一个天才的想法，一下子解决了很多疑难杂症。虽然它目前还处在测试版本，这决定了它还有很多问题，开发的时候也许会遇到一些麻烦。但是核心的问题确实被真正的解决了，开发一个APP再也不是巨大的工作量了。 不需要一个陡峭的学习曲线，一个前端开发者就可以快速开发一个自己的APP。不在需要多个团队配合，一个团队搞定所有平台。顺便使用nodejs搭建一个后端接口，再配合MongoDB或者MySQL，完美！ 当我使用几天的时间开发完一个完整的APP的时候，我最大的感受就是—爽。 真的不需要再费力发布APP客户端了。一次安装永久最新，只需要更新服务器的js版本就能做到让用户更新最新的UI界面。升级过程用户完全无感知。客户端版本升级？那是什么。 再也不需要做2套代码了。开发iOS和Android只需要一套前端代码。在强大的社区帮助下，RN几乎支持所有的原生功能。一个团队只需要配备一个懂原生的开发就能轻易添加各种自定义的原生支持，想要加速某些方面只需要随着自己的心意自定义就好了，RN提供了完整的自定义流程。还有什么不满足？ 不需要做什么原生的开发，一个稍微复杂的APP就可以诞生出来。这得益于活跃的社区和热情的开源共享者。只需要npm和react-native短短一条命令，就跟安装web的第三方包一样简单。native就已经安装好了你需要的各种包，一切都是那么的简便。开发效率翻倍的提升。需要的开发人员翻倍的下降。 往常两个团队才能开发的项目，现在只需要一个团队。如果是简单项目甚至两三个人就搞定了。如果前端开发同学比较全面的话….仔细想想吧，一个前端搞APP，一个前端搞接口，一个前端搞DB。哇！前端搞定整个项目。 如果你真的想要学习一下这种高大上的技术，请在gitbook.cn上搜索react-native的实战达人课。一个真实的案例加一个资深的老师教你开发一个完整的电商APP。 前端才是真正的艺术，哈！","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"成就匹配算法解析","slug":"成就匹配算法解析","date":"2018-03-16T15:26:00.000Z","updated":"2018-03-20T06:35:03.829Z","comments":true,"path":"2018/03/16/成就匹配算法解析/","link":"","permalink":"http://www.guofangchao.com/2018/03/16/成就匹配算法解析/","excerpt":"","text":"今天遇到一个问题： 有4个固定的成就，每个成就对应一个数字。用户的积分超过这个数字自动获得这个成就将这个方法作为一个公用的方法 考虑如下：1.必须是一个单独的方法（多余）2.输入参数固定为积分数量3.输出参数包括当前成就名称，到达下一级需要的积分，下一级成就名称4.扩展要好，下次修改不用改太多5.性能要好，不能出问题 以下是JavaScript的实现版本。 123456789101112131415161718/***输入积分数，返回成就信息集。包含积分+1操作*num &#123;Number&#125; 当前积分数量*return num &#123;Number&#125; 距离下一级需要的积分数量*return type &#123;String&#125; 当前达到的成就名称*return next &#123;String&#125; 下一级的成就名称*/function test(num)&#123; var score_list=[0,500,2000,7000,16999]; var type_list=[\"\",\"专访\",\"百科\",\"群展\",\"个展\"]; var index=score_list.length-1; while(num&lt;score_list[index])index--; return &#123; num:score_list[index+1]-num, type:type_list[index], next:type_list[index+1] &#125;&#125; 可以考虑将2个数组放在外面节约一下空间，我这边的实际情况就不需要考虑了。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"算法","slug":"suanfa","permalink":"http://www.guofangchao.com/tags/suanfa/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"AppRegistry详细解析","slug":"AppRegistry详细解析","date":"2018-03-16T15:14:17.000Z","updated":"2018-03-16T15:16:28.673Z","comments":true,"path":"2018/03/16/AppRegistry详细解析/","link":"","permalink":"http://www.guofangchao.com/2018/03/16/AppRegistry详细解析/","excerpt":"","text":"在React-native中有一个api叫AppRegistry。这是RN中的一个重要api。 接口介绍 static registerComponent(appKey, componentProvider, section?)注册组件，js中非常重要的一步，只有这里注册了，native code中才会找到要执行的js。 static registerRunnable(appKey, run)注册一个新的线程，通过第一个参数来区分，第二个参数是一个方法。 static runApplication(appKey, appParameters) #根据key来执行对应的应用（例如使用Runable注册的）。如果appKey不存在会报错。 static getAppKeys()获取注册的所有线程。其中包括第一步注册的Component和后面注册的Runable static unmountApplicationComponentAtRootTag(rootTag)结束应用，不传参数默认结束appKeys中的第一个 static registerHeadlessTask(taskKey, task)创建一个任务，这个线程不支持UI。 static startHeadlessTask(taskId, taskKey, data)执行对应的任务。（暂不支持） static registerSection(appKey, component)注册一个切片 解释 appKey用到这个参数的地方，使用方法都一样 registerHeadlessTask这个方法的第二个参数是一个方法，要求返回的是一个Promise对象","categories":[],"tags":[],"keywords":[]},{"title":"04.基础-组件和商品详情","slug":"04-基础-组件和商品详情","date":"2018-03-14T14:40:00.000Z","updated":"2018-03-14T15:19:25.735Z","comments":true,"path":"2018/03/14/04-基础-组件和商品详情/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/04-基础-组件和商品详情/","excerpt":"","text":"知识点：1.使用路由跳转内页2.开发完整的商品详情页3.弹出选择数量 前面的代码已经加入git仓库，链接地址。讲项目放在本地的同学也可以试着将代码放到仓库里。这个地方可以使用单独的分支合并到master，也可以直接覆盖带master分支。 为了能够更直观的看到每次提交的代码，我尽量把每一节的内容都做一次提交，备注也会写的非常清楚.另外我也会不定时的增加各种注释到代码里。一般情况只需要切换到不同的提交时间点即可看到当时使用的代码了。 添加页面和跳转在src目录下添加一个新的目录detail，用来放新加入的详情页。新建goods.js，并写几行简单的代码。 在src下的index.js中，将新建的页面加入到路由里。 这样新建的详情页就加入了路由管理，只要在需要跳转的时候执行传入路由的名字就可以了。这里改造home页，将几个地方的跳转改成刚才的路由名称就可以了。 点击商品就会发现已经可以跳转到详情页了，但是现在详情页什么都没有。同时也不能返回到上一页。 自定义顶部在src下新建一个component目录，用来存放头部组件以及以后会用到的一些其他组件。将组件抽成一个公用的组件是一个非常明智的方法，它会让你省下很多的时间。最好的做法就是做一个兼容很多情况的组件，然后使用继承的方法做一些参数的重载。 改造这个组件，让ios的顶部和安卓的顶部高度一致，把ios顶部的系统组件露出来。默认情况下ios顶部在小图标下面，安卓则有一个系统的顶部横条，小图标不影响正常的界面。 顶部组件默认有一个中间的标题，下面再加一个默认的左侧返回键。返回键使用的是路由组件的gobanck方法。右侧给一个自定义右侧按钮的方法。 把这个自定义组件放在详情页，然后给一个title值。一个简单的顶部组件就做完了。 刷新页面看效果，点击一下返回键，看看是不是可以用了。 详情页顶部上半部分包括头图和几个属性介绍。 详情页的所有内容使用ScrollView包裹。这是一个比较简单的列表组件，使用非常方便。在列表不长的情况下请尽量使用这个组件。 将路由传进来的参数保存在组件的变量里。由于传入的参数有2个，所有这个地方使用了2个变量，同时后面做判断的时候也要判断2次。 在组件初始化之后调用接口，将接口返回的数据存入组件的state中。这里注意把state中的变量提前写好，减少不必要的bug。 在最上面添加一个商品图片，然后接着添加价格等信息。 到这里，详情页的简单信息就实现了。后面再添加一个详细的商品信息就可以了。 这里需要注意的是,接口返回的图片有大有小，这里做了一个处理,图片太大的话就缩小一些。 最终效果和正常的电商APP就很相似了。如果有特殊的样式还可以再自己调整。 上面的开发完成之后图片是同时加载的，导致有时候上部分的图片显示延迟，后面优化的时候会优化这种情况。 购买和加入购物车展示的界面有了，下面再加上加入购物车、购买等按钮就可以了。 按钮要求悬浮在界面的最下方，所以要将这几个按钮放在ScrollView的后面。放在里面虽然也可以做到，但是非常不推荐，这样会增加渲染难度。 这里有3个按钮，分别是购物车、立即购买和分享商品。 购买弹出层点击立即购买按钮不会直接跳转到下单页，这里会弹出一个简单的选择数量的页面。在RN中如果需要使用这样的一个层就需要用Modal组件来做。Modal在RN中是一个单独的view层，默认覆盖在所有的页面上面。 这里设置Modal不使用默认的动画、全完透明，给onRequestClose添加一个默认的方法，不然会在手机上报错。 首先给Modal加一个内容层。这一层的主要作用是自己做遮罩的样式。这里是一个半透明的黑色遮罩。内部加一层点击区域，效果等于再点击黑色透明层的时候能够关掉弹出层。123456 &lt;View style=&#123;SpecificationsStyle.warp&#125;&gt; &lt;TouchableOpacity activeOpacity=&#123;0.9&#125; style=&#123;&#123; width: px(750), flex: 1 &#125;&#125; onPress=&#123;() =&gt; this.setState(&#123; priceBoxStatus: false &#125;)&#125;&gt;&lt;/TouchableOpacity&gt;&lt;/View&gt; 接下来开始写商品简略信息，包括商品小图、价格。 下面再加一层用来放选择商品数量和购买按钮。 最后把几个事件实现一下。123456789101112131415161718192021222324252627282930313233343536373839//购买方法 openbuy() &#123; this.setState(&#123; priceBoxStatus: true &#125;) &#125; //数量减少 reduce() &#123; if (this.state.buyNumber == 1) return; let buyNumber = Number(this.state.buyNumber) || 2; if (isNaN(buyNumber)) buyNumber = 2; this.setState(&#123; buyNumber: --buyNumber &#125;) &#125; //改数量 changeNumber(num) &#123; num = Number(num); if (isNaN(num)) num = 1; if (num &gt; this.state.limitStock) &#123; num = 1 toast(`库存不足`); &#125; this.setState(&#123; buyNumber: num &#125;); &#125; //增加数量 plus() &#123; if (this.state.isBuyLimit == 1 &amp;&amp; this.state.buyNumber &gt;= this.state.buyLimitNum) &#123; toast(`该商品为限购商品,$&#123;this.state.buyLimitMsg&#125;`); return; &#125; if (this.state.buyNumber &gt;= this.state.limitStock) &#123; toast(`库存仅剩$&#123;this.state.limitStock&#125;件`); return; &#125; let qty = this.state.buyNumber || 1; if (isNaN(qty)) qty = 1; this.setState(&#123; buyNumber: ++qty &#125;) &#125; 最终效果如图。点击立即购买按钮即可弹出这一个弹出层。弹出层可以选择数量，默认保持数量为1，受库存以及最大可选择的数量影响。也可以直接点击按钮跳转到购买页。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"03.基础-首页模板和商品列表","slug":"03-基础-首页模板和商品列表","date":"2018-03-14T14:39:00.000Z","updated":"2018-03-14T14:39:49.655Z","comments":true,"path":"2018/03/14/03-基础-首页模板和商品列表/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/03-基础-首页模板和商品列表/","excerpt":"","text":"知识点：1.给首页添加banner2.给首页添加运营模板3.获取接口的商品4.给顶部加一个搜索条 从这章开始我们正式开始案例的开发。git仓库的地址会放到下一章显示，需要的同学可以直接去git上看每一次提交的代码。 本文先从最早的代码形式开始一步一步的讲下去，开始开发的app会在某些情况下很卡，后面会将优化需要做的东西讲出来。这里先从简单的实现app界面开始讲，如果你觉得手机反应慢，请看后面的优化部分。 首页容器修改首页index.js文件,创建一个容器,用来放置后面要添加的各种组件。 Banner和快捷入口这里的Banner用到了一个轮播图组件。根目录下执行npm i --save react-native-swiper安装新的组件。 创建一个组件，这个组件用来放Banner和快捷入口。 这里创建state中变量，banners用来存储banner列表，quicks用来存储快捷入口的列表。 请求远程接口，将返回的数据放入state中。 将banner渲染再页面上。这里有一个小技巧，如果只有一张图片就不再使用轮播图。 接下来就是快捷入口，由于快捷入口用到了gif图。所以这里添加一个第三方的组件react-native-fast-image。在线的项目使用的是官方推荐的设置方法，让RN的image组件支持的gif。 执行npm i --save react-native-fast-image，然后使用link命令将组件加入到原生代码里。react-native link react-native-fast-image，执行完毕重新运行模拟器react-native run-ios。 将state中的数据渲染在banner的下面。这里用到了几个组件和一个新的图片，需要单独添加。ImageBackground是RN在0.47之后的版本加入的组件，它可以将一个图片当做背景来使用。这里推荐在0.50之后的版本中使用。 刷新模拟器看看效果。一个简单的banner+入口的界面就显示出来了。是不是非常简单！ 自定义模板从入口下面开始就是一个自定义的模板。这里使用现成的接口，现成的设计来做模板。运营人员会在后端传入图片并设置跳转链接。app根据设计好的样式渲染模板结果。目前有8个模板在使用，后面可能会添加更多。这里先不管后面的新模板。 在home下新建一个floor_modules.js文件。自定义模板单独放在这里处理。这里由于代码比较长就不贴出来了，有想看具体情况的可以去git仓库看。 到目前为止使用还是View组件。这个组件是不支持滑动的，要想列表可以滑动，需要将渲染结果放在专门的列表组件中才行。这里不适用ScrollView的原因是，FlatList可以在滚动的时候隐藏屏幕外的无用节点。可以提高列表性能，尤其是列表非常长的时候。 把刚才写的2个组件放到Flatlist中的header组件中ListHeaderComponent。 使用numColumns设置列表为双列。 使用refreshing传入下拉刷新使用到的变量。 使用onRefresh在下拉刷新的时候重新获取列表数据 使用onEndReached在滑动到列表底部的时候加载下一页 使用ListHeaderComponent渲染列表的头 使用renderItem渲染列表项。 使用ListFooterComponent设置底部的文字，一般可以给加载下一页展示加载的状态、文字。 使用onScroll在滑动的时候触发自己的事件。这里使用scrollEventThrottle控制触发的频率，内部的数字就是1000毫秒内触发的次数，数字越大触发越少。 使用keyExtractor设置列表每个项的key。在列表判断列表项的时候会使用这个返回的id作为key。注意，这里返回的值不能重复。 使用data设置商品的项，必须是数组。 商品列表首先给上面的2个组件添加一个名字，然后在刷新方法里调用他们的刷新方法。这样就可以做到在下拉刷新的时候同时可以刷新前面2个组件。 添加一个请求数据的方法并在组件初始化结束之后调用方法。这里使用await来达到同步等待请求结果的效果。注意，必须使用try来包裹这个方法。否则在返回错误信息的时候会发生app奔溃的效果。 这里设置了一个start变量来存储页码。这里注意一下，只有需要改变UI的变量才需要放到state里面，其他的尽量放到组件自身上面或者其他地方。否在在改变一些无意义的数据的时候也会触发界面刷新。 这里把加载下一页单独写成一个方法了。有的手机在初始化列表的时候不仅会调用一次获取第一页的方法，同时也会调用一次下一页的方法。 新建商品列表组件GoodItem，修改Flatlist组件，把GoodItem放到内容渲染方法里。 这里将数组序号也传入组件，目的是给商品列表的每一项添加一个不一样的样式。这里设置的样式在安卓和ios上会有不同的效果 通过取余方法即可完成每行有2中不同的样式。这在双列的列表中非常的常用。 首页列表中的这个大块头部组件和列表中的非常多得商品项会暴露出很多问题。后面会把这一块优化，以达到和原生一样的效果。 头部组件初步开发已经完成了。但是我们还需要在这个的基础上再加上头部组件，这个组件负责显示用的一些信息和一个假的搜索条。这样才是一个完整的APP该有的样子。 添加一个SearchHeader组件，用来做商品列表页的顶部。1234567//顶部搜索条组件class SearchHeader extends React.Component&#123; render()&#123; //这里先不去管具体的内容 return &lt;View&gt;&lt;/View&gt; &#125;&#125; 将组件放在最外层，同时使用绝对定位将顶部浮动在所有组件的最前面。这里先不讲动画，看着难受的同学可以先把浮动的组件改成普通的组件。 123456789101112131415161718const styles = StyleSheet.create(&#123; headerView: &#123; position: \"absolute\", left: 0, right: 0, top: 0, zIndex: 100, &#125;, pageView: &#123; flex: 1, width: deviceWidth, &#125;, loading: &#123; textAlign: 'center', fontSize: px(28), color: \"#ccc\" &#125;,&#125;) 顶部添加一个头像显示组件，中间添加一个输入框。这里的输入框没有实际的功能，主要是为了跳转到真正的搜索页的。 到这里基本就开发完了。将它们组合在一起然后刷新页面。 完成到这里就完成了基础的首页开发。一个简单的首页就呈现在外面的面前。如果懂打包的同学已经可以马上打一个apk文件了。这里稍微注意一下，模拟器使用的是ios，打包最方便的还是安卓，但是ios和安卓在某些情况下会有一些区别。比如样式上会根据手机的不同有一些不一样的效果，有些组件甚至只支持ios。 在浏览的时候也会看到滑动会有一些生涩，点击跳转也没有做。顶部最好有一些动画等等。这些在后面都会有涉及。图中就是在说列表太长导致更新很慢，同时还提醒开发者使用PureComponent来优化性能。后面会教大家怎样使用purComponent和shouldComponentUpdate来优化性能。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"02.基础-封装自己的库","slug":"02-基础-封装自己的库","date":"2018-03-14T14:38:00.000Z","updated":"2018-03-14T14:38:48.692Z","comments":true,"path":"2018/03/14/02-基础-封装自己的库/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/02-基础-封装自己的库/","excerpt":"","text":"知识点：1.封装一个自己的日志，代替原生的console2.封装一个自己的请求库，代替原生的fetch3.自适应方法，兼容各种手机屏幕4.封装一个本地存储5.集成toast弹出提示6.让iOS支持http地址7.安卓需要证书才能编译 在正式开始之前，我们先封装几个要用到的库。 自定义本地日志自定义日志的一个好处就是省的每次都要手动注释console。而且还可以同时将日志存在本地，或者发到日志服务器。一个方法就一举多得了。 在src目录下新建一个utils文件夹。我们封装一个日志输出类。开发模式下使用console.log命令。正式情况下记录在变量中，方便在手机上查看日志。 新建一个log.js文件。路径为根目录/src/utils/log.js。 新建一个数组变量logs，用来临时存放日志信息。 将日志分成信息、警告和错误3种，分别给出3个可调用的方法。同时给第一个参数加一个好看的颜色。 在index中引入日志组件，写几个方法看看调用的结果。 这里稍微定义一下日志的要求。参数0，字符串。参数1，对象。参数2，字符串。 自定义请求RN默认提供了fetch方法去请求远程数据。我们再封装一次，将这个方法将会针对现有的项目做封装，在使用请求的时候能够更适合、更方便。这里使用header保存了一些临时的变量，算是一个小小的全局缓存吧。 创建request.js文件，目录：根目录/src/utils/request.js。 将请求header里的信息单独出来，每次请求都需要带上这个共享header数据。 创建一个Request类,并将这个类对外公开。这里讲请求初始化一次，以后用到别的请求的时候也可以单独实例化一次。123456/** * 请求库 */class Request &#123;&#125;export default new Request(); 每次请求都将header中的内容带入请求中，单独检测httpcode和后端返回的code值。这里可以直接做权限检测，在需要的时候跳转到登录页。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 请求库 */class Request &#123; /** * 检测返回状态码 * @param &#123;*&#125; status * @param &#123;*&#125; res */ async _checkStatus(status, res, url) &#123; if (status !== 200) &#123; logWarm('请求失败参数', await res.text(), url, headers); throw new Error('网络连接失败，请检查网络'); &#125; &#125; /** * 检查后端返回的状态码 * @param &#123;*&#125; status */ _checkAppStatus(json, url) &#123; if (json.status != 0) &#123; logWarm('返回状态报错', json, url); throw new Error(`$&#123;json.errorMsg&#125;`); &#125; &#125; /** * 内部实现网络请求 * @param &#123;*&#125; url * @param &#123;*&#125; options */ async _request(url, options, type) &#123; url = url.indexOf('http') == 0 ? url : url.indexOf('/api') == 0 ? domain + url : baseUrl + url; let res = await fetch(url, options); this._checkStatus(res.status, res, url) if (type === 'json') return await this._jsonFactory(res, url, options) return await this._jsonFactory(res, url, options) &#125; /** * 处理json数据 * @param &#123;*&#125; res * @param &#123;*&#125; url */ async _jsonFactory(res, url, options) &#123; let json; let txt = ''; try &#123; txt = await res.text(); &#125; catch (e) &#123; log('未拿到返回字符串', &#123; url: url, txt: txt &#125;); throw new Error('数据格式错误'); &#125; try &#123; json = JSON.parse(txt); &#125; catch (e) &#123; logErr('返回数据格式错误', &#123; url: url, txt: txt &#125;); throw new Error('数据格式错误'); &#125; this._checkAppStatus(json, url) log(\"请求返回\", json, url, options); return json.data; &#125; /** * get请求 * @param &#123;*&#125; url */ async get(url, data) &#123; if (data) data = urlEncoded(data); if (url.indexOf('?') &lt; 0 &amp;&amp; data) url += '?' + data; return this._request(url, &#123; method: 'GET', headers: headers, timeout: 10000 &#125;, 'json') &#125; /** * post请求 * @param &#123;*&#125; url * @param &#123;*&#125; data */ async post(url, data) &#123; return this._request(url, &#123; method: 'POST', headers: Object.assign(headers, &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125;), timeout: 10000, body: urlEncoded(data) &#125;, 'json') &#125;&#125; 调用一次远程端口并查看日志输出。这里调用的也是案例中要使用到的获取banner的接口。这个接口不需要用户权限，后面还会遇到需要用户权限的接口。 自适应方法这里推荐一种自适应的方法。同时也是前端在开发移动端页面的时候常用的方法。将手机屏幕宽度默认为750像素，然后将所有的宽高按照这个比例去缩放。这要求设计出的设计稿也要宽度是750。 在utils下新建一个px.js文件。按照出入的大小根据当前屏幕的宽度获取到缩放的比例并返回结果。 在首页引入px方法，查看使用px之后的效果。 可以看到使用px将500像素缩放之后的效果和最开始设置的纯数字200效果是一致的。这里使用的是ios模拟器，真实的屏幕宽是375，按照750宽去算的话会把传入的参数统统除以2。 封装本地存储RN提供的AsyncStorage可以根据key存储相应的字符串。我们这里改进一下，让它可以存储所有类型的字段。利用的是将传入的参数改造成对象，然后使用JSON的方法将对象转化成一个可以存储的字符串。 在utils下新建一个Storage.js。 将传入的对象转化为字符串并存入AsyncStorage。123456789101112131415161718192021222324252627282930313233343536373839'use strict';import &#123; AsyncStorage &#125; from 'react-native';/** * 获取存储的数据 * @param &#123;*&#125; key */exports.getItem = async (key) =&gt; &#123; let item = await AsyncStorage.getItem(key); if (!item) &#123; return null; &#125; return JSON.parse(item).v || null;&#125;/** * 存入数据 * @param &#123;*&#125; key * @param &#123;*&#125; value */exports.setItem = (key, value) =&gt; AsyncStorage.setItem(key, JSON.stringify(&#123; v: value&#125;));/** * 删除已经存在的数据 * @param &#123;*&#125; key */exports.removeItem = (key) =&gt; AsyncStorage.removeItem(key);/** * 清除所有 */exports.clear = () =&gt; AsyncStorage.clear();/** * 获取所有的key */exports.getAllKeys = () =&gt; AsyncStorage.getAllKeys(); 在首页使用setItem存入数据,然后第二次进入页面再使用getItem获取数据。 这里用到了componentDidMount这个方法。这个方法是在组件生命周期中的初始化完成之后执行的。 添加弹出toast之前公司使用的是自己开发的提示方法，这个方法需要改变原生代码，非常的不方便。这里推荐使用第三方的开源组件react-native-root-toast。只需要安装一下就好了。 执行命令，安装toast。npm i --save react-native-root-toast。 在utils目录下新建toast.js文件。添加toast的默认方法并填入默认参数。这里设置显示时间为1000毫秒，背景颜色是一个半透明的黑色。这里也是为了方便调用，如果需要多种效果的就定义多个吧。 在首页引入toast并看看实际的效果。 让iOS支持http协议苹果之前推荐使用https协议,现在默认是不支持http的。如果需要支持http需要单独设置。案例中的项目也用到了http，所以需要修改info.plist文件，让iOS可以访问http的地址。 使用xcode选择打开其他项目。 打开项目下的iOS文件夹，选择项目文件并打开。 选择info.plist文件，再右边选择第一行并点击+号添加一项。 选择App Transport Security Setting这一项，会弹出提示。点击确定即可自动刷新。 在上面添加的新配置中添加一个新的配置Allow Arbitrary Loads，同时设置为YES。 改完配置还需要编译一次。点击左上角的三角形或者菜单中product下的build选项。 这里我使用的是xcode修改配置文件，如果你发现配置文件没有变化，也可以自己改info.plist文件的内容。 编译安卓客户端使用android studio打开根项目下的android目录。打开build.gradle文件。这个就是项目的gradle配置文件，通常使用这个文件对整个项目进行描述。 经过一定时间的等待，IDE就会初始化整个项目。如果有一些需要下载的文件也会在这个时间通知下载。 点击菜单build/gennerate signed apk。这个就是编译一个可以安装在安卓手机上的安装包。也可以通过点击make project来看看项目是否可以编译通过。 点击next，IDE会提示需要选择一个证书。这里可以选择一个已有的并输入密码，也可以通过点击create new来创建一个。后面一直点击next就可以了，IDE会在生成apk之后弹出通知。 选择创建一个新的证书。根据提示填入相应的内容，之后点击ok即可生成。记得选择remember password，下次直接填入密码。 经过一整机器躁动之后，IDE弹出编译结果。点击蓝色字可以快速打开apk的地址。 将apk文件发送到手机上安装即可。一个你自己开发的app就安装好了。 这里要注意，在打包之前要把RN打包生成的bundle文件放入android文件下的assets目录中。否则安卓会因为找不到启动文件而报错。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"01.基础-项目初始化","slug":"01-基础-项目初始化","date":"2018-03-14T14:12:00.000Z","updated":"2018-03-14T14:39:05.931Z","comments":true,"path":"2018/03/14/01-基础-项目初始化/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/01-基础-项目初始化/","excerpt":"","text":"知识点：1.快速创建RN项目2.添加使用路由功能3.不要在RN中使用的功能 从这里开始，我们将一步一步的创建一个可以真正的使用的app。第一部分讲述开发一个app的大致过程，第二部分将开始优化性能、开发效率等，第三部分教大家添加热更新、支付、分享这些功能。大多数第三方组件可以很方便的link到项目里，部分需要手动导入甚至主动开发一些东西，这里也会在用到的时候讲出来。 创建项目的前提条件·使用react-native创建一个新的项目请确保你的电脑上已经满足下面的这些条件。 nodejs。RN的所有库都是从npm上安装的。请确保你的电脑上已经安装了npm。可以使用npm -v来查看当前是否安装了npm。当前项目使用的node版本是8.9.3，npm的版本是5.5.3。 react-native-cli。这个通常用作RN的初始化和启动模拟器等，是用npm可以安装到电脑上。 python。RN里面有些脚本是使用python写的。请确保电脑上已经安装了python2.7以上的版本。 jdk1.8。安卓项目需要使用jdk1.8，请在电脑上安装好jdk1.8。安装的教程可以方便从网上搜索到。 Android Studio。调试以及编译安卓代码需要使用到。请在安装Android Studio之后安装好Android SDK以及模拟器。模拟器可以使用市面上的安卓模拟器，它们普遍比自带的模拟器要快。闲麻烦的同学可以直接连接手机调试。在安装好IED之后请下载好需要使用到的androidSDK。下载SDK需要科学上网或者把下载地址替换成国内的几个下载源。 git。后面的项目会加入到git中，使用git做版本管理的好处不言而喻。 Xcode（仅ios项目中）。安装了Xcode才能使用iOS模拟器。ios模拟器下的开发速度要明显优于安卓下，后面的开发过程大多数也是在ios模拟器中进行的。在模拟器中的表现都差不多，有些不一样的效果可以在看到的时候单独调试。 Watchman（仅mac系统用到）。Watchman用来监听文件变动等。mac下必须安装Watchman。 vscode。文中演示项目使用的编辑器是vscode。这里也推荐使用vscode开发前端项目。 创建项目我们先在本地创建一个可运行的项目，同时这个项目会加入到git的版本管理中。 执行react-native init anxintao --version 0.53.0。图中1代表之前安装的react-native-cli的命令。图中2代表初始化命令。图中3代表项目的名称，这里是anxintao。图中4代表指定RN的版本号，这个参数不传默认使用最新版。图中5代表RN具体使用的版本号。 使用vscode打开项目，在项目根目录下执行命令启动初始化之后的项目，mac下推荐react-native run-ios，window下推荐react-native run-android启动默认的项目。如果能启动说明项目初始化完成，否则说明项目的某些东西没有安装好。这里推荐把启动的命令写入到package.json文件中。比如:输入npm run ios即可代替原来的react-native run-ios，输入命令的速度快了不少。也可以给vscode安装一个启动RN的插件，不过效果跟输命令差不多，具体要看个人习惯了。 到这里就说明项目创建成功了。这个项目现在还很简单，它的原生部分只有一个简单的空壳。这个空壳仅仅是初始化了一个RN的activity，所有的js都是运行在根视图上的。 这里注意一下，新建的项目提示了按键可以刷新页面或者调出菜单。这显示的是ios模拟器，按键为command R刷新和command D调出菜单。 添加路由一个完整的项目不能没有路由。这里我们使用React Navigation。 在写文章的时候已经有一个路由组件react-native-navigation热度超过了react-navigation。它更多的使用的是原生的路由切换，效果更好。想用的同学可以去尝试一下。 安装路由。在根目录下执行npm install --save react-navigation。 在根目录下新建src目录。所有页面放入这个文件夹下。 新建一个首页，给后面的路由调用。页面路径为:根目录/src/home/index.js 12345678910111213141516'use strict';import React from 'react';import &#123; StyleSheet, View, Text&#125; from 'react-native';export default class extends React.Component &#123; render() &#123; return &lt;View style=&#123;&#123; marginTop: 200 &#125;&#125;&gt; &lt;Text&gt;这是首页&lt;/Text&gt; &lt;/View&gt; &#125;&#125; 修改根目录下的index.js。添加整个项目的路由。 1234import &#123; AppRegistry &#125; from 'react-native';import Pages from './src';//启动AppRegistry.registerComponent('anxintao', () =&gt; Pages); 5.在src目录下新建index.js文件。在这个文件里添加路由。我们从简单的一个页面开始。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354'use strict';import React from 'react';import &#123; StyleSheet&#125; from 'react-native';//添加路由组件import Navigation from 'react-navigation';//添加展示用的首页import Home from './home/index'//创建路由const Pages = Navigation.StackNavigator(&#123; 'Home': &#123; screen: Home &#125;&#125;, &#123; //这里做了一个页面跳转的动画 transitionConfig: () =&gt; (&#123; screenInterpolator: sceneProps =&gt; &#123; const &#123; layout, position, scene &#125; = sceneProps; const &#123; index &#125; = scene; //设置页面跳转的动画 const translateX = position.interpolate(&#123; inputRange: [index - 1, index, index + 1], outputRange: [layout.initWidth, 0, 0] &#125;); const opacity = position.interpolate(&#123; inputRange: [index - 1, index - 0.99, index, index + 0.99, index + 1], outputRange: [0, 1, 1, 0.3, 0] &#125;); return &#123; opacity, transform: [&#123; translateX &#125;] &#125;; &#125; &#125;), navigationOptions: &#123; header: null &#125;&#125;);//创建一个自己的容器,方便以后对路由做一些处理export default class extends React.Component&#123; constructor(props) &#123; super(props); &#125; render() &#123; return &lt;Pages onNavigationStateChange=&#123;this.listenChange.bind(this)&#125;&gt;&lt;/Pages&gt;; &#125; //监听路由的跳转 listenChange(state1, state2, action) &#123; &#125;&#125; 6.添加完成之后删除掉初始化项目之后的App.js。这个时候在模拟器中使用快捷键command+R即可刷新刷新页面。7.至此就完成了简单的路由设置。之后只需要添加页面并在路由中注册即可使用。 路由升级版简单的路由并不能起到很好的作用，我们还是创建一个更实用的路由吧。比如带3个tab切换的首页，这也是大多数app使用套路。 添加4个tab切换页。我们假定未来需要4个切换页，分别是首页、分类页、购物车、个人中心。在home下分别创建他们。 修改路由所在的index文件。引入下面要用到的几个组件和页面 添加新加入的页面123456789101112import React from 'react';import &#123; StyleSheet, Image&#125; from 'react-native';//添加路由组件import Navigation from 'react-navigation';//添加展示用的首页import Home from './home/index'import Products from './home/products'import Shop_Cart from './home/shop_cart'import My from './home/my' 创建底部的样式123456789101112131415//创建tab页的顶部样式const styles = StyleSheet.create(&#123; tab: &#123; height: 40, backgroundColor: '#fbfafc', borderTopColor: '#efefef' &#125;, tabIcon: &#123; width: 20, height: 20 &#125;, tabLabel: &#123; marginBottom: 4 &#125;&#125;) 创建一个tab路由，为了简单这里只展示2个页面的。具体的代码可以去git仓库查看。1234567891011121314151617181920212223242526272829303132333435363738394041//创建首页的tab页const Tabs = Navigation.TabNavigator(&#123; 'Home': &#123; screen: Home, navigationOptions: (&#123; navigation, screenProps &#125;) =&gt; &#123; return &#123; tabBarLabel: '首页', tabBarIcon: (opt) =&gt; &#123; if (opt.focused) return &lt;Image source=&#123;&#123; uri: require('./images/tab-home-active') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; return &lt;Image source=&#123;&#123; uri: require('./images/tab-home') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; &#125; &#125; &#125; &#125;, 'Products': &#123; screen: Products, navigationOptions: (&#123; navigation, screenProps &#125;) =&gt; &#123; return &#123; tabBarLabel: '产品分类', tabBarIcon: (opt) =&gt; &#123; if (opt.focused) return &lt;Image source=&#123;&#123; uri: require('./images/tab-products-active') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; return &lt;Image source=&#123;&#123; uri: require('./images/tab-products') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; &#125; &#125; &#125; &#125;,&#125;, &#123; //设置tab使用的组件 tabBarComponent: Navigation.TabBarBottom, //点击哪个才加载哪个tab里的页面 lazy: true, //设置tab放在界面的底部 tabBarPosition: 'bottom', //设置tab里面的样式 tabBarOptions: &#123; style: styles.tab, labelStyle: styles.tabLabel, activeTintColor: '#d0648f' &#125;&#125;); 替换Pages里的第一个页面为刚才创建的Tab路由。由于默认加载第一个，所以需要将第一个设置成tab页。123'Tabs': &#123; screen: Tabs &#125; 3.现在再刷新模拟器,就会发现底部的Tab切换已经好了。点击可以切换不同的页面。 4.这里我将图片转化成base64的方式再引入到图片组件中。好处是打包之后会变成一个整体。坏处是打包之后的bundle文件会变大，做增量更新也比较麻烦。 不推荐使用的东西 投影。安卓不支持投影，在开发的时候如果没有必要就使用别的方式代替吧。比如使用图片代替投影。 边框色。在长列表中尽量不要使用边框色，在某些安卓手机下会闪退。 使用了圆角的情况再使用背景色。ios手机会出现边框颜色异常或者异常色块。去掉背景即可。 过于深层次的结构 过于频繁的刷新state","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"00.为什么我选择react-native","slug":"00-为什么我选择react-native","date":"2018-03-14T14:10:00.000Z","updated":"2018-03-14T14:15:33.879Z","comments":true,"path":"2018/03/14/00-为什么我选择react-native/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/00-为什么我选择react-native/","excerpt":"","text":"在所有的技术选型之前都有一个为什么。 为什么我选择了React-native？选择这个技术到底给我带来了什么样的技术福利？如果你正在考虑RN，或者还在研究选择什么样的技术实现自家的APP。不妨看看我的课程，说不定你就有了不一样的感受。 注：react-native以下会简称RN。 我注意的优点选择RN之前我也看过了其他的几种技术，早一点的时候我也使用过其他的技术做APP。比如HBuilder的框架，非常的方便、非常的好用、什么都不需要管。但是开发完之后发现性能很差，做一个稍微复杂点的项目就非常上火。后来切了原生，但是使用java做开发也有非常多得问题，开发效率很低。 后来我选择了RN，它使用js更新虚拟dom，通过一个桥接器将需要更新的结果通知到UI层，让native执行UI的改变。简单来说，就是用js做驱动开发一个类原生的APP。所有的渲染都是和原生一样的，一下子就讲原生开发和js开发连接起来。通过这么一个模式，将传统的java或者oc开发转变成了简单易懂的前端js开发。这是移动开发的一大进步，避免了一个APP多个平台多套代码的尴尬，同时提升了开发效率，将移动开发带入了一个新的层面。 性能相似很多人说RN的性能比不上原生的APP。这个说法是要看具体的场景下的。 在一般的应用场景下RN的表现和原生APP是没有太大的差别的。一个APP也不会是到处都是复杂的交互效果。一些简单的点缀动画再加上列表图片等才是一个APP最常见的内容。这种情况下它们之间的表现是一样的。 RN本身只是使用js处理了UI渲染之前的一些逻辑，在最终的渲染上其实使用的还是原生的逻辑。尤其是渲染完成之后更是和原生的没有半点区别。 我们的案例是一个电商项目，主要渲染逻辑是首页的自定义模板、无限加载的列表等。目前最大的性能瓶颈其实是在事件的优化上，优化之后用户已经感知不到和原生的区别了。我们会在后面的部分提到性能优化，将一个粗糙的app通过简单的方法提高10倍性能，再通过另外一个稍微复杂的方法减低内存占用。 开发效率高通常情况开发一款APP需要发布在安卓和iOS两个平台，导致的结果就是一个APP两个团队两套代码。界面几乎一样，为什么不能使用一套代码呢？之前也有大神使用各种手段达成这个目标，但是并不是很理想。 由于使用熟悉的react和jsx的模式，开发者只需要有前端知识就可以很迅速的上手一个RN项目。如果再学一些实战的例子，稍微复杂一些的项目也难不倒各位前端开发者。 debug超级方便，一边开发一边看效果再也不是梦。 快速热更新RN生成的js文件，只要不涉及原生功能的增减，已经发布的APP完全不需要重新安装即可完成新版功能的上线。用户只需打开APP就能体验到最新的APP，省去了下载重装的各种麻烦。把app的更新做到了和网页更新一样的方便快捷。 使用RN就能达到既有原生的所有能力，又有类似浏览器上的快速更新能力。同时还可以接入各种定制好的网页，将APP的自由度提高到一个非常高的地步。 大公司背书RN的开发者是facebook，背靠大树好乘凉，社区更疯狂。FB本身也在尝试使用RN技术开发自己的APP，RN一定会越来越完善。截止写这篇文章的时候RN已经更新到了0.53.0。 RN本身也是开源的，所有的源代码都是可以看到的。社区的讨论也是比较热烈的。现在可能中文文档还比较少，未来随着开发者的努力，这些坑都会填起来的。 其实最开始的时候也没有想很多，仅仅是冲着RN可以快速开发，上线快体验好。经过了这么长时间的开发，我更加喜欢RN的这种开发方式，项目中也填了各种各样的坑。后面就用一个实际的例子来展示RN是怎样开发的吧。 RN的缺点升级快RN本身其实还处于测试版，开发组经常会升级RN，解决一些遗留或者隐藏的bug。在这个的过程中就导致了RN本身升级非常快，开发者在使用RN开发APP的过程中应该尽量提高自己的版本，不需要一直是最新的，只要能够跟的上FB的节奏即可。 自己搞定的问题也是可以合并入RN的源代码里的。不要一味的等RN更新，有些问题自己解决更方便。建议会Android或者ios同学自己动手。 动画难这里的难指的是复杂的动画在开发中很难去优化。尤其是开发者懂前端但是不懂原生的情况下。好在常见的APP也不需要多么复杂的动画。一般使用位移变换就足够了，太复杂的动画建议使用RN的svg组件来做。 webview难用RN自带的webview跟浏览器有一定的差别。APP经常要打开一些网页，可能在开发的时候一切正常，但是到了RN里面就会有一些奇怪的问题，主要还是受到系统浏览器的影响，会有一些兼容方面的问题。这种情况下不如微信使用自己研发的浏览器，可以畅快的使用ES6之类的新技术。 需要原生支持简单的东西和界面的展现已经完全放手给了开发者。但是还是有一些功能只能原生去实现，如果原生部分的开发者对RN不太了解可能会给APP带来不可预知的bug。好在大多数开源看只需要执行link命令就可以把原生部分也安装好。 技术都会有优点和缺点。选择合适的技术才能给项目带来长久的生命力。 其他技术weex核心思想上，这两家其实并没有什么区别。weex也可以算是站在RN的肩膀上起步的。目前活跃度不高，大多数是在观望中。 开发框架weex使用vue。熟悉vue的开发者可能会更熟悉。 RN使用react。都是facebook出品，框架融合上会更方便一些。 它们都是组件化开发，都输数据绑定，都有虚拟dom。社区同样活跃，使用人数也都非常多。 学习成本react的jsx初期会比较难上手，css的写法也跟前端的样式写法不一样。weex使用模板的形式，直接html+css开发。上手会稍微简单一些。 异步weex只支持callback的形式。RN支持promise的形式。 这些都是可以解决的。不是什么问题。 社区RN开源早，有facebook支持。社区的组件库已经比较丰富，社区活跃度比较高。weex开源晚，社区活跃不高，以阿里系比较多。 FlutterFlutter 是Google推出的一个跨平台（Android 和 iOS）移动开发框架，使用的是 Dart 语言。 Flutter 的目标是用来创建高性能、高稳定性、高帧率、低延迟的 Android 和 iOS 应用。并且开发出来的应用在不同的平台用起来跟原生应用具有一样的体验。不同的平台的原生体验应该得到保留，让该应用看起来同整个系统更加协调。不同平台的滚动操作、字体、图标 等特殊的特性 应该和该平台上的其他应用保持一致，让用户感觉就像操作原生应用一样。比如，返回图标 Android 和 iOS 是不一样的；滚动内容滚动到底的反馈也是不一样的。 兼容Flutter不使用系统提供的组件，自己实现了一套渲染机制，所以在性能优化、跨平台方面表现优秀。实际体验上，性能比RN要高不少。 RN最终调用的还是系统的组件，虽然FB已经很努力了，但是在某些时候还是会有兼容性需要处理。 组件Flutter 内置了对Material Design的支持，给开发者提供了丰富的 UI 控件库选择。同时所有的组件都有扩展，保持了很高的灵活性。 RN通过react也做到了组件式开发，跟Flutter相比，多了一个桥接器的转换，性能上肯定不如Flutter。 开发语言Flutter使用Dart实现。Dart号称要完全取代js，不过目前离这个目标还非常远。初期上手还是有一些难度的。 RN使用js开发，做过前端的都非常熟悉，上手很容易。 Flutter现在还在实验阶段，不排除google使用别的框架替换它的可能性。Dart语言也处于成长阶段，只有google的浏览器在支持。或许在Flutter持续发展到一个阶段之后，才会有很多支持者。 在写文章的时候google放出了第一个测试版，感兴趣的同学可以下载下来玩玩。 相比于其他几种技术，RN是目前社区最活跃，开发效率最高的一种选择。选择RN也是需要在一个比较短的时间内能够完成APP的开发。尤其现在前端开发者可以非常容易的从网页开发转到APP开发上。对于我们包含APP、微信、小程序这样的三个平台更是需要RN这样的技术，一个团队就可以维护项目的持续增长。 如果你需要RN来开发自己的项目，那就看下去吧。我们将从简单的界面开发，数据更新等开始逐步深入。后面涉及到性能优化、自定义原生部分等。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]}]}