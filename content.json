{"meta":{"title":"IT技术博客","subtitle":"一个技术人的实验室","description":"全栈工程师/产品经理/游戏开发","author":"郭方超","url":"http://www.guofangchao.com"},"pages":[{"title":"关于我","date":"2018-03-14T07:30:30.000Z","updated":"2018-03-21T14:51:42.904Z","comments":true,"path":"about/index.html","permalink":"http://www.guofangchao.com/about/index.html","excerpt":"","text":"郭方超,生于1986年. 2012年-2015年,在泽旭担任技术工程师. 2015年-2016年,在瑞格传播担任项目经理. 2016年-2017年,在来吧旅行网担任前端架构师. 2017年-2018年,在达令担任前端架构师. 想加友链的可以在下面留言，请先加好再申请。","keywords":null},{"title":"分类","date":"2016-11-15T11:11:13.000Z","updated":"2018-03-21T11:26:06.964Z","comments":true,"path":"categories/index.html","permalink":"http://www.guofangchao.com/categories/index.html","excerpt":"","text":""},{"title":"帮助","date":"2018-03-14T14:42:32.000Z","updated":"2018-03-14T14:43:24.718Z","comments":true,"path":"help/index.html","permalink":"http://www.guofangchao.com/help/index.html","excerpt":"","text":"有问题可以在这个下面留言。","keywords":null},{"title":"友情链接","date":"2018-03-14T14:44:49.000Z","updated":"2018-03-14T14:45:25.610Z","comments":true,"path":"links/index.html","permalink":"http://www.guofangchao.com/links/index.html","excerpt":"","text":"个人博客","keywords":null},{"title":"标签","date":"2016-11-15T11:10:05.000Z","updated":"2018-03-21T11:27:30.193Z","comments":true,"path":"tags/index.html","permalink":"http://www.guofangchao.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RN的缓存策略探索","slug":"app缓存策略探索","date":"2018-03-28T11:26:00.000Z","updated":"2018-03-28T11:33:17.961Z","comments":true,"path":"2018/03/28/app缓存策略探索/","link":"","permalink":"http://www.guofangchao.com/2018/03/28/app缓存策略探索/","excerpt":"","text":"最近使用RN做APP，时间长了总是觉得接口请求是在太频繁。遂想到，不如给接口做个缓存吧。 这里申明一下，我是从前端开始接触RN，然后到APP的。对于APP原本是使用什么样的缓存策略还真的没有去深入了解。这里本着将前端的思想带入APP的原则来探讨一下使用RN来做接口部分的缓存策略。 服务器接口缓存最开始的时候只是希望减轻服务器压力，减少不必要的计算过程。比如用户数据没变化的时候就不需要去计算用户的各种数据，直接使用缓存就好了。 这里将服务器的接口返回数据根据策略缓存在redis中，然后根据上次更新之后的时间戳来判断是否需要重新计算缓存中的数据。 有人可能开始质疑。这个数据本来就是放在缓存中的，尤其是用户数据，根本不可能实时去计算。这里稍微说一下这个方案的背景。 后端计算和更新的数据其实已经存在在redis中了，但是在业务比较复杂的情况下，有些数据其实还是需要去获取的。这里的缓存其实类似于一个http的缓存。它的本意只是为了缓存最终接口需要返回的数据。这里使用redis去存储本来只是一个过度方案。打算使用这个方案的同学可以去关注一下varnish，这个才是真正的http缓存。 使用APP缓存这个阶段其实才开始算真正的缓存。 APP端会把第一次从接口获取到的数据缓存在本地，并且返回接口的时间戳。当下一次请求的时候直接带上这个时间戳去请求。 服务器根据这个时间戳去判断接口是否有更新，或者也可以定一个固定的时间。在这个时间段内默认缓存不过期。服务器返回304这样的http code。APP根据这个code判断缓存未过期，直接使用本地缓存的接口信息。 这样有很多好处： 减少不必要的计算 关键时刻可以立马更新接口数据，甚至可以灰度更新某些地区的、ip的用户缓存 不返回大块的数据，加速了请求速度 如果遇到网络错误，可以直接使用缓存的信息。相当于离线APP 使用接口hash将接口返回的数据看过一段固定的字符串，每次都计算字符串的hash值。这样可以更加方便的判断接口返回数据是否需要更新。 在上一步的策略中，接口返回的数据根据时间戳其实是根据接口更新的时间来定的。加入接口更新了，但是数据并没有变化，这个时候就会产生一次额外的请求。用户多的时候也是一个非常流量的操作。 如果使用hash来判断接口是否需要更新，这样就可以直接免去了这种无用的更新操作。相比上一个版本更加的高效。不过服务端计算hash让整个项目的复杂度又高了不少。这个就要考虑这样做是否值得了。 如果原有的更新策略已经完成了。比如刷新redis的策略已经做完了。其实这个时候将redis中的数据做一次hash也不费事，这样也可以非常简单的将缓存策略升级。 使用APP过期策略这里再提出一个更加激进的策略。假如某些接口的更新速度非常慢，我叫这些接口静态接口。那么每次的304请求是不是非常多余？ 这里就将这种接口设置一个固定的过期时间。在这个过期时间内，每次请求接口都会使用本地缓存，直到过期之后采取请求远程接口。 有人提出说，这种策略在后端有更新的时候不能即时的更新数据。别着急，更新数据也可以非常及时。 在所有接口之后，在新增一个本地缓存策略接口。将上述几个接口的状态放在这里。每次都请求后端接口，让后端来判断这个接口是否需要更新。比如：请求hash，如果需要更新就返回最新状态，不需要更新就不返回数据。 其他的静态接口在请求之前都会使用这个状态比较一次。如果需要更新就发请求，不需要更新就使用本地缓存。这样就完美的解决了接口缓存的问题。从一个每次都要请求接口变成了部分接口快速返回304，部分接口不请求。 RN开发的APP可以非常快的发布版本（热更新），同时开发的时候由于js的原因也会非常的灵活。这个时候使用上面的缓存策略会更加简单方便。 通过上述几个策略就可以减少非常多的无用请求。比如后端的热配置信息，很多时候其实没有改动，完全可以使用静态接口的策略。 进入APP的时候也可以先使用旧的数据展示列表，然后伺机更新。当然详情也和过期下架的产品还是要即时的排除掉的。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"},{"name":"app","slug":"app","permalink":"http://www.guofangchao.com/tags/app/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"修改centos的欢迎界面","slug":"修改centos的欢迎界面","date":"2018-03-28T04:34:00.000Z","updated":"2018-03-28T04:34:37.488Z","comments":true,"path":"2018/03/28/修改centos的欢迎界面/","link":"","permalink":"http://www.guofangchao.com/2018/03/28/修改centos的欢迎界面/","excerpt":"","text":"123456789101112131415161718192021 * , _/^\\_ &lt; &gt;* /.-.\\ * * `/&amp;\\` * ,@.*;@, /_o.I %_\\ * * (`&apos;--:o(_@; /`;--.,__ `&apos;) * ;@`o % O,*`&apos;`&amp;\\ * (`&apos;--)_@ ;o %&apos;()\\ * /`;--._`&apos;&apos;--._O&apos;@; /&amp;*,()~o`;-.,_ `&quot;&quot;`)* /`,@ ;+&amp; () o*`;-&apos;;\\ (`&quot;&quot;--.,_0o*`;-&apos; &amp;()\\ /-.,_ ``&apos;&apos;--....-&apos;`) * * /@%;o`:;&apos;--,.__ __.&apos;\\ ;*,&amp;(); @ % &amp;^;~`&quot;`o;@(); * /(郭方超的 技术博客 空间\\ `&quot;=&quot;==&quot;&quot;==,,,.,=&quot;==&quot;===&quot;` __.----.---&apos;&apos;#####---...___...-----._ 如果你的服务器已登录就提示上面的这一段信息是不是很漂亮啊。如果你还不知道怎么设置就来看看下面的教程吧。 这段信息其实存储在服务器的etc目录下:/etc/motd。只要使用vim打开即可看到默认的一段信息。如果你的服务器是阿里云，默认的是你的服务器名字等简单的一段信息。登录的时候也非常没有趣味。 提示:可以使用一点颜色,让显示更有趣 也可以修改脚本,当用户登录的时候显示用户的信息。比如修改root下的脚本。vi /root/.bash_profile 这里就非常随意了，直接在最后面加echo输出即可。也可以使用变量输出诸如磁盘用量等信息。12echo -e &quot;\\e[1;34mThis is a blue text.\\e[0m&quot;echo df","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/tags/服务器/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}]},{"title":"前端如何拥有自己的服务器","slug":"前端如何拥有自己的服务器","date":"2018-03-28T04:00:00.000Z","updated":"2018-03-28T04:00:39.414Z","comments":true,"path":"2018/03/28/前端如何拥有自己的服务器/","link":"","permalink":"http://www.guofangchao.com/2018/03/28/前端如何拥有自己的服务器/","excerpt":"","text":"前言作为前端开发者一直都在关注浏览器的行为、表现。但是时间长了免不了要接触到后端的知识、服务器的知识。尤其是在前端技术爆发式发展的当下，前端慢慢的渗透到了更多的领域。比如，使用 express/koa 创建 http 服务，使用React-Native开发Android和IOS通用的APP，甚至使用node开发系统、嵌入式程序等。这个时候，我的内心开始蠢蠢欲动，我们能做的不仅仅是网页。 首先，我需要一台服务器。上面有我需要的各种有用的库，每当我有新的想法需要实践的时候我就拿出来搞一波，简单快速成型。我不必依赖后端同事，我也不想占用公司的资源，哪怕是创业或者我想开发自己的软件/库，我也不会有任何的问题。 来看这篇文章的同学想必都是需要这么一个服务器的，刚开始学习的时候，我不建议大家使用复杂的环境，这个会带来大量的调试成本，同时页会遇到很多不可预知的错误，这里我推荐使用云服务器（其他同学可以使用虚拟机，效果也可以），大家根据我的教程就可以轻松愉快的创建一个完整的服务器。 准备我需要以下这些来完成后面的工作。 1.一个域名：下面将讲解使用 Nginx 管理自己的各个服务，一个域名是必不可少的，如果你经常使用域名那就更好了。2.一台Linux服务器：这篇文章主要在 Linux 上做各种开发，Window 的没有什么难度，网上也有很多教程，这里就不介绍了。作为一个服务器怎么能用 Windows 呢?3.如果使用 Windows 电脑做个人电脑，我这里推荐大家安装一个 xshell 做为连接服务器的工具，这个软件非常好用，其他诸如 Mac/Ubuntu 的请使用电脑自带的终端。 创建自己的服务器使用云服务器我这里推荐使用云服务器，相比使用自己的服务器，云服务器有很多方便的地方，而且云服务器提供一个一周的试用版，用起来非常的方便。 创建一个轻量级的服务器阿里云可以购买一台可使用一周的服务器，这个服务器正好用来做这次开发（已有的请跳过）。 登录阿里云，进入购买 CES 的地方，链接地址请单击这里。 依次选择： 计费方式：包年包月。 地域：华北5（当前华北5有优惠）。 实例：请寻找1vCPU、1G内存的实例（我最终选择了突发性能实例 t5）。 镜像：选择CentOS 7.4 （现在后端普遍使用6+的版本，7相比6有了很大改进，前端选择7可以减少很多麻烦），勾选安全加固。 云盘：40G高效云盘。 公网带宽：勾选自动分配公网 IP，选择1M带宽。 安全组：选择默认安全组，并勾选http80端口和http443端口。 购买周期：选择1周。 最终结果：我们的服务器主要做网站类的开发，所以有针对性需求的用户可以考虑将内存增大，其他在需要的时候采取考虑。 使用虚拟机如果你打算使用虚拟机，这可能会增加你的开发难度，而且效果可能和在自己的电脑上直接开发没有太大区别，这里虽然不推荐，我还是稍微讲一下吧。下面演示一下使用VM12虚拟机以及Ubuntu系统来安装一个虚拟机，安装是在windows系统下进行，这也是大多数安装虚拟机的场景了。 下载要安装的系统Ubuntu，下载地址。 下载安装VMware，这个请自行百度，产品激活密钥等也可以通过百度解决。 打开VM并创建一个虚拟机： 选择自定义： 单击下一步按钮直到这一步： 请输入一个已经存在的位置： 默认的配置已经足够了，请注意电脑的剩余空间： 下一步并选择硬件： 选择第一步下载的镜像： 下一步直到完成。此时已经可以启动虚拟机了： 选择中文简体，这也是选择ubuntu的一个重要原因： 这一步比较重要的是取消掉下载更新，不然你得到一个下载中的状态，国内网络不太好，下载会比较吃力，这里就直接取消了： 第一次安装的时候直接清除就好了： 点击下一步依据个人喜好选择键盘布局/位置等，然后输入自己的用户名密码就开始正式的安装了： 到这里就安装好了：以上基本就可以安装好一台虚拟机了，实际的使用上和一台真实的机器并没有太大的区别，剩下的请各位自行探索。本文主要介绍的还是在云服务器上的开发。 安装自己的开发环境到这里就可以开始第一次在Linux上开发了，是不是很兴奋? 连接到服务器Linux服务器不像window那样有一个可视化的界面，window/mac连接的时候也不像远程桌面那样方便。这里连接服务器需要使用命令才行。 window连接服务器好消息是window下有一款神器:xshell，命令可以很方便的输入到一台服务器或者多台服务器上，用户密码也可以很方便的保存在本地，多个服务器还可以分组，你要做的就是专注于眼前的服务器开发。 这个软件多用于常年跟服务器打交道的同学那里。如果你没有，可以找他们要一个。 首先你需要安转一个xshell，下载需要填一些信息，最方便的就是问同事要一个，安装非常简单，要注意的是安装的时候需要选择个人开发使用，不然安装好之后发现需要交钱才能用就坑了。 安装好之后你就可以把自己的服务器ip、用户名、密码都填好了，以后只需要鼠标一点就进入了自己的服务器了。 需要注意的是，选择一下默认的字符，不然你的中文会变成乱码。 连接之后的界面是下面这样。 首先有一个进入服务器的提示，然后下面就是熟悉的命令行了，不同的是前面那段显示的规则是用户名@机器名。 Mac连接服务器Mac连接服务器可以使用自带的终端应用，也可以自己下载一个iTerm2，这里我推荐使用iTerm2，可以方便的使用不同的主题，添加各种有用的插件。 打开iTerm2，输入连接命令ssh 用户名@ip地址然后回车，你会看到提示你输入密码，这个时候输入你在购买服务器的时候设置的密码就好了。 只要密码正确，你就可以进入服务器了，依旧是熟悉的命令行模式。 你会在第一时间看到服务器反馈的上次登录信息，欢迎信息，然后是命令行的提示，前面的显示规则是用户名@机器名，这里的欢迎信息是我自己改的，有兴趣的同学可以自行探索（比如显示一个美女）。 几个常用的命令要想使用Linux系统服务器做开发，不懂几个常用命令怎么行？ ssh 用户名@ip，连接服务器的命令。 cd 绝对路径/相对路径，跳转到路径对应的目录下。 rm 文件名，删除文件。 rm -rf 目录路径，删除目录以及目录下的所有文件，谨慎操作! ls [-a]，查看当前目录下的文件和目录，加-a参数可以查看所有文件，包括隐藏文件（.开头的文件是隐藏文件，默认是看不见的）。 ll，查看当前目录下的文件详情，可以文件的权限，遇到没有权限执行的情况下可以使用这个命令查看。 pwd，查看当前路径的完整路径，不知道自己在哪儿的时候可以使用这个命令查看。 which 名字，在几个默认位置查找改名字，比如查找pm2安装在哪个地方了。 mkdir 目录名，创建一个空目录。 cat 相对/绝对文件路径，查看文件的内容，多为查看日志或者其他文本文件。 cp 文件路径 目标路径，复制一个文件到另外一个地方。 mv 文件路径 目标路径，移动一个文件到另外一个地方，也可以重命名。 ps -aux，显示当前进程，有时候需要用这个查看进程是否存活。 kill -9 进程id，结束进程，进程id就是上一条命令查到的pid。 tar -zxvf 文件，解压缩文件。 tar -zcvf 压缩后的文件 要压缩的文件/目录，压缩文件。 vi 文件路径，使用vim进入文件的编辑模式。 vi退出文件，按下esc键保证退出编辑模式，输入:q或者:q!强制退出。 vi编辑，按下i左下角会提示进入编辑模式，然后就是正常的输入文字，再按esc键退出编辑模式。 vi保存编辑结果，按下esc键保证退出编辑模式，输入:x保存并退出。 后面还有很多内容,包括: 如何购买一个阿里云服务器？服务器的选择、系统的选择、怎么挑选最合算？ 安装 Node、PM 2 并备份系统； 安装 MySQL、Redis、Nginx 并配置安全规则，防止服务器被扫描； 部署一个简单的 Express 服务； 简单的数据库连接、PM2 守护、Nginx 端口映射； 写自己的脚本、真正的做到一键部署、一键重启。 文章地址:点击跳转","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/tags/服务器/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"使用Varnish加速http","slug":"使用Varnish加速http","date":"2018-03-28T03:17:00.000Z","updated":"2018-03-28T03:17:53.633Z","comments":true,"path":"2018/03/28/使用Varnish加速http/","link":"","permalink":"http://www.guofangchao.com/2018/03/28/使用Varnish加速http/","excerpt":"","text":"varnish是一个http缓存方案。它使用纯内存作为缓存对象，所以在速度上非常有优势。如果打算加速web服务器的图片等静态资源或者cookie、某些变动不频繁的接口等资源都可以使用Varnish来做加速。 普通情况下也可以使用nginx来做缓存，但是ngxin毕竟主业是反代。如果遇到大规模使用的情况下还是换个专业的吧。 可以使用安装包安装,这里给出一个在Red Hat和centos上安装的地址:https://packagecloud.io/varnishcache/varnish60/install#manual-rpm 也可以使用源代码安装git clone https://github.com/varnishcache/varnish-cache 还需要安装下面的几个依赖 autoconf automake jemalloc-devel libedit-devel libtool ncurses-devel pcre-devel pkgconfig python-docutils python-sphinx 之后编译源代码1234cd varnish-cachesh autogen.shsh configuremake 也可以在编译的时候做一次检测1make check 最后只需要安装到系统中就可以了1sudo make install 之后可以启动varnish服务了1service varnish start","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}],"tags":[{"name":"varnish","slug":"varnish","permalink":"http://www.guofangchao.com/tags/varnish/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}]},{"title":"React Native 实战：构建电商 App","slug":"React-Native-实战：构建电商-App","date":"2018-03-28T02:23:00.000Z","updated":"2018-03-28T02:24:44.903Z","comments":true,"path":"2018/03/28/React-Native-实战：构建电商-App/","link":"","permalink":"http://www.guofangchao.com/2018/03/28/React-Native-实战：构建电商-App/","excerpt":"","text":"课程介绍React Native 充分利用了 Facebook 的现有轮子，是一个很优秀的集成作品，使用 RN 即可做到无需编译就能远程热更新 App，再加上友好的开发方式、快到爆炸的开发效率、RN 已经完爆了其他的 App 开发方式，即使是一个初入前端的开发者也能迅速开发一套 iOS、Android 双平台的 App。 文章中将分三个部分讲解 RN 的开发。通过开发一个比较完整的电商 App 来逐步带领读者走入 React Native 的世界。读者可以从中汲取到完整的项目经验，从菜鸟到精通也只需要学完这个达人课即可。 第一部分主要讲述封装基本组件、简单页面的开发：这个阶段主要解决开发中遇到的兼容问题，在文中会提出解决方案、避免无用的代码。 第二个部分将讲述复杂的业务逻辑：让第一次做开发的读者也能非常快速的适应业务形态，让开发有底气、不再受制于产品的约束。 第三部分将讲述性能的极致优化、热更新、统计等这些 App 必须的东西，让开发的 App 能够真正的比得上原生 App 和混合 App。 该课程已经上线,需要订阅的同学可以点击查看课程地址","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"使用ReactNative的心得","slug":"ReactNative中遇到的问题","date":"2018-03-27T11:09:00.000Z","updated":"2018-03-27T11:15:25.477Z","comments":true,"path":"2018/03/27/ReactNative中遇到的问题/","link":"","permalink":"http://www.guofangchao.com/2018/03/27/ReactNative中遇到的问题/","excerpt":"","text":"适配iPhoneXRN版本0.52之后提供了适配iPhoneX的组件SafeView。不过单独这个是不行的，还需要在ios中修改配置，把视图从一个短小的区域拉伸到全屏的大小。 这里通过修改设置打开默认的安全区域。 由于之前使用的还是旧版的RN，这里我为了兼容旧的版本做了一个js的判断。通过判断高度是否符合812来判断是否iPhoneX。同时有一个小小的缓存，不需要每次都重复判断。这里的1.0.6是开始使用新能力的版本号。 添加额外的线程有些功能其实没必要跑在UI线程上。这些东西如果放在组件里反而不是那么融洽。甚至有时候会对正常的逻辑产生影响。 可以使用下面的方式注册一下额外的层。这个不显示UI，但是可以用来更新一些缓存，返回远程数据等。123AppRegistry.registerRunnable(&apos;RunableTask&apos;, TaskRun)AppRegistry.runApplication(&apos;RunableTask&apos;, &#123;&#125;); 在线上产品中就是利用了这一个层做了一些额外的事情。这里我使用事件触发的形式来做正常组件和这一个层的通知。 需要小心一点。如果在这一层做了定时器、循环事件等操作，记得要取消掉，不然事件就会变成两次。 缓存APP还是需要缓存的。这里可以缓存一些上次打开的数据，比如广告、用户信息等。 在打开APP的时候可以先用这些数据走正常的流程，然后在用一个异步的任务去鉴定、更新这些数据。这样下来可以让APP打开非常流畅，同时用户也不会发现数据变化大等异常。这些同时也是需要后端接口数据支持的。 关于Alert、Modal正常情况下Alert、Modal是独立于当前组件View之上的。如果这个时候遇到意外情况。比如组件销毁、暂停等情况下Alert还未销毁。这个时候就会发生比较严重的错误。 Alert大多数会报错，APP闪退。 Modal部分会报错，部分会暂停，失去事件等操作。导致APP一直停留在Modal视图上，用户也不能操作任何东西。时间长了系统就会判断APP未响应等等。 如果你不想处理这些东西，可以考虑使用一个自定义的Alert或者内嵌在组件中的View来代替Modal。 自定义组件在APP中其实有些属性是要经常用到的。比如Text组件的禁止使用系统字体大小，Image的缩放方式等。这些组件在平常使用过程中会经常重复添加各种属性，可以将这些组件独立出来，并且使用更加语义化的属性名来代替RN提供的使用方式。 在这个的基础上还可以将按钮、卡片等组件进一步抽象出来。对于不使用第三方开源组件的项目来说还是很有必要的。 解决遇到的问题使用RN开发会遇到很多问题，这些问题都可以在RN的Issues中找到答案。如果还没有就上google去搜一下，这个要求使用科学上网的形式。 有些问题需要修改RN的代码。不要怕麻烦，如果是js部分的修改，直接将下载的包修改成可上传的包就行了。这里记得上传到私有npm库中。如果是native的问题最好是在自己的native代码中覆盖掉旧的代码，毕竟前端去编译RN的源代码还是有很大的风险的。 不要去百度，百度真的没有答案。 按钮RN提供的按钮其实很丑，正常开发的时候大家都是使用自定义的按钮。 使用这种模式做出来的按钮非常漂亮，也更能符合设计的结果。不过使用的时候尽量不要给按钮本身加样式，有样式尽量添加到内部的View等组件上。 向下兼容RN使用的过程中我们升级了一个大的版本，从0.40系列升级到了0.50系列。由于大部分手机用户还存在不愿意升级APP的情况，向下兼容成了唯一的选择。 我使用的策略是修改源代码。。。。 比如升级0.53的时候发现有些native组件名变了。原来使用的是RCTMultilineTextInputView，现在变成了RCTTextView。不管RN出于什么理由改变了这个组件名字，造成的结果就是现在的旧代码不能跑在新的APP壳下。 我们可以打印出NativeModules的UIManager对象看看。 而兼容也是从这里开始做的。我们判断一下当前的RN是否在UIManager中提供了对应的原生组件即可判断当前的环境是否正确的环境。 比如要升级到53，修改53的源代码react-native/Libraries/Components/TextInput/TextInput.js。1234567891011121314//安卓的没变化,要排除if (Platform.OS === 'android') &#123; var AndroidTextInput = requireNativeComponent('AndroidTextInput', null);&#125; else if (Platform.OS === 'ios') &#123;//如果支持RCTTextView,既新APP if(UIManager.RCTTextView)&#123; var RCTMultilineTextInputView = requireNativeComponent('RCTTextView', null); var RCTSinglelineTextInputView = requireNativeComponent('RCTTextField', null); &#125;else&#123; //其他情况 var RCTMultilineTextInputView = requireNativeComponent('RCTMultilineTextInputView', null); var RCTSinglelineTextInputView = requireNativeComponent('RCTSinglelineTextInputView', null); &#125;&#125; 使用类似这样的手段就能区别两种APP壳的环境。用户在使用的时候也不至于要必须升级APP才能使用新版APP的功能了。 使用RN开发APP确实非常快，但是各位在开发中还是不要忘记钻研RN的源代码。很多解决方案其实很简单，有些时候可能只是由于低版本的APP不支持而导致的。 如果你想对RN有一个进一步的了解，还需要对原生的代码也有一定的了解。当然正常情况下还是有位这方面的同事一起开发比较好。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"科学而自由的上网指南","slug":"科学而自由的上网指南","date":"2018-03-25T09:03:00.000Z","updated":"2018-03-25T09:04:06.079Z","comments":true,"path":"2018/03/25/科学而自由的上网指南/","link":"","permalink":"http://www.guofangchao.com/2018/03/25/科学而自由的上网指南/","excerpt":"","text":"前段时间和谐大神比较厉害,我辈码农的很多自由上网工具都被墙掉了.我也是其中的一员…. 其实我基本上是不用的,国内的资源很多很丰富.在大多数时候一个百度就解决了问题了.偶尔遇到一些比较奇怪的问题才会去了解一下国外大神的想法.这个时候就有很大的可能遇到打不开的情况.凑巧这个时候之前用的收费工具不能用了.真的是让人着急啊. 索性我还是自己想办法吧.别人搭的商业服务不行,这里我就自己搭一个纯私人的服务算了. 首先要选择一个合适的服务器.这里首先就排除了阿里腾讯等国内大公司产品,其次亚马逊这种费钱的大户也是不考虑的.这里稍微推荐几个靠谱的专业服务器提供商. Vultr.机房遍及各大州,资源非常丰富.正常服务器500G/月流量,512MB的内存.价格为2.5$/月.不过很多时候有优惠,可以拿到1.5$/月的服务器.通过优惠地址还可以在第一次购买的时候增加更多优惠.优惠地址:https://www.vultr.com/?ref=7331073 sugarhosts.提供Sata和SSD两种硬盘VPS,49￥/月. 搬瓦工.机房非常多,目前年付低至19.99美金，多机房可选/切换. 如果你打开vultr之后发现可以购买1.5$的服务器,不要犹豫,马上下手吧.这个服务器几乎是全网最便宜的了.如果没有也可以换换搬瓦工,20$/年算下来也是非常便宜了.一月才用了1G的流量…. 我这里就是买了一个1.5$的服务器.速度算不上快,但是看个facebook的视频还是可以的.系统挑的是centos7, 在vultr上面购买服务器之后需要安装ss才能安全自由的上网.可以在github上面搜索源代码https://github.com/search?utf8=%E2%9C%93&amp;q=ShadowSocks&amp;type= 第一个就是ss的地址,打开之后看到的是一个默认的空地址.其实这里是个假象,只需要切换到master分支即可.https://github.com/shadowsocks/shadowsocks/tree/master 这里顺便提供一个ss管理端的地址https://github.com/orvice/ss-panel/tree/master 执行一键安装脚本.这里使用的是别的大神整理好的脚本,直接安装成功.这个脚本是centos上安装的脚本.别的系统没有试过,不确定是否可行.123wget --no-check-certificate -O shadowsocks-libev.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.shchmod +x shadowsocks-libev.sh./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log 安装过程中会提示输入ip/端口等信息.12345Congratulations, Shadowsocks-libev server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_method 到这里基本上就安装成功了,有一些改动也可以根据官网的教程来修改配置文件. 也可以自己优化ss的效率,提高ss的速度.这里推荐一个优化文章,链接地址 ss已经停止更新了,有兴趣的可以转向研究ss的进阶版本ssr.","categories":[{"name":"资源","slug":"resource","permalink":"http://www.guofangchao.com/categories/resource/"}],"tags":[{"name":"自由","slug":"自由","permalink":"http://www.guofangchao.com/tags/自由/"},{"name":"科学","slug":"科学","permalink":"http://www.guofangchao.com/tags/科学/"}],"keywords":[{"name":"资源","slug":"resource","permalink":"http://www.guofangchao.com/categories/resource/"}]},{"title":"使用google的免费服务运行机器学习代码","slug":"使用google的免费服务运行机器学习代码","date":"2018-03-23T02:14:00.000Z","updated":"2018-03-23T02:15:00.418Z","comments":true,"path":"2018/03/23/使用google的免费服务运行机器学习代码/","link":"","permalink":"http://www.guofangchao.com/2018/03/23/使用google的免费服务运行机器学习代码/","excerpt":"","text":"如果你想学习机器学习,但是又没有一个自己的环境/显卡.这里告诉大家一个好消息,google上面有一个免费的机器学习环境可以使用了. 在google搜索google colab,打开搜索到的地址:https://colab.research.google.com 默认会提示创建一个新的记事本.这是因为google提供的是一个笔记本的环境,所有的代码都是存储在一个个的记事本中的. 这个时候可以点击取消查看默认的案例. 从案例中可以看到代码和文档是直接结合在一起的,同时可以在代码的最下面看到执行的结果.这里稍微注意下一下,每段代码都是单独的一行. 可以在之前的界面点击创建,也可以在左上角的文件中选择创建.可选的有python2和python3这两种版本,根据自己的喜好来选择就好. 创建之后记得选择执行代码程序下的更改运行时类型. 在下面的硬件加速器中选择GPU,这样之后的代码就运行在gpu上了.再也不怕家里的电脑没gpu了. 这里添加一行代码,输入下面的一个案例.然后点击左侧的运行按钮,这样就可以在下面看到运行的结果了.1234567import matplotlib.pyplot as pltimport numpy as npx = np.arange(20)y = [x_i + np.random.randn(1) for x_i in x]a, b = np.polyfit(x, y, 1)plt.plot(x, y, 'o', np.arange(20), a*np.arange(20)+b, '-');","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.guofangchao.com/categories/机器学习/"}],"tags":[{"name":"google","slug":"google","permalink":"http://www.guofangchao.com/tags/google/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.guofangchao.com/categories/机器学习/"}]},{"title":"hexo添加seo优化","slug":"hexo添加seo优化","date":"2018-03-22T06:26:00.000Z","updated":"2018-03-22T06:43:35.341Z","comments":true,"path":"2018/03/22/hexo添加seo优化/","link":"","permalink":"http://www.guofangchao.com/2018/03/22/hexo添加seo优化/","excerpt":"","text":"站点收录一般来说你的网站搭建好后依旧是无法在各大搜索引擎中搜到的，具体可以通过在搜索引擎输入site:你的域名验证。所以你需要提交你的站点到各大搜索引擎： https://ziyuan.baidu.com/linksubmit/url https://www.google.com/webmasters/tools/home?hl=zh-CN 文件收录:1.需要先下载验证文件，将下载的文件放到站点根目录/source文件下2.在站点配置文件中找到skip_render:修改： 1234skip_render: - README.md - CNAME - baidu_verify_XXXXXXXXXX.html #下载的文件名 token验证1.把图中马赛克部分的token复制下来2.打开主题配置文件，搜索site_verification，修改： 添加站点地图sitemap安装hexo的sitemap网站地图生成插件12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save","categories":[{"name":"资源","slug":"resource","permalink":"http://www.guofangchao.com/categories/resource/"}],"tags":[{"name":"seo","slug":"seo","permalink":"http://www.guofangchao.com/tags/seo/"}],"keywords":[{"name":"资源","slug":"resource","permalink":"http://www.guofangchao.com/categories/resource/"}]},{"title":"react-native:一场APP中的革命","slug":"react-native-一场APP中的革命","date":"2018-03-20T03:35:00.000Z","updated":"2018-03-20T03:35:47.605Z","comments":true,"path":"2018/03/20/react-native-一场APP中的革命/","link":"","permalink":"http://www.guofangchao.com/2018/03/20/react-native-一场APP中的革命/","excerpt":"","text":"记得从2010年开始，前端就逐渐绽放光芒。 在那之前的我还是一个勤恳的后端工程师，每天的工作就是一边干着后端代码一边还要写一点table之类的前端代码。嗯，也算不上前端，仅仅是一个又一个表格的嵌套而已。那个时候的前端真的是个垃圾啊。 也就在那一年，我第一次转做开发web应用，依然记得跟我配合的是一个可爱的前端妹子。从前端妹子身上我学到了基础的前端开发方式，也就是在那一年我认识了锋利的jquery。那是怎样一种不同的语言啊，简单快速、上手就能使用、即时产生效果。一些好看的效果实现出来真的是又快速又简单。我回头看了看无趣的java代码…..嗯，小妹妹教教我好不好？ 从此真可谓一发不可收拾啊。我从jquery入门的前端，又回头研究了原生的各种使用姿势。一座新世界的大门从此向我打开。我开始制作各种有意思的小组件。有改了好几个版本的无限循环的轮播图一个系列。电脑手机上自适应网页宽度的各种姿势。导航等菜单中使用到的下拉列表的各种特效。各种效果的网页加载使用的loading动画。一路走来我深深的喜欢上了这种写完就能看效果，而且效果还日常爆炸的技术。 当我以为这就是前端的全部的时候，我看到了模块化技术。原来我之前骑的是自行车，果然我还是太年轻了。模块解决了大型项目分工合作的问题，顺便让网页加载的更加流畅，一举多得莫不过如此把。 我以为模块化已经非常厉害了，但是牛人的世界我不懂。后面有陆续遇到了gulp、babel、webpack，一个更比一个厉害，它们的思想真正让我知道，世界还可以这样子。至于后来遇到的了SPA应用，嗯，这个spa有点爽。果然，在一个适当的机会，我当机立断转战vueJs。 在不知不觉中前端的触角已经蔓延到了整个世界。尤其是在我们有了nodejs之后。曾经的一个脚本语言，由于各路神仙的加入，再加上它天生的开源基因，一个广阔的世界已经在向各位前端开发者走来。还有什么是我们做不到的呢？ 在之前一直想要做一个自己的APP。但是开发一个APP非常的麻烦，不仅仅是还需要学习安卓的开发语言和模式，同时要开发ios还需要再学习一套oc的东西，如果你还要兼容swift设置wp….我的天，想想就不开心一整天。 仔细想想我还能回忆曾经上手安卓代码的那段艰难岁月。下了一整天的SDK，后来才发现可以找国内的源。搞了一天的编辑器，最后还是屈服于Android studio，那个时候真的很少有好用的IDE。复杂的配置、艰难的界面布局、状况频出的开发过程。。。。。心酸啊。本来好好的学习心态也只剩下了无尽的挣扎。 我在想facebook的开发者们也肯定是这么想的，不然不会出现react-native。这真的是一个天才的想法，一下子解决了很多疑难杂症。虽然它目前还处在测试版本，这决定了它还有很多问题，开发的时候也许会遇到一些麻烦。但是核心的问题确实被真正的解决了，开发一个APP再也不是巨大的工作量了。 不需要一个陡峭的学习曲线，一个前端开发者就可以快速开发一个自己的APP。不在需要多个团队配合，一个团队搞定所有平台。顺便使用nodejs搭建一个后端接口，再配合MongoDB或者MySQL，完美！ 当我使用几天的时间开发完一个完整的APP的时候，我最大的感受就是—爽。 真的不需要再费力发布APP客户端了。一次安装永久最新，只需要更新服务器的js版本就能做到让用户更新最新的UI界面。升级过程用户完全无感知。客户端版本升级？那是什么。 再也不需要做2套代码了。开发iOS和Android只需要一套前端代码。在强大的社区帮助下，RN几乎支持所有的原生功能。一个团队只需要配备一个懂原生的开发就能轻易添加各种自定义的原生支持，想要加速某些方面只需要随着自己的心意自定义就好了，RN提供了完整的自定义流程。还有什么不满足？ 不需要做什么原生的开发，一个稍微复杂的APP就可以诞生出来。这得益于活跃的社区和热情的开源共享者。只需要npm和react-native短短一条命令，就跟安装web的第三方包一样简单。native就已经安装好了你需要的各种包，一切都是那么的简便。开发效率翻倍的提升。需要的开发人员翻倍的下降。 往常两个团队才能开发的项目，现在只需要一个团队。如果是简单项目甚至两三个人就搞定了。如果前端开发同学比较全面的话….仔细想想吧，一个前端搞APP，一个前端搞接口，一个前端搞DB。哇！前端搞定整个项目。 如果你真的想要学习一下这种高大上的技术，请在gitbook.cn上搜索react-native的实战达人课。一个真实的案例加一个资深的老师教你开发一个完整的电商APP。 前端才是真正的艺术，哈！","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"成就匹配算法解析","slug":"成就匹配算法解析","date":"2018-03-16T15:26:00.000Z","updated":"2018-03-20T06:35:03.829Z","comments":true,"path":"2018/03/16/成就匹配算法解析/","link":"","permalink":"http://www.guofangchao.com/2018/03/16/成就匹配算法解析/","excerpt":"","text":"今天遇到一个问题： 有4个固定的成就，每个成就对应一个数字。用户的积分超过这个数字自动获得这个成就将这个方法作为一个公用的方法 考虑如下：1.必须是一个单独的方法（多余）2.输入参数固定为积分数量3.输出参数包括当前成就名称，到达下一级需要的积分，下一级成就名称4.扩展要好，下次修改不用改太多5.性能要好，不能出问题 以下是JavaScript的实现版本。 123456789101112131415161718/***输入积分数，返回成就信息集。包含积分+1操作*num &#123;Number&#125; 当前积分数量*return num &#123;Number&#125; 距离下一级需要的积分数量*return type &#123;String&#125; 当前达到的成就名称*return next &#123;String&#125; 下一级的成就名称*/function test(num)&#123; var score_list=[0,500,2000,7000,16999]; var type_list=[\"\",\"专访\",\"百科\",\"群展\",\"个展\"]; var index=score_list.length-1; while(num&lt;score_list[index])index--; return &#123; num:score_list[index+1]-num, type:type_list[index], next:type_list[index+1] &#125;&#125; 可以考虑将2个数组放在外面节约一下空间，我这边的实际情况就不需要考虑了。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"算法","slug":"suanfa","permalink":"http://www.guofangchao.com/tags/suanfa/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"AppRegistry详细解析","slug":"AppRegistry详细解析","date":"2018-03-16T15:14:17.000Z","updated":"2018-03-16T15:16:28.673Z","comments":true,"path":"2018/03/16/AppRegistry详细解析/","link":"","permalink":"http://www.guofangchao.com/2018/03/16/AppRegistry详细解析/","excerpt":"","text":"在React-native中有一个api叫AppRegistry。这是RN中的一个重要api。 接口介绍 static registerComponent(appKey, componentProvider, section?)注册组件，js中非常重要的一步，只有这里注册了，native code中才会找到要执行的js。 static registerRunnable(appKey, run)注册一个新的线程，通过第一个参数来区分，第二个参数是一个方法。 static runApplication(appKey, appParameters) #根据key来执行对应的应用（例如使用Runable注册的）。如果appKey不存在会报错。 static getAppKeys()获取注册的所有线程。其中包括第一步注册的Component和后面注册的Runable static unmountApplicationComponentAtRootTag(rootTag)结束应用，不传参数默认结束appKeys中的第一个 static registerHeadlessTask(taskKey, task)创建一个任务，这个线程不支持UI。 static startHeadlessTask(taskId, taskKey, data)执行对应的任务。（暂不支持） static registerSection(appKey, component)注册一个切片 解释 appKey用到这个参数的地方，使用方法都一样 registerHeadlessTask这个方法的第二个参数是一个方法，要求返回的是一个Promise对象","categories":[],"tags":[],"keywords":[]},{"title":"04.基础-组件和商品详情","slug":"04-基础-组件和商品详情","date":"2018-03-14T14:40:00.000Z","updated":"2018-03-14T15:19:25.735Z","comments":true,"path":"2018/03/14/04-基础-组件和商品详情/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/04-基础-组件和商品详情/","excerpt":"","text":"知识点：1.使用路由跳转内页2.开发完整的商品详情页3.弹出选择数量 前面的代码已经加入git仓库，链接地址。讲项目放在本地的同学也可以试着将代码放到仓库里。这个地方可以使用单独的分支合并到master，也可以直接覆盖带master分支。 为了能够更直观的看到每次提交的代码，我尽量把每一节的内容都做一次提交，备注也会写的非常清楚.另外我也会不定时的增加各种注释到代码里。一般情况只需要切换到不同的提交时间点即可看到当时使用的代码了。 添加页面和跳转在src目录下添加一个新的目录detail，用来放新加入的详情页。新建goods.js，并写几行简单的代码。 在src下的index.js中，将新建的页面加入到路由里。 这样新建的详情页就加入了路由管理，只要在需要跳转的时候执行传入路由的名字就可以了。这里改造home页，将几个地方的跳转改成刚才的路由名称就可以了。 点击商品就会发现已经可以跳转到详情页了，但是现在详情页什么都没有。同时也不能返回到上一页。 自定义顶部在src下新建一个component目录，用来存放头部组件以及以后会用到的一些其他组件。将组件抽成一个公用的组件是一个非常明智的方法，它会让你省下很多的时间。最好的做法就是做一个兼容很多情况的组件，然后使用继承的方法做一些参数的重载。 改造这个组件，让ios的顶部和安卓的顶部高度一致，把ios顶部的系统组件露出来。默认情况下ios顶部在小图标下面，安卓则有一个系统的顶部横条，小图标不影响正常的界面。 顶部组件默认有一个中间的标题，下面再加一个默认的左侧返回键。返回键使用的是路由组件的gobanck方法。右侧给一个自定义右侧按钮的方法。 把这个自定义组件放在详情页，然后给一个title值。一个简单的顶部组件就做完了。 刷新页面看效果，点击一下返回键，看看是不是可以用了。 详情页顶部上半部分包括头图和几个属性介绍。 详情页的所有内容使用ScrollView包裹。这是一个比较简单的列表组件，使用非常方便。在列表不长的情况下请尽量使用这个组件。 将路由传进来的参数保存在组件的变量里。由于传入的参数有2个，所有这个地方使用了2个变量，同时后面做判断的时候也要判断2次。 在组件初始化之后调用接口，将接口返回的数据存入组件的state中。这里注意把state中的变量提前写好，减少不必要的bug。 在最上面添加一个商品图片，然后接着添加价格等信息。 到这里，详情页的简单信息就实现了。后面再添加一个详细的商品信息就可以了。 这里需要注意的是,接口返回的图片有大有小，这里做了一个处理,图片太大的话就缩小一些。 最终效果和正常的电商APP就很相似了。如果有特殊的样式还可以再自己调整。 上面的开发完成之后图片是同时加载的，导致有时候上部分的图片显示延迟，后面优化的时候会优化这种情况。 购买和加入购物车展示的界面有了，下面再加上加入购物车、购买等按钮就可以了。 按钮要求悬浮在界面的最下方，所以要将这几个按钮放在ScrollView的后面。放在里面虽然也可以做到，但是非常不推荐，这样会增加渲染难度。 这里有3个按钮，分别是购物车、立即购买和分享商品。 购买弹出层点击立即购买按钮不会直接跳转到下单页，这里会弹出一个简单的选择数量的页面。在RN中如果需要使用这样的一个层就需要用Modal组件来做。Modal在RN中是一个单独的view层，默认覆盖在所有的页面上面。 这里设置Modal不使用默认的动画、全完透明，给onRequestClose添加一个默认的方法，不然会在手机上报错。 首先给Modal加一个内容层。这一层的主要作用是自己做遮罩的样式。这里是一个半透明的黑色遮罩。内部加一层点击区域，效果等于再点击黑色透明层的时候能够关掉弹出层。123456 &lt;View style=&#123;SpecificationsStyle.warp&#125;&gt; &lt;TouchableOpacity activeOpacity=&#123;0.9&#125; style=&#123;&#123; width: px(750), flex: 1 &#125;&#125; onPress=&#123;() =&gt; this.setState(&#123; priceBoxStatus: false &#125;)&#125;&gt;&lt;/TouchableOpacity&gt;&lt;/View&gt; 接下来开始写商品简略信息，包括商品小图、价格。 下面再加一层用来放选择商品数量和购买按钮。 最后把几个事件实现一下。123456789101112131415161718192021222324252627282930313233343536373839//购买方法 openbuy() &#123; this.setState(&#123; priceBoxStatus: true &#125;) &#125; //数量减少 reduce() &#123; if (this.state.buyNumber == 1) return; let buyNumber = Number(this.state.buyNumber) || 2; if (isNaN(buyNumber)) buyNumber = 2; this.setState(&#123; buyNumber: --buyNumber &#125;) &#125; //改数量 changeNumber(num) &#123; num = Number(num); if (isNaN(num)) num = 1; if (num &gt; this.state.limitStock) &#123; num = 1 toast(`库存不足`); &#125; this.setState(&#123; buyNumber: num &#125;); &#125; //增加数量 plus() &#123; if (this.state.isBuyLimit == 1 &amp;&amp; this.state.buyNumber &gt;= this.state.buyLimitNum) &#123; toast(`该商品为限购商品,$&#123;this.state.buyLimitMsg&#125;`); return; &#125; if (this.state.buyNumber &gt;= this.state.limitStock) &#123; toast(`库存仅剩$&#123;this.state.limitStock&#125;件`); return; &#125; let qty = this.state.buyNumber || 1; if (isNaN(qty)) qty = 1; this.setState(&#123; buyNumber: ++qty &#125;) &#125; 最终效果如图。点击立即购买按钮即可弹出这一个弹出层。弹出层可以选择数量，默认保持数量为1，受库存以及最大可选择的数量影响。也可以直接点击按钮跳转到购买页。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"03.基础-首页模板和商品列表","slug":"03-基础-首页模板和商品列表","date":"2018-03-14T14:39:00.000Z","updated":"2018-03-14T14:39:49.655Z","comments":true,"path":"2018/03/14/03-基础-首页模板和商品列表/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/03-基础-首页模板和商品列表/","excerpt":"","text":"知识点：1.给首页添加banner2.给首页添加运营模板3.获取接口的商品4.给顶部加一个搜索条 从这章开始我们正式开始案例的开发。git仓库的地址会放到下一章显示，需要的同学可以直接去git上看每一次提交的代码。 本文先从最早的代码形式开始一步一步的讲下去，开始开发的app会在某些情况下很卡，后面会将优化需要做的东西讲出来。这里先从简单的实现app界面开始讲，如果你觉得手机反应慢，请看后面的优化部分。 首页容器修改首页index.js文件,创建一个容器,用来放置后面要添加的各种组件。 Banner和快捷入口这里的Banner用到了一个轮播图组件。根目录下执行npm i --save react-native-swiper安装新的组件。 创建一个组件，这个组件用来放Banner和快捷入口。 这里创建state中变量，banners用来存储banner列表，quicks用来存储快捷入口的列表。 请求远程接口，将返回的数据放入state中。 将banner渲染再页面上。这里有一个小技巧，如果只有一张图片就不再使用轮播图。 接下来就是快捷入口，由于快捷入口用到了gif图。所以这里添加一个第三方的组件react-native-fast-image。在线的项目使用的是官方推荐的设置方法，让RN的image组件支持的gif。 执行npm i --save react-native-fast-image，然后使用link命令将组件加入到原生代码里。react-native link react-native-fast-image，执行完毕重新运行模拟器react-native run-ios。 将state中的数据渲染在banner的下面。这里用到了几个组件和一个新的图片，需要单独添加。ImageBackground是RN在0.47之后的版本加入的组件，它可以将一个图片当做背景来使用。这里推荐在0.50之后的版本中使用。 刷新模拟器看看效果。一个简单的banner+入口的界面就显示出来了。是不是非常简单！ 自定义模板从入口下面开始就是一个自定义的模板。这里使用现成的接口，现成的设计来做模板。运营人员会在后端传入图片并设置跳转链接。app根据设计好的样式渲染模板结果。目前有8个模板在使用，后面可能会添加更多。这里先不管后面的新模板。 在home下新建一个floor_modules.js文件。自定义模板单独放在这里处理。这里由于代码比较长就不贴出来了，有想看具体情况的可以去git仓库看。 到目前为止使用还是View组件。这个组件是不支持滑动的，要想列表可以滑动，需要将渲染结果放在专门的列表组件中才行。这里不适用ScrollView的原因是，FlatList可以在滚动的时候隐藏屏幕外的无用节点。可以提高列表性能，尤其是列表非常长的时候。 把刚才写的2个组件放到Flatlist中的header组件中ListHeaderComponent。 使用numColumns设置列表为双列。 使用refreshing传入下拉刷新使用到的变量。 使用onRefresh在下拉刷新的时候重新获取列表数据 使用onEndReached在滑动到列表底部的时候加载下一页 使用ListHeaderComponent渲染列表的头 使用renderItem渲染列表项。 使用ListFooterComponent设置底部的文字，一般可以给加载下一页展示加载的状态、文字。 使用onScroll在滑动的时候触发自己的事件。这里使用scrollEventThrottle控制触发的频率，内部的数字就是1000毫秒内触发的次数，数字越大触发越少。 使用keyExtractor设置列表每个项的key。在列表判断列表项的时候会使用这个返回的id作为key。注意，这里返回的值不能重复。 使用data设置商品的项，必须是数组。 商品列表首先给上面的2个组件添加一个名字，然后在刷新方法里调用他们的刷新方法。这样就可以做到在下拉刷新的时候同时可以刷新前面2个组件。 添加一个请求数据的方法并在组件初始化结束之后调用方法。这里使用await来达到同步等待请求结果的效果。注意，必须使用try来包裹这个方法。否则在返回错误信息的时候会发生app奔溃的效果。 这里设置了一个start变量来存储页码。这里注意一下，只有需要改变UI的变量才需要放到state里面，其他的尽量放到组件自身上面或者其他地方。否在在改变一些无意义的数据的时候也会触发界面刷新。 这里把加载下一页单独写成一个方法了。有的手机在初始化列表的时候不仅会调用一次获取第一页的方法，同时也会调用一次下一页的方法。 新建商品列表组件GoodItem，修改Flatlist组件，把GoodItem放到内容渲染方法里。 这里将数组序号也传入组件，目的是给商品列表的每一项添加一个不一样的样式。这里设置的样式在安卓和ios上会有不同的效果 通过取余方法即可完成每行有2中不同的样式。这在双列的列表中非常的常用。 首页列表中的这个大块头部组件和列表中的非常多得商品项会暴露出很多问题。后面会把这一块优化，以达到和原生一样的效果。 头部组件初步开发已经完成了。但是我们还需要在这个的基础上再加上头部组件，这个组件负责显示用的一些信息和一个假的搜索条。这样才是一个完整的APP该有的样子。 添加一个SearchHeader组件，用来做商品列表页的顶部。1234567//顶部搜索条组件class SearchHeader extends React.Component&#123; render()&#123; //这里先不去管具体的内容 return &lt;View&gt;&lt;/View&gt; &#125;&#125; 将组件放在最外层，同时使用绝对定位将顶部浮动在所有组件的最前面。这里先不讲动画，看着难受的同学可以先把浮动的组件改成普通的组件。 123456789101112131415161718const styles = StyleSheet.create(&#123; headerView: &#123; position: \"absolute\", left: 0, right: 0, top: 0, zIndex: 100, &#125;, pageView: &#123; flex: 1, width: deviceWidth, &#125;, loading: &#123; textAlign: 'center', fontSize: px(28), color: \"#ccc\" &#125;,&#125;) 顶部添加一个头像显示组件，中间添加一个输入框。这里的输入框没有实际的功能，主要是为了跳转到真正的搜索页的。 到这里基本就开发完了。将它们组合在一起然后刷新页面。 完成到这里就完成了基础的首页开发。一个简单的首页就呈现在外面的面前。如果懂打包的同学已经可以马上打一个apk文件了。这里稍微注意一下，模拟器使用的是ios，打包最方便的还是安卓，但是ios和安卓在某些情况下会有一些区别。比如样式上会根据手机的不同有一些不一样的效果，有些组件甚至只支持ios。 在浏览的时候也会看到滑动会有一些生涩，点击跳转也没有做。顶部最好有一些动画等等。这些在后面都会有涉及。图中就是在说列表太长导致更新很慢，同时还提醒开发者使用PureComponent来优化性能。后面会教大家怎样使用purComponent和shouldComponentUpdate来优化性能。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"02.基础-封装自己的库","slug":"02-基础-封装自己的库","date":"2018-03-14T14:38:00.000Z","updated":"2018-03-14T14:38:48.692Z","comments":true,"path":"2018/03/14/02-基础-封装自己的库/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/02-基础-封装自己的库/","excerpt":"","text":"知识点：1.封装一个自己的日志，代替原生的console2.封装一个自己的请求库，代替原生的fetch3.自适应方法，兼容各种手机屏幕4.封装一个本地存储5.集成toast弹出提示6.让iOS支持http地址7.安卓需要证书才能编译 在正式开始之前，我们先封装几个要用到的库。 自定义本地日志自定义日志的一个好处就是省的每次都要手动注释console。而且还可以同时将日志存在本地，或者发到日志服务器。一个方法就一举多得了。 在src目录下新建一个utils文件夹。我们封装一个日志输出类。开发模式下使用console.log命令。正式情况下记录在变量中，方便在手机上查看日志。 新建一个log.js文件。路径为根目录/src/utils/log.js。 新建一个数组变量logs，用来临时存放日志信息。 将日志分成信息、警告和错误3种，分别给出3个可调用的方法。同时给第一个参数加一个好看的颜色。 在index中引入日志组件，写几个方法看看调用的结果。 这里稍微定义一下日志的要求。参数0，字符串。参数1，对象。参数2，字符串。 自定义请求RN默认提供了fetch方法去请求远程数据。我们再封装一次，将这个方法将会针对现有的项目做封装，在使用请求的时候能够更适合、更方便。这里使用header保存了一些临时的变量，算是一个小小的全局缓存吧。 创建request.js文件，目录：根目录/src/utils/request.js。 将请求header里的信息单独出来，每次请求都需要带上这个共享header数据。 创建一个Request类,并将这个类对外公开。这里讲请求初始化一次，以后用到别的请求的时候也可以单独实例化一次。123456/** * 请求库 */class Request &#123;&#125;export default new Request(); 每次请求都将header中的内容带入请求中，单独检测httpcode和后端返回的code值。这里可以直接做权限检测，在需要的时候跳转到登录页。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 请求库 */class Request &#123; /** * 检测返回状态码 * @param &#123;*&#125; status * @param &#123;*&#125; res */ async _checkStatus(status, res, url) &#123; if (status !== 200) &#123; logWarm('请求失败参数', await res.text(), url, headers); throw new Error('网络连接失败，请检查网络'); &#125; &#125; /** * 检查后端返回的状态码 * @param &#123;*&#125; status */ _checkAppStatus(json, url) &#123; if (json.status != 0) &#123; logWarm('返回状态报错', json, url); throw new Error(`$&#123;json.errorMsg&#125;`); &#125; &#125; /** * 内部实现网络请求 * @param &#123;*&#125; url * @param &#123;*&#125; options */ async _request(url, options, type) &#123; url = url.indexOf('http') == 0 ? url : url.indexOf('/api') == 0 ? domain + url : baseUrl + url; let res = await fetch(url, options); this._checkStatus(res.status, res, url) if (type === 'json') return await this._jsonFactory(res, url, options) return await this._jsonFactory(res, url, options) &#125; /** * 处理json数据 * @param &#123;*&#125; res * @param &#123;*&#125; url */ async _jsonFactory(res, url, options) &#123; let json; let txt = ''; try &#123; txt = await res.text(); &#125; catch (e) &#123; log('未拿到返回字符串', &#123; url: url, txt: txt &#125;); throw new Error('数据格式错误'); &#125; try &#123; json = JSON.parse(txt); &#125; catch (e) &#123; logErr('返回数据格式错误', &#123; url: url, txt: txt &#125;); throw new Error('数据格式错误'); &#125; this._checkAppStatus(json, url) log(\"请求返回\", json, url, options); return json.data; &#125; /** * get请求 * @param &#123;*&#125; url */ async get(url, data) &#123; if (data) data = urlEncoded(data); if (url.indexOf('?') &lt; 0 &amp;&amp; data) url += '?' + data; return this._request(url, &#123; method: 'GET', headers: headers, timeout: 10000 &#125;, 'json') &#125; /** * post请求 * @param &#123;*&#125; url * @param &#123;*&#125; data */ async post(url, data) &#123; return this._request(url, &#123; method: 'POST', headers: Object.assign(headers, &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125;), timeout: 10000, body: urlEncoded(data) &#125;, 'json') &#125;&#125; 调用一次远程端口并查看日志输出。这里调用的也是案例中要使用到的获取banner的接口。这个接口不需要用户权限，后面还会遇到需要用户权限的接口。 自适应方法这里推荐一种自适应的方法。同时也是前端在开发移动端页面的时候常用的方法。将手机屏幕宽度默认为750像素，然后将所有的宽高按照这个比例去缩放。这要求设计出的设计稿也要宽度是750。 在utils下新建一个px.js文件。按照出入的大小根据当前屏幕的宽度获取到缩放的比例并返回结果。 在首页引入px方法，查看使用px之后的效果。 可以看到使用px将500像素缩放之后的效果和最开始设置的纯数字200效果是一致的。这里使用的是ios模拟器，真实的屏幕宽是375，按照750宽去算的话会把传入的参数统统除以2。 封装本地存储RN提供的AsyncStorage可以根据key存储相应的字符串。我们这里改进一下，让它可以存储所有类型的字段。利用的是将传入的参数改造成对象，然后使用JSON的方法将对象转化成一个可以存储的字符串。 在utils下新建一个Storage.js。 将传入的对象转化为字符串并存入AsyncStorage。123456789101112131415161718192021222324252627282930313233343536373839'use strict';import &#123; AsyncStorage &#125; from 'react-native';/** * 获取存储的数据 * @param &#123;*&#125; key */exports.getItem = async (key) =&gt; &#123; let item = await AsyncStorage.getItem(key); if (!item) &#123; return null; &#125; return JSON.parse(item).v || null;&#125;/** * 存入数据 * @param &#123;*&#125; key * @param &#123;*&#125; value */exports.setItem = (key, value) =&gt; AsyncStorage.setItem(key, JSON.stringify(&#123; v: value&#125;));/** * 删除已经存在的数据 * @param &#123;*&#125; key */exports.removeItem = (key) =&gt; AsyncStorage.removeItem(key);/** * 清除所有 */exports.clear = () =&gt; AsyncStorage.clear();/** * 获取所有的key */exports.getAllKeys = () =&gt; AsyncStorage.getAllKeys(); 在首页使用setItem存入数据,然后第二次进入页面再使用getItem获取数据。 这里用到了componentDidMount这个方法。这个方法是在组件生命周期中的初始化完成之后执行的。 添加弹出toast之前公司使用的是自己开发的提示方法，这个方法需要改变原生代码，非常的不方便。这里推荐使用第三方的开源组件react-native-root-toast。只需要安装一下就好了。 执行命令，安装toast。npm i --save react-native-root-toast。 在utils目录下新建toast.js文件。添加toast的默认方法并填入默认参数。这里设置显示时间为1000毫秒，背景颜色是一个半透明的黑色。这里也是为了方便调用，如果需要多种效果的就定义多个吧。 在首页引入toast并看看实际的效果。 让iOS支持http协议苹果之前推荐使用https协议,现在默认是不支持http的。如果需要支持http需要单独设置。案例中的项目也用到了http，所以需要修改info.plist文件，让iOS可以访问http的地址。 使用xcode选择打开其他项目。 打开项目下的iOS文件夹，选择项目文件并打开。 选择info.plist文件，再右边选择第一行并点击+号添加一项。 选择App Transport Security Setting这一项，会弹出提示。点击确定即可自动刷新。 在上面添加的新配置中添加一个新的配置Allow Arbitrary Loads，同时设置为YES。 改完配置还需要编译一次。点击左上角的三角形或者菜单中product下的build选项。 这里我使用的是xcode修改配置文件，如果你发现配置文件没有变化，也可以自己改info.plist文件的内容。 编译安卓客户端使用android studio打开根项目下的android目录。打开build.gradle文件。这个就是项目的gradle配置文件，通常使用这个文件对整个项目进行描述。 经过一定时间的等待，IDE就会初始化整个项目。如果有一些需要下载的文件也会在这个时间通知下载。 点击菜单build/gennerate signed apk。这个就是编译一个可以安装在安卓手机上的安装包。也可以通过点击make project来看看项目是否可以编译通过。 点击next，IDE会提示需要选择一个证书。这里可以选择一个已有的并输入密码，也可以通过点击create new来创建一个。后面一直点击next就可以了，IDE会在生成apk之后弹出通知。 选择创建一个新的证书。根据提示填入相应的内容，之后点击ok即可生成。记得选择remember password，下次直接填入密码。 经过一整机器躁动之后，IDE弹出编译结果。点击蓝色字可以快速打开apk的地址。 将apk文件发送到手机上安装即可。一个你自己开发的app就安装好了。 这里要注意，在打包之前要把RN打包生成的bundle文件放入android文件下的assets目录中。否则安卓会因为找不到启动文件而报错。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"01.基础-项目初始化","slug":"01-基础-项目初始化","date":"2018-03-14T14:12:00.000Z","updated":"2018-03-14T14:39:05.931Z","comments":true,"path":"2018/03/14/01-基础-项目初始化/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/01-基础-项目初始化/","excerpt":"","text":"知识点：1.快速创建RN项目2.添加使用路由功能3.不要在RN中使用的功能 从这里开始，我们将一步一步的创建一个可以真正的使用的app。第一部分讲述开发一个app的大致过程，第二部分将开始优化性能、开发效率等，第三部分教大家添加热更新、支付、分享这些功能。大多数第三方组件可以很方便的link到项目里，部分需要手动导入甚至主动开发一些东西，这里也会在用到的时候讲出来。 创建项目的前提条件·使用react-native创建一个新的项目请确保你的电脑上已经满足下面的这些条件。 nodejs。RN的所有库都是从npm上安装的。请确保你的电脑上已经安装了npm。可以使用npm -v来查看当前是否安装了npm。当前项目使用的node版本是8.9.3，npm的版本是5.5.3。 react-native-cli。这个通常用作RN的初始化和启动模拟器等，是用npm可以安装到电脑上。 python。RN里面有些脚本是使用python写的。请确保电脑上已经安装了python2.7以上的版本。 jdk1.8。安卓项目需要使用jdk1.8，请在电脑上安装好jdk1.8。安装的教程可以方便从网上搜索到。 Android Studio。调试以及编译安卓代码需要使用到。请在安装Android Studio之后安装好Android SDK以及模拟器。模拟器可以使用市面上的安卓模拟器，它们普遍比自带的模拟器要快。闲麻烦的同学可以直接连接手机调试。在安装好IED之后请下载好需要使用到的androidSDK。下载SDK需要科学上网或者把下载地址替换成国内的几个下载源。 git。后面的项目会加入到git中，使用git做版本管理的好处不言而喻。 Xcode（仅ios项目中）。安装了Xcode才能使用iOS模拟器。ios模拟器下的开发速度要明显优于安卓下，后面的开发过程大多数也是在ios模拟器中进行的。在模拟器中的表现都差不多，有些不一样的效果可以在看到的时候单独调试。 Watchman（仅mac系统用到）。Watchman用来监听文件变动等。mac下必须安装Watchman。 vscode。文中演示项目使用的编辑器是vscode。这里也推荐使用vscode开发前端项目。 创建项目我们先在本地创建一个可运行的项目，同时这个项目会加入到git的版本管理中。 执行react-native init anxintao --version 0.53.0。图中1代表之前安装的react-native-cli的命令。图中2代表初始化命令。图中3代表项目的名称，这里是anxintao。图中4代表指定RN的版本号，这个参数不传默认使用最新版。图中5代表RN具体使用的版本号。 使用vscode打开项目，在项目根目录下执行命令启动初始化之后的项目，mac下推荐react-native run-ios，window下推荐react-native run-android启动默认的项目。如果能启动说明项目初始化完成，否则说明项目的某些东西没有安装好。这里推荐把启动的命令写入到package.json文件中。比如:输入npm run ios即可代替原来的react-native run-ios，输入命令的速度快了不少。也可以给vscode安装一个启动RN的插件，不过效果跟输命令差不多，具体要看个人习惯了。 到这里就说明项目创建成功了。这个项目现在还很简单，它的原生部分只有一个简单的空壳。这个空壳仅仅是初始化了一个RN的activity，所有的js都是运行在根视图上的。 这里注意一下，新建的项目提示了按键可以刷新页面或者调出菜单。这显示的是ios模拟器，按键为command R刷新和command D调出菜单。 添加路由一个完整的项目不能没有路由。这里我们使用React Navigation。 在写文章的时候已经有一个路由组件react-native-navigation热度超过了react-navigation。它更多的使用的是原生的路由切换，效果更好。想用的同学可以去尝试一下。 安装路由。在根目录下执行npm install --save react-navigation。 在根目录下新建src目录。所有页面放入这个文件夹下。 新建一个首页，给后面的路由调用。页面路径为:根目录/src/home/index.js 12345678910111213141516'use strict';import React from 'react';import &#123; StyleSheet, View, Text&#125; from 'react-native';export default class extends React.Component &#123; render() &#123; return &lt;View style=&#123;&#123; marginTop: 200 &#125;&#125;&gt; &lt;Text&gt;这是首页&lt;/Text&gt; &lt;/View&gt; &#125;&#125; 修改根目录下的index.js。添加整个项目的路由。 1234import &#123; AppRegistry &#125; from 'react-native';import Pages from './src';//启动AppRegistry.registerComponent('anxintao', () =&gt; Pages); 5.在src目录下新建index.js文件。在这个文件里添加路由。我们从简单的一个页面开始。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354'use strict';import React from 'react';import &#123; StyleSheet&#125; from 'react-native';//添加路由组件import Navigation from 'react-navigation';//添加展示用的首页import Home from './home/index'//创建路由const Pages = Navigation.StackNavigator(&#123; 'Home': &#123; screen: Home &#125;&#125;, &#123; //这里做了一个页面跳转的动画 transitionConfig: () =&gt; (&#123; screenInterpolator: sceneProps =&gt; &#123; const &#123; layout, position, scene &#125; = sceneProps; const &#123; index &#125; = scene; //设置页面跳转的动画 const translateX = position.interpolate(&#123; inputRange: [index - 1, index, index + 1], outputRange: [layout.initWidth, 0, 0] &#125;); const opacity = position.interpolate(&#123; inputRange: [index - 1, index - 0.99, index, index + 0.99, index + 1], outputRange: [0, 1, 1, 0.3, 0] &#125;); return &#123; opacity, transform: [&#123; translateX &#125;] &#125;; &#125; &#125;), navigationOptions: &#123; header: null &#125;&#125;);//创建一个自己的容器,方便以后对路由做一些处理export default class extends React.Component&#123; constructor(props) &#123; super(props); &#125; render() &#123; return &lt;Pages onNavigationStateChange=&#123;this.listenChange.bind(this)&#125;&gt;&lt;/Pages&gt;; &#125; //监听路由的跳转 listenChange(state1, state2, action) &#123; &#125;&#125; 6.添加完成之后删除掉初始化项目之后的App.js。这个时候在模拟器中使用快捷键command+R即可刷新刷新页面。7.至此就完成了简单的路由设置。之后只需要添加页面并在路由中注册即可使用。 路由升级版简单的路由并不能起到很好的作用，我们还是创建一个更实用的路由吧。比如带3个tab切换的首页，这也是大多数app使用套路。 添加4个tab切换页。我们假定未来需要4个切换页，分别是首页、分类页、购物车、个人中心。在home下分别创建他们。 修改路由所在的index文件。引入下面要用到的几个组件和页面 添加新加入的页面123456789101112import React from 'react';import &#123; StyleSheet, Image&#125; from 'react-native';//添加路由组件import Navigation from 'react-navigation';//添加展示用的首页import Home from './home/index'import Products from './home/products'import Shop_Cart from './home/shop_cart'import My from './home/my' 创建底部的样式123456789101112131415//创建tab页的顶部样式const styles = StyleSheet.create(&#123; tab: &#123; height: 40, backgroundColor: '#fbfafc', borderTopColor: '#efefef' &#125;, tabIcon: &#123; width: 20, height: 20 &#125;, tabLabel: &#123; marginBottom: 4 &#125;&#125;) 创建一个tab路由，为了简单这里只展示2个页面的。具体的代码可以去git仓库查看。1234567891011121314151617181920212223242526272829303132333435363738394041//创建首页的tab页const Tabs = Navigation.TabNavigator(&#123; 'Home': &#123; screen: Home, navigationOptions: (&#123; navigation, screenProps &#125;) =&gt; &#123; return &#123; tabBarLabel: '首页', tabBarIcon: (opt) =&gt; &#123; if (opt.focused) return &lt;Image source=&#123;&#123; uri: require('./images/tab-home-active') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; return &lt;Image source=&#123;&#123; uri: require('./images/tab-home') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; &#125; &#125; &#125; &#125;, 'Products': &#123; screen: Products, navigationOptions: (&#123; navigation, screenProps &#125;) =&gt; &#123; return &#123; tabBarLabel: '产品分类', tabBarIcon: (opt) =&gt; &#123; if (opt.focused) return &lt;Image source=&#123;&#123; uri: require('./images/tab-products-active') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; return &lt;Image source=&#123;&#123; uri: require('./images/tab-products') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; &#125; &#125; &#125; &#125;,&#125;, &#123; //设置tab使用的组件 tabBarComponent: Navigation.TabBarBottom, //点击哪个才加载哪个tab里的页面 lazy: true, //设置tab放在界面的底部 tabBarPosition: 'bottom', //设置tab里面的样式 tabBarOptions: &#123; style: styles.tab, labelStyle: styles.tabLabel, activeTintColor: '#d0648f' &#125;&#125;); 替换Pages里的第一个页面为刚才创建的Tab路由。由于默认加载第一个，所以需要将第一个设置成tab页。123'Tabs': &#123; screen: Tabs &#125; 3.现在再刷新模拟器,就会发现底部的Tab切换已经好了。点击可以切换不同的页面。 4.这里我将图片转化成base64的方式再引入到图片组件中。好处是打包之后会变成一个整体。坏处是打包之后的bundle文件会变大，做增量更新也比较麻烦。 不推荐使用的东西 投影。安卓不支持投影，在开发的时候如果没有必要就使用别的方式代替吧。比如使用图片代替投影。 边框色。在长列表中尽量不要使用边框色，在某些安卓手机下会闪退。 使用了圆角的情况再使用背景色。ios手机会出现边框颜色异常或者异常色块。去掉背景即可。 过于深层次的结构 过于频繁的刷新state","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"00.为什么我选择react-native","slug":"00-为什么我选择react-native","date":"2018-03-14T14:10:00.000Z","updated":"2018-03-14T14:15:33.879Z","comments":true,"path":"2018/03/14/00-为什么我选择react-native/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/00-为什么我选择react-native/","excerpt":"","text":"在所有的技术选型之前都有一个为什么。 为什么我选择了React-native？选择这个技术到底给我带来了什么样的技术福利？如果你正在考虑RN，或者还在研究选择什么样的技术实现自家的APP。不妨看看我的课程，说不定你就有了不一样的感受。 注：react-native以下会简称RN。 我注意的优点选择RN之前我也看过了其他的几种技术，早一点的时候我也使用过其他的技术做APP。比如HBuilder的框架，非常的方便、非常的好用、什么都不需要管。但是开发完之后发现性能很差，做一个稍微复杂点的项目就非常上火。后来切了原生，但是使用java做开发也有非常多得问题，开发效率很低。 后来我选择了RN，它使用js更新虚拟dom，通过一个桥接器将需要更新的结果通知到UI层，让native执行UI的改变。简单来说，就是用js做驱动开发一个类原生的APP。所有的渲染都是和原生一样的，一下子就讲原生开发和js开发连接起来。通过这么一个模式，将传统的java或者oc开发转变成了简单易懂的前端js开发。这是移动开发的一大进步，避免了一个APP多个平台多套代码的尴尬，同时提升了开发效率，将移动开发带入了一个新的层面。 性能相似很多人说RN的性能比不上原生的APP。这个说法是要看具体的场景下的。 在一般的应用场景下RN的表现和原生APP是没有太大的差别的。一个APP也不会是到处都是复杂的交互效果。一些简单的点缀动画再加上列表图片等才是一个APP最常见的内容。这种情况下它们之间的表现是一样的。 RN本身只是使用js处理了UI渲染之前的一些逻辑，在最终的渲染上其实使用的还是原生的逻辑。尤其是渲染完成之后更是和原生的没有半点区别。 我们的案例是一个电商项目，主要渲染逻辑是首页的自定义模板、无限加载的列表等。目前最大的性能瓶颈其实是在事件的优化上，优化之后用户已经感知不到和原生的区别了。我们会在后面的部分提到性能优化，将一个粗糙的app通过简单的方法提高10倍性能，再通过另外一个稍微复杂的方法减低内存占用。 开发效率高通常情况开发一款APP需要发布在安卓和iOS两个平台，导致的结果就是一个APP两个团队两套代码。界面几乎一样，为什么不能使用一套代码呢？之前也有大神使用各种手段达成这个目标，但是并不是很理想。 由于使用熟悉的react和jsx的模式，开发者只需要有前端知识就可以很迅速的上手一个RN项目。如果再学一些实战的例子，稍微复杂一些的项目也难不倒各位前端开发者。 debug超级方便，一边开发一边看效果再也不是梦。 快速热更新RN生成的js文件，只要不涉及原生功能的增减，已经发布的APP完全不需要重新安装即可完成新版功能的上线。用户只需打开APP就能体验到最新的APP，省去了下载重装的各种麻烦。把app的更新做到了和网页更新一样的方便快捷。 使用RN就能达到既有原生的所有能力，又有类似浏览器上的快速更新能力。同时还可以接入各种定制好的网页，将APP的自由度提高到一个非常高的地步。 大公司背书RN的开发者是facebook，背靠大树好乘凉，社区更疯狂。FB本身也在尝试使用RN技术开发自己的APP，RN一定会越来越完善。截止写这篇文章的时候RN已经更新到了0.53.0。 RN本身也是开源的，所有的源代码都是可以看到的。社区的讨论也是比较热烈的。现在可能中文文档还比较少，未来随着开发者的努力，这些坑都会填起来的。 其实最开始的时候也没有想很多，仅仅是冲着RN可以快速开发，上线快体验好。经过了这么长时间的开发，我更加喜欢RN的这种开发方式，项目中也填了各种各样的坑。后面就用一个实际的例子来展示RN是怎样开发的吧。 RN的缺点升级快RN本身其实还处于测试版，开发组经常会升级RN，解决一些遗留或者隐藏的bug。在这个的过程中就导致了RN本身升级非常快，开发者在使用RN开发APP的过程中应该尽量提高自己的版本，不需要一直是最新的，只要能够跟的上FB的节奏即可。 自己搞定的问题也是可以合并入RN的源代码里的。不要一味的等RN更新，有些问题自己解决更方便。建议会Android或者ios同学自己动手。 动画难这里的难指的是复杂的动画在开发中很难去优化。尤其是开发者懂前端但是不懂原生的情况下。好在常见的APP也不需要多么复杂的动画。一般使用位移变换就足够了，太复杂的动画建议使用RN的svg组件来做。 webview难用RN自带的webview跟浏览器有一定的差别。APP经常要打开一些网页，可能在开发的时候一切正常，但是到了RN里面就会有一些奇怪的问题，主要还是受到系统浏览器的影响，会有一些兼容方面的问题。这种情况下不如微信使用自己研发的浏览器，可以畅快的使用ES6之类的新技术。 需要原生支持简单的东西和界面的展现已经完全放手给了开发者。但是还是有一些功能只能原生去实现，如果原生部分的开发者对RN不太了解可能会给APP带来不可预知的bug。好在大多数开源看只需要执行link命令就可以把原生部分也安装好。 技术都会有优点和缺点。选择合适的技术才能给项目带来长久的生命力。 其他技术weex核心思想上，这两家其实并没有什么区别。weex也可以算是站在RN的肩膀上起步的。目前活跃度不高，大多数是在观望中。 开发框架weex使用vue。熟悉vue的开发者可能会更熟悉。 RN使用react。都是facebook出品，框架融合上会更方便一些。 它们都是组件化开发，都输数据绑定，都有虚拟dom。社区同样活跃，使用人数也都非常多。 学习成本react的jsx初期会比较难上手，css的写法也跟前端的样式写法不一样。weex使用模板的形式，直接html+css开发。上手会稍微简单一些。 异步weex只支持callback的形式。RN支持promise的形式。 这些都是可以解决的。不是什么问题。 社区RN开源早，有facebook支持。社区的组件库已经比较丰富，社区活跃度比较高。weex开源晚，社区活跃不高，以阿里系比较多。 FlutterFlutter 是Google推出的一个跨平台（Android 和 iOS）移动开发框架，使用的是 Dart 语言。 Flutter 的目标是用来创建高性能、高稳定性、高帧率、低延迟的 Android 和 iOS 应用。并且开发出来的应用在不同的平台用起来跟原生应用具有一样的体验。不同的平台的原生体验应该得到保留，让该应用看起来同整个系统更加协调。不同平台的滚动操作、字体、图标 等特殊的特性 应该和该平台上的其他应用保持一致，让用户感觉就像操作原生应用一样。比如，返回图标 Android 和 iOS 是不一样的；滚动内容滚动到底的反馈也是不一样的。 兼容Flutter不使用系统提供的组件，自己实现了一套渲染机制，所以在性能优化、跨平台方面表现优秀。实际体验上，性能比RN要高不少。 RN最终调用的还是系统的组件，虽然FB已经很努力了，但是在某些时候还是会有兼容性需要处理。 组件Flutter 内置了对Material Design的支持，给开发者提供了丰富的 UI 控件库选择。同时所有的组件都有扩展，保持了很高的灵活性。 RN通过react也做到了组件式开发，跟Flutter相比，多了一个桥接器的转换，性能上肯定不如Flutter。 开发语言Flutter使用Dart实现。Dart号称要完全取代js，不过目前离这个目标还非常远。初期上手还是有一些难度的。 RN使用js开发，做过前端的都非常熟悉，上手很容易。 Flutter现在还在实验阶段，不排除google使用别的框架替换它的可能性。Dart语言也处于成长阶段，只有google的浏览器在支持。或许在Flutter持续发展到一个阶段之后，才会有很多支持者。 在写文章的时候google放出了第一个测试版，感兴趣的同学可以下载下来玩玩。 相比于其他几种技术，RN是目前社区最活跃，开发效率最高的一种选择。选择RN也是需要在一个比较短的时间内能够完成APP的开发。尤其现在前端开发者可以非常容易的从网页开发转到APP开发上。对于我们包含APP、微信、小程序这样的三个平台更是需要RN这样的技术，一个团队就可以维护项目的持续增长。 如果你需要RN来开发自己的项目，那就看下去吧。我们将从简单的界面开发，数据更新等开始逐步深入。后面涉及到性能优化、自定义原生部分等。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]}]}