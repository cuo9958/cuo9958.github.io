{"meta":{"title":"IT技术博客","subtitle":"一个技术人的实验室","description":"全栈工程师/产品经理/游戏开发","author":"郭方超","url":"http://www.guofangchao.com"},"pages":[{"title":"帮助","date":"2018-03-14T14:42:32.000Z","updated":"2018-03-14T14:43:24.718Z","comments":true,"path":"help/index.html","permalink":"http://www.guofangchao.com/help/index.html","excerpt":"","text":"有问题可以在这个下面留言。","keywords":null},{"title":"友情链接","date":"2018-03-14T14:44:49.000Z","updated":"2018-03-14T14:45:25.610Z","comments":true,"path":"links/index.html","permalink":"http://www.guofangchao.com/links/index.html","excerpt":"","text":"个人博客","keywords":null},{"title":"标签","date":"2016-11-15T11:10:05.000Z","updated":"2018-03-21T11:27:30.193Z","comments":true,"path":"tags/index.html","permalink":"http://www.guofangchao.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-11-15T11:11:13.000Z","updated":"2018-03-21T11:26:06.964Z","comments":true,"path":"categories/index.html","permalink":"http://www.guofangchao.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-03-14T07:30:30.000Z","updated":"2018-03-21T14:51:42.904Z","comments":true,"path":"about/index.html","permalink":"http://www.guofangchao.com/about/index.html","excerpt":"","text":"郭方超,生于1986年. 2012年-2015年,在泽旭担任技术工程师. 2015年-2016年,在瑞格传播担任项目经理. 2016年-2017年,在来吧旅行网担任前端架构师. 2017年-2018年,在达令担任前端架构师. 想加友链的可以在下面留言，请先加好再申请。","keywords":null}],"posts":[{"title":"ReactNative热更新系统","slug":"ReactNative热更新系统","date":"2019-08-21T08:48:00.000Z","updated":"2019-08-21T08:48:27.328Z","comments":true,"path":"2019/08/21/ReactNative热更新系统/","link":"","permalink":"http://www.guofangchao.com/2019/08/21/ReactNative热更新系统/","excerpt":"","text":"热更新是一个非常方便的方案。在应对大量用户和深度定制的时候一定不能使用开源的方案。一般第三方的这种方案，服务器带宽较小，或者不够灵活，不能满足自己的想法。这里推荐自己实现对应的热更新方案。只需要少量代码即可支持。下面推荐一种灵活的热更新方案。包括客户端的改造、接口设计、界面开发，同时是开源的！可以自由改造。 体验地址：demo 用户名密码都是：admin 基础数据的准备和实现首先第一点，一个APP如果要支持热更新，需要在打开APP（或者其他进入RN页面之前）就要判断是否需要更新bundle文件。这里就是我们实现热更新的节点。一旦需要热更新就开始下载文件，而判断的接口就是我们这次文章的核心内容。这里简单贴出安卓和ios两端的下载逻辑。 请求之前需要在head中附带上客户端的几个重要信息。客户端版本号version、客户端唯一id:clientid、客户端类型platform、客户端品牌brand。 ios下载的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344-(void)doCheckUpdate&#123; self.upView.viewButtonStart.hidden = YES; if ([XCUploadManager isFileExist:[XCUploadManager bundlePathUrl].path]) &#123;//沙盒里已经有了下载好的jsbundle，以沙盒文件优先 self.oldSign = [FileHash md5HashOfFileAtPath:[XCUploadManager bundlePathUrl].path]; &#125;else &#123;//真机计算出的包内bundlemd5有变化，可能是压缩了，所以这里写死初始化的md5 // NSString *ipPath = [[NSBundle mainBundle] pathForResource:@\"main\" ofType:@\"jsbundle\"]; // self.oldSign = [FileHash md5HashOfFileAtPath:ipPath]; self.oldSign = projectBundleMd5; &#125; AFHTTPSessionManager *_sharedClient = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@\"http://test.com\"]]; [self initAFNetClient:_sharedClient]; [_sharedClient GET:@\"api/check\" parameters:nil progress:nil success:^(NSURLSessionDataTask * __unused task, id JSON) &#123; NSDictionary *dic = [JSON valueForKeyPath:@\"data\"]; BOOL isNeedLoadBundle = YES; if ([dic isKindOfClass:[NSDictionary class]]) &#123; self.updateSign = [dic stringForKey:@\"sign\"]; self.downLoadUrl = [dic stringForKey:@\"downloadUrl\"]; if(self.updateSign.length &amp;&amp; self.oldSign.length &amp;&amp; (![self.updateSign isEqualToString:self.oldSign])) &#123; //需要更新bundle文件了 self.upView.viewUpdate.hidden = NO; [self updateBundleNow]; isNeedLoadBundle = NO; &#125;else &#123; //不需要更新bundle文件，再处理跳过按钮显示逻辑 [self.upView showSkipButtonOrNot]; &#125; &#125; if (isNeedLoadBundle) &#123; [self loadBundle]; &#125; &#125; failure:^(NSURLSessionDataTask *__unused task, NSError *error) &#123; [self loadBundle]; &#125;];&#125; 安卓下载的例子1234567891011121314151617181920212223242526272829303132333435363738private void requestData() &#123; subscribe = DalingNetwork .getDalingApi() .getBundleVersion() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new BaseSubscriber&lt;BundleVersionResponse&gt;() &#123; @Override public void onError(Throwable e) &#123; startMainActivity(); e.printStackTrace(); &#125; @Override public void onNext(final BundleVersionResponse response) &#123; isJSNeedUpdate = false; if (response.status == 0) &#123; if (response.data != null) &#123; if (MainApplication.getApplication().getBundleMD5().equalsIgnoreCase(response.data.sign)) &#123; //和本地版本相同，直接进入主页 isJSNeedUpdate = false; tv_skip.setVisibility(View.VISIBLE); startMainActivity(); &#125; else &#123; //下载升级 isJSNeedUpdate = true; downloadSign = response.data.sign; downloadUrl = response.data.downloadUrl; downLoad(response.data.downloadUrl, response.data.sign); &#125; &#125; &#125; else &#123; startMainActivity(); &#125; &#125; &#125;); &#125; 系统设计方案首先来看一下我们是怎样设计客户端获取更新逻辑的。 客户端请求的时候会带上版本号、平台2个重要信息。 接口拿到请求之后查询对应的本地缓存，没有则去数据库查询。 从查询结果中筛查对应的3段数据：白名单、灰度、全量，判断顺序从左到右。 返回查询之后对应的结果。 数据库等设计上面的设计是基础的逻辑，下面我们继续细化逻辑。其中为了支持更好的性能和分布式做了一些其他的方案设计。 根据逻辑自行设计是完全可以的😁 数据库设计我们选择MySQL作为基础数据库，负责存储每次发布之后的数据保存。fe_bundle表存储的是每次发布的bundle信息，主要分3个部分： 表本身需要的数据。id、状态、操作人、发布说明。 判断是否更新的依据字段。版本号、平台、客户端id、bundle的签名、地址、压缩包的地址。 作为附加数据在接口返回的。标签id、标签内容。 fe_labels表就是作为附加数据存储的。如果想要在接口上返回一些复杂的操作，比如显示隐藏某个界面、是否加载某个bundle、是否强制更新等，都可以在这里设置。这个表本身只支持添加和是否启用，不支持删除，防止误操作。 根据实际情况减少字段的长度可以优化数据库的查询性能。比如昵称的长度不会超过10个字符。大量数据的情况下添加索引也会提高数据库性能。查询的时候只查询需要的字段也可以减少查询的时间。 发布订阅设计使用发布订阅模式主要是为了同步每次发布的结果。这样做可以解耦发布和本地缓存更新，多个服务器支持也不会出现资源争夺或者更新不及时的情况。 这里使用的是redis的发布订阅模式，可以选的其他方案有MQ的消息队列等方式。在收到消息的时候主动更新本地缓存。 本地缓存设计接口响应速度快不快的关键就是在本地缓存这里了。毕竟在用户大量访问的情况下，一个数据库是非常难支撑的。这里利用本地缓存减少数据库的查询，不管是面对多少用户，实际在工作的就只有接口所在的服务器线程。而且这里利用了nodejs的高并发优势，只要机器抗的住，我们的服务就不会卡顿或者挂掉。服务能支持的并发数几乎等于机器支持的并发数。 本地缓存的优点就是查询速度快，没有网络请求的消耗。 在遇到缓存没有的情况下，去数据库读取数据并缓存在本地。 使用双缓存，避免多个请求来临的情况下并发打垮数据库。 双缓存只是应对特殊情况，比如本地缓存失效、服务器重启等情况下的大量请求。正常情况下发布订阅已经解决了本地缓存的问题。 前台界面开发前台界面使用React+Mobx+ElementUI实现。这里选择这个技术栈主要是为了方便，毕竟会RN的开发者大概率是可以很快上手React的。 React作为基础框架，利用框架的优势快速开发。 Mobx作为状态管理，这次项目中只利用到了用户信息的全局管理。 ElementUI的几个UI还不错，这里利用现成的UI开发，剩下大量的设计精力。 登录界面登录只需要简单的一个背景+登录信息输入框即可。有兴趣的可以优化一下，让界面更好看。这里利用Mobx将用户的登录信息保存在全局缓存中。这个设计比较简陋，在公司内部用一下还可以了。如果是开发给更多人用一定要完善一下，把用户鉴权做的更安全一些。 bundle管理界面列表管理只需要显示关键信息即可。列出查询的几个参数，方便查询。在点击删除的时候要弹出是否删除的提示，点击发布的时候也需要弹出提示。编辑的时候给出几个固定选项。如果是灰度的时候还能够选择不同的手机品牌、灰度的比例。如果是白名单模式，需要填入白名单对应的clientid。 标签管理标签的核心就是添加和使用。在添加的时候定义好添加的字段和值类型。只需要一次添加即可完成。客户端兼容🈚️值情况下的兼容就好了。 后端接口开发接口分2个部分，一部分是应对后台的编辑列表等接口，另外一个部分是应对大量用户的查询接口。 编辑查询接口接口开发其实非常简单，如果对数据库使用不熟练的可以看看相应的文档或者教程。sequelize简单教程 接口开发3个步骤： 获取请求的参数。这里最好添加默认值处理，异常校验。 查询数据库。处理正常返回和catch报错的2种情况。 按照约定的规范返回具体的内容。 这里约定，返回status=0是查询成功，所有数据放在data字段里。返回status=1代表查询失败，错误信息放在msg字段里。 查询接口查询接口分2个线程，一个线程是网络请求线程，管理来访的网络请求和筛选返回。另外一个线程管理本地更新，通过redis的订阅模式触发对应的数据更新。 缓存更新当redis通知到需要更新的时候会带上版本号、平台的数据库。我们本地缓存也是由这2个字段作为key缓存的。searchFromService这个方法主要是从数据库拿对应的数据列表，并且在拿到数据之后手工把数据分为3个部分，分别用来处理白名单、灰度、全量的数据。他们对应的返回也是N个白名单、N个灰度、1个全量数据。 网络请求网络请求逻辑较复杂，需要首先从缓存中拿数据，同时可能触发数据库拿数据并处理到缓存中，备份缓存拿数据并返回。数据来源确定之后就开始分阶段筛选。 筛选是否存在合适的白名单数据。 筛选是否存在合适的灰度数据 判断对应的全量数据是否存在。 以上判断全部完成之后就可以知道本次请求是否有合适的bundle了。没有的话客户端也不需要更新。用户可以正常打开并浏览。 判断灰度的时候clientid中可能会带字母。这情况下需要将字母转为数据再判断。这里的转化是简单的字母数字对应，具体表现就是百分比前移。前60%的用户量会大于后40%的用户量。如果对这个有要求的可以按照26进制转10进制的方式转化数据。拿到的就是真实的百分比了。 源代码地址前台页面地址：前台代码 后台接口地址：后台代码 数据库地址：数据库代码","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"reactnatiev","slug":"reactnatiev","permalink":"http://www.guofangchao.com/tags/reactnatiev/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"获取git当前分支名","slug":"获取git当前分支名","date":"2019-05-05T04:16:00.000Z","updated":"2019-05-05T07:11:35.493Z","comments":true,"path":"2019/05/05/获取git当前分支名/","link":"","permalink":"http://www.guofangchao.com/2019/05/05/获取git当前分支名/","excerpt":"","text":"使用git获取分支名有两种方式。 12345678910const child_process = require(&apos;child_process&apos;);let res = child_process.execSync(&apos;git symbolic-ref --short -q HEAD&apos;, &#123; encoding: &apos;utf8&apos;&#125;);let res2 = child_process.execSync(&apos;git branch | grep &quot;*&quot;&apos;, &#123; encoding: &apos;utf8&apos;&#125;);console.log(res, res2) 如果没有提交新分支，使用第二种获取不到分支名。 123456const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);let str = fs.readFileSync(path.resolve(&apos;/Users/mac/space/xc_app_rn&apos;, &apos;.git/HEAD&apos;), &#123; encoding: &apos;utf8&apos; &#125;);console.log(str.replace(&apos;ref: refs/heads/&apos;, &apos;&apos;))","categories":[{"name":"git","slug":"git","permalink":"http://www.guofangchao.com/categories/git/"}],"tags":[{"name":"node","slug":"node","permalink":"http://www.guofangchao.com/tags/node/"}],"keywords":[{"name":"git","slug":"git","permalink":"http://www.guofangchao.com/categories/git/"}]},{"title":"流式编程：让页面飞起来","slug":"流式编程：让页面飞起来","date":"2019-04-18T15:39:00.000Z","updated":"2019-04-18T15:39:50.933Z","comments":true,"path":"2019/04/18/流式编程：让页面飞起来/","link":"","permalink":"http://www.guofangchao.com/2019/04/18/流式编程：让页面飞起来/","excerpt":"","text":"有时候也可以成为函数式编程。它的主要目的是在数据拉取的过程中渲染页面，即边处理数据边渲染页面。 类似概念： 流式应用：Rxjs 流式列表 流式处理：大数据、实时计算 文件处理、字节流、加密、网络 流式应用 瀑布流 实时计算 流处理 来源和结论页面结构原始页面是嵌套的，但是去掉嵌套来看，整个页面是一个从上到下的渲染过程。在渲染的过程中如果触发页面重绘，也就是出现脱离文档流的样式，整个页面的性能就会下降。从这个方面讲，前端结构是需要尽量流式的展示的。 接口请求打开页面甚至在页面什么也没有展示的时候，接口就会请求数据。 有的请求3、5个，有的请求10多个。从整体上看，大多数接口是一个顺序请求的过程。它收到页面结构的影响，过快的请求反而渲染的不是所需要的地方。 并行的请求顺序就可以看做是一个流式的过程。 tips:有些接口可以同时异步执行，使用并行请求，将页面渲染分离，可以加速页面的呈现。tips:多次请求需要多次握手，使用http2.0可以加速这个时间。合并接口可以直接去掉多余时间。 优化顺序 按照页面渲染顺序做开发。没必要呈现的后渲染，可以加速页面展示。 多余接口后请求，优先渲染第一屏。 从结构上优化。先加载的先请求，先呈现的先计算，后加载的排队来，后呈现的叠加计算。 实例分析单接口情况单接口的时候会遇到数据量大，结构复杂。页面结构也会相应的增长复杂度。 加速接口返回速度。这个往往比较容易。 使用适配器模式将接口转化成合适的结构。接口返回的数据往往更倾向于接口熟悉的模式，如果接口的结构无法改变，就需要自己做二次处理。这里注意不要污染数据，多次引用容易造成不必要的问题。 页面尽量组件化，不容的组件使用不同的数据。如果页面较大，可以分批渲染。 多接口多接口的情况往往是需要并行的和需要并发的接口齐上阵，一不注意就造成接口阻塞。 梳理接口顺序。将优先渲染的数据优先请求，后面的排队来。 优先请求的数据异步执行，不要排队等待接口返回。 先返回的数据线渲染，后返回的数据后渲染。多种渲染使用组件分离。 实时+触发请求接口的过程中不断有点击加载的情况。如果点击比较频繁，就需要针对性优化 多次触发的情况下取消前一次请求。 多次渲染的情况下，缓存渲染结果。 复杂页面复杂结构页面，合并上面的例子 总结流式编程将页面结构看做数据，多个数据并行展示看做一个整体。通过这样宏观的抽象整理，将页面变成了一个流动的对象。从根本上改变了开发的形态。 在实际开发中使用流式编程思想可以很容易的开发出高性能的页面。页面渲染更快，展示更合理。同时反过来加速了代码结构的进化，促进开发者思考和成长。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.guofangchao.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"私有库使用指南","slug":"私有库使用指南","date":"2019-04-18T12:31:00.000Z","updated":"2019-04-18T12:31:30.152Z","comments":true,"path":"2019/04/18/私有库使用指南/","link":"","permalink":"http://www.guofangchao.com/2019/04/18/私有库使用指南/","excerpt":"","text":"npm私有仓库的使用切换库到私有库 全局安装切换库使用的工具npm i -g nrm 把私有库注册到本地电脑nrm add daling http://npm-registry.corp.daling.com,后面填的就是私有库地址 将库切换到达令家私有库npm use daling 如果需要，切换到公有库npm use npm 注册登录私有库 查询当前用户npm whoami 查询不到的需要登录或者注册，登录自动注册，已注册的需要使用设置的账户密码登录npm login 发布新库 在package.json中设置库的名称。修改name字段为@dal/test。其中@是必须要有的，后面跟部门固定的名称，斜杆后面是具体的项目名。 使用npm发布库到私有库中npm publish，注意版本号不要重复。 下载新库，使用npm install --save @dal/test","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://www.guofangchao.com/tags/npm/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"微信机器人","slug":"微信机器人","date":"2019-04-03T12:38:00.000Z","updated":"2019-04-03T12:38:34.460Z","comments":true,"path":"2019/04/03/微信机器人/","link":"","permalink":"http://www.guofangchao.com/2019/04/03/微信机器人/","excerpt":"","text":"技术选型 electron react 结构设计 通讯方式 文件结构 build dist public react_config scripts server src test app.js wechat.memory-card.json 开发方式 开发环境 生成环境 其他 使用electron-builder打包发布应用 修改react_config是为了给整个应用的配置文件保留位置","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/tags/nodejs/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"vue面试题","slug":"vue面试题","date":"2019-03-25T09:51:00.000Z","updated":"2019-03-25T09:51:30.205Z","comments":true,"path":"2019/03/25/vue面试题/","link":"","permalink":"http://www.guofangchao.com/2019/03/25/vue面试题/","excerpt":"","text":"vue面试题 v-show 与 v-if 区别 动态绑定class的方法 计算属性和 watch 的区别 怎样理解单向数据流 keep-alive 自定义组件的语法糖 v-model 是怎样实现的 生命周期 组件通信 路由跳转 vue-router 有哪几种导航钩子 Vue.js 2.x 双向绑定原理 什么是 MVVM，与 MVC 有什么区别 vuex this.$nextTick() v-show 与 v-if 区别 v-hsow和v-if的区别：v-show是css切换，v-if是完整的销毁和重新创建。 使用频繁切换时用v-show，运行时较少改变时用v-if v-if=‘false’ v-if是条件渲染，当false的时候不会渲染绑定 class 的数组用法 对象方法 v-bind:class=”{‘orange’: isRipe, ‘green’: isNotRipe}” 数组方法v-bind:class=”[class1, class2]” 行内 v-bind:style=”{color: color, fontSize: fontSize+’px’ }” 计算属性和 watch 的区别计算属性是自动监听依赖值的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。 所以区别来源于用法，只是需要动态值，那就用计算属性；需要知道值的改变后执行业务逻辑，才用 watch，用反或混用虽然可行，但都是不正确的用法。 说出一下区别会加分computed 是一个对象时，它有哪些选项？computed 和 methods 有什么区别？computed 是否能依赖其它组件的数据？watch 是一个对象时，它有哪些选项？ 有get和set两个选项 methods是一个方法，它可以接受参数，而computed不能，computed是可以缓存的，methods不会。 computed可以依赖其他computed，甚至是其他组件的data watch 配置handlerdeep 是否深度immeditate 是否立即执行 总结当有一些数据需要随着另外一些数据变化时，建议使用computed。当有一个通用的响应数据变化的时候，要执行一些业务逻辑或异步操作的时候建议使用watcher 事件修饰符 绑定一个原生的click事件， 加native， 其他事件修饰符 stop prevent self 组合键 click.ctrl.exact 只有ctrl被按下的时候才触发 组件中 data 为什么是函数 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ 因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 keep-alivevue官方解释 自定义组件的语法糖 v-model 是怎样实现的博客介绍 根据官方文档介绍，v-model本质上就是语法糖，即利用v-model绑定数据后，其实就是既绑定了数据，又添加了一个input事件监听 Render 函数怎样理解单向数据流这个概念出现在组件通信。父组件是通过 prop 把数据传递到子组件的，但是这个 prop 只能由父组件修改，子组件不能修改，否则会报错。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。 一般来说，对于子组件想要更改父组件状态的场景，可以有两种方案： 在子组件的 data 中拷贝一份 prop，data 是可以修改的，但 prop 不能：12345678910export default &#123; props: &#123; value: String &#125;, data () &#123; return &#123; currentValue: this.value &#125; &#125;&#125; 如果是对 prop 值的转换，可以使用计算属性：12345678export default &#123; props: [&apos;size&apos;], computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase(); &#125; &#125;&#125; 生命周期 创建前后 beforeCreate/created 在beforeCreate 阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象有了，el还没有。 载入前后 beforeMount/mounted 在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前未虚拟的DOM节点，data尚未替换。在mounted阶段，vue实例挂载完成，data成功渲染。 更新前后 beforeUpdate/updated 当data变化时，会触发beforeUpdate和updated方法。这两个不常用，不推荐使用。 销毁前后beforeDestory/destoryed beforeDestory是在vue实例销毁前触发，一般在这里要通过removeEventListener解除手动绑定的事件。实例销毁后，触发的destroyed。 组件间的通信 父子 props/event $parent/$children ref provide/inject 兄弟 bus vuex 跨级 bus vuex provide.inject 路由的跳转方式一般有两种 router-link标签会渲染为标签，咋填template中的跳转都是这种； 另一种是编程是导航 也就是通过js跳转 比如 router.push(‘/home’) Vue.js 2.x 双向绑定原理这个问题几乎是面试必问的，回答也是有深有浅。基本上要知道核心的 API 是通过 Object.defineProperty() 来劫持各个属性的 setter / getter，在数据变动时发布消息给订阅者，触发相应的监听回调，这也是为什么 Vue.js 2.x 不支持 IE8 的原因（IE 8 不支持此 API，且无法通过 polyfill 实现）。官方解释 什么是 MVVM，与 MVC 有什么区别博客解释 nextTick()在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后，立即使用这个回调函数，获取更新后的 DOM。123456// 修改数据vm.msg = &apos;Hello&apos;// DOM 还未更新Vue.nextTick(function () &#123; // DOM 更新&#125;)","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.guofangchao.com/tags/vue/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"react-native中生成二维码和分享图片","slug":"react-native中生成二维码和分享图片","date":"2018-12-06T04:15:00.000Z","updated":"2018-12-06T04:16:02.368Z","comments":true,"path":"2018/12/06/react-native中生成二维码和分享图片/","link":"","permalink":"http://www.guofangchao.com/2018/12/06/react-native中生成二维码和分享图片/","excerpt":"","text":"在react-native中展示二维码是一个非常麻烦的过程。 最好的方法莫过于原生支持画二维码。但是这有一个副作用，需要在原生中添加新的代码。对于不打算很快升级的项目是一个很通过的选择。 这里我介绍一种不使用原生的方式来生成二维码，副作用仅仅是需要联网下载一个js文件。当然可以使用本地缓存了，这样就和原生几乎一致了。 npm地址 实现自定义二维码不添加原生代码的情况下实现react-native中展示二维码，其实利用的正是WebView组件。 在前端开发的过程中已经有大神实现了js生成二维码的功能。它就是qrcode.js，熟悉的人已经可以很快想到实现方式了。 如果将WebView看做一个类似View的组件，那么在WebView加载完成之后它就已经在展现上与普通组件没有什么区别了。在这个时候就可以看做已经完成了二维码的生成。 1234567891011121314&lt;WebView automaticallyAdjustContentInsets=&#123;false&#125; scalesPageToFit=&#123;Platform.OS === 'android'&#125; contentInset=&#123;&#123; top: 0, right: 0, bottom: 0, left: 0 &#125;&#125; source=&#123;&#123; html: this.html() &#125;&#125; opaque=&#123;false&#125; underlayColor=&#123;'transparent'&#125; style=&#123;&#123; height: size, width: size &#125;&#125; javaScriptEnabled=&#123;true&#125; scrollEnabled=&#123;false&#125; onLoad=&#123;this.props.onLoad&#125; onLoadEnd=&#123;this.props.onLoadEnd&#125; originWhitelist=&#123;['*']&#125;/&gt; 其中的html方法其实就是在生成我们需要的html代码。 我们再这里定义几个参数，方便我们使用12345678static defaultProps = &#123; value: \"\", size: 100, bgColor: \"#fff\", fgColor: \"#000\", onLoad: () =&gt; &#123; &#125;, onLoadEnd: () =&gt; &#123; &#125;, &#125; 最终效果如下： 产生组件快照很多时候我们还是需要将APP中的某个部分截图保存的。 在react-native中，我们可以利用takeSnapshot方法，将组件保存在临时目录中，同时使用CameraRoll.saveToCameraRoll方法将图片放入相册中。 有没有想到什么？ 是的，我们可以在客户端自己生成分享图片。 如果你的分享图片用到了很多动态数据。比如：用户不同图片不同，产品或者渠道不同图片也不同。这个时候服务端生成图片会非常的耗资源。同时用户在等待图片生成的过程中也会有很大的延迟。 这个时候如果图片能够在客户端中生成岂不是非常的好。速度又快，效果又好。 利用上面的二个组件，我们就可以自定义分享图片并下载到用户的相册中。 npm地址源代码地址","categories":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"},{"name":"qrcode","slug":"qrcode","permalink":"http://www.guofangchao.com/tags/qrcode/"}],"keywords":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/categories/react-native/"}]},{"title":"react-native中图片加载变黑","slug":"react-native中图片加载变黑","date":"2018-11-28T08:56:00.000Z","updated":"2018-11-28T08:57:40.351Z","comments":true,"path":"2018/11/28/react-native中图片加载变黑/","link":"","permalink":"http://www.guofangchao.com/2018/11/28/react-native中图片加载变黑/","excerpt":"","text":"图片如果在加载完图片之后变黑，基本和图片的样式有关。 首先检查图片是否使用到了边框、圆角等属性。如果有就取消并使用其他方式实现。 其次检查图片的resizeMode属性。调整到cover之类的属性上。","categories":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/categories/react-native/"}],"tags":[{"name":"image","slug":"image","permalink":"http://www.guofangchao.com/tags/image/"}],"keywords":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/categories/react-native/"}]},{"title":"轻量级配置中心","slug":"轻量级配置中心","date":"2018-11-20T04:59:00.000Z","updated":"2018-11-20T05:00:15.476Z","comments":true,"path":"2018/11/20/轻量级配置中心/","link":"","permalink":"http://www.guofangchao.com/2018/11/20/轻量级配置中心/","excerpt":"","text":"项目地址 单项目的时候只需要一个简单的配置文件即可完成配置管理。假如多个项目多个环境同时配置就会产生非常复杂的配置管理情况。 这个时候就需要用到配置中心了，它的原理其实类似于redis缓存这种。不同之处在于配置中心只关注配置，并且有更多的有利于配置的功能。大概的功能如下： 同时这些功能也是这次要开发的配置中心需要包含的功能。 本次开发的配置中心是基于nodejs的版本。客户端获取配置的方式可以参考协议来开发属于自己的客户端SDK。目前已经提供的是javascript版本。 功能设计配置中心的开发是基于nodejs的，这里先看一下大体的流程。 从上面可以看到，一个配置中心最主要的功能包括： 数据存储。这里使用存储协议匹配多种存储形式。 定时任务。这里包含了定时存储和自定义的定时更新任务。 web站点。主要是提供一个简单快速的设置配置的方式。 心跳检测。使用TCP协议将客户端和配置中心相连，可以监听到配置的改动，及时获取最新的配置内容。 开发功能落实到具体的开发上面其实非常简单，很多时候可能只需要一个了解和实践的过程。这里我把大概的思路跟大家捋一下。 数据存储存储的目的只有2个： 存储用到的配置。这里只是简单的实现了列表、存、取的功能 用户登录。 本教程目前只实现了本地json文件的读写，如果想要使用MySQL或者Redis等可以自己按照下面的协议实现。 init()，存储库的初始化方法。在项目启动的时候会第一时间调用。 list()，获取命名空间列表。这里使用命名空间区分不同的配置文件。这里默认使用def来保存第一个文件。 all(namespace = &quot;def&quot;)，获取对应命名空间下的配置内容。 update(namespace, txt)，更新一个命名空间的所有配置。这里传入的是字符串，保存的也是字符串。 get(key, namespace = &quot;def&quot;)，获取对应命名空间下的某个字段的内容。这里需要警惕，配置不一定是json对象的。 set(key, val, namespace = &quot;def&quot;)，设置对应命名空间下的某个字段的值。 login(user, pwd)，登录判断，目前返回true或者false就可以了。 只要是实现了上面协议的存储库就可以无痕替换掉项目的存储方式。 定时任务固定的定时任务只有定时存储当前缓存的配置数据。这里一个是为了项目重启的时候能够获得上次保存的配置内容，另外一个也是为了防止程序崩溃的情况下能够不丢失已经保存的数据。 程序内容设定了一个状态变量changed，如果有对应的配置变动了，就会将其的状态变更为true。定时保存任务就会在启动的时候讲数据保存在存储库中。 自定义定时任务的目的在于设置一个配置结果和定时时间，当时间到了的时候就触发一次更新操作。这个功能实现非常简单，但是对于使用的人来说是一个非常好用的功能。例如：半夜2点定时上线某些产品什么的。。。。在也不需要熬夜等了。 这次分享的项目还没有实现这个自定义定时更新功能。在后续的更新中会逐步完善这个功能。 web站点web站点就是操作配置的地方。项目默认提供了几个接口用来获取和更新配置。 目前使用jQuery实现，界面比较简陋，基础功能已经实现了。 这里可以看到最上面是命名空间的标签。下面是添加命名空间。再往下是显示和编辑配置的地方。 心跳检测心跳其实才是配置中心的核心内容。它主要的任务就是及时并且快速的通知到客户端配置有更新，需要使用最新的配置。 服务端使用nodejs的net.createServer方法创建一个TCP的监听服务，如果客户端连接就会将客户端的连接对象放入对象缓存池。 在连接的时候这里做了2件事： 给连接对象添加了一个uuid，方便辨认不同的客户端。 通知客户端发送验证令牌。这里的逻辑比较简陋，只是简单的验证一下。 在连接之后就是心跳检测的过程了。客户端需要定时去更新自己的状态，服务端根据这个请求来更新客户端的最后存在时间，加入超时或者断开连接就代表客户端断线，就会将客户端从对象缓存池中移除。 如果web站点更新了对应的配置，服务端会主动发送命名到客户端。命令类似于操作|命名空间|更改值，客户端根据收到的命令触发客户端的配置更新监听并且使用远程api更新客户端的缓存配置。 客户端本身会自动更新配置内容，同时提供了一个监听方法便于监听配置的更改。 多环境配置在服务端根目录下有一个config目录，这里就是给服务端多环境提供的配置。 只需要根据NODE_ENV的值创建对应的文件即可。项目启动的时候会自动根据环境参数使用对应文件的配置。 如果你要问客户端的多环境？命名空间已经完全可以实现了。如果要添加更多级的环境参数可以自定义命名空间的命名协议，比如：test.conf1这样的方式即可在不更改主体程序的情况下实现多级配置环境。代价是需要修改web站点的界面。。。。 结束语到此一个nodejs版本的轻量级配置中心已经开发完成。如果将上面最开始提到的功能全部完成，这个项目也就不仅仅是一个轻量级的配置中心。它的功能已经完全不亚于其他的开源配置中心了。 有兴趣的可以参与进来一起更新最好用的配置中心。 项目地址","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/categories/nodejs/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.guofangchao.com/tags/前端/"},{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/tags/nodejs/"},{"name":"配置中心","slug":"配置中心","permalink":"http://www.guofangchao.com/tags/配置中心/"}],"keywords":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/categories/nodejs/"}]},{"title":"centos安装Rabbitmq3.7.7","slug":"centos安装Rabbitmq3-7-7","date":"2018-11-01T09:56:00.000Z","updated":"2018-11-01T09:57:33.667Z","comments":true,"path":"2018/11/01/centos安装Rabbitmq3-7-7/","link":"","permalink":"http://www.guofangchao.com/2018/11/01/centos安装Rabbitmq3-7-7/","excerpt":"","text":"安装erlang安装教程 安装下面的提示新建一个文件，内容就是代码。 To use Erlang 21.x on CentOS 7:12345678# In /etc/yum.repos.d/rabbitmq-erlang.repo[rabbitmq-erlang]name=rabbitmq-erlangbaseurl=https://dl.bintray.com/rabbitmq/rpm/erlang/21/el/7gpgcheck=1gpgkey=https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.ascrepo_gpgcheck=0enabled=1 To use Erlang 21.x on CentOS 6:12345678# In /etc/yum.repos.d/rabbitmq-erlang.repo[rabbitmq-erlang]name=rabbitmq-erlangbaseurl=https://dl.bintray.com/rabbitmq/rpm/erlang/21/el/6gpgcheck=1gpgkey=https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.ascrepo_gpgcheck=0enabled=1 执行安装命令yum install erlang 安装完成之后用命令检查一下erl 安装socat123wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repoyum -y install socat 安装rabbitmq官方下载 12345678910111213141516171819202122# 启动service rabbitmq-server start# 停止service rabbitmq-server stop# 重启service rabbitmq-server restart# 开机自启chkconfig rabbitmq-server on# 启用监控插件rabbitmq-plugins enable rabbitmq_management# 修改防火墙vim /etc/sysconfig/iptables# 开放端口15672 和 5672-A INPUT -m state --state NEW -m tcp -p tcp --dport 15672 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 5672 -j ACCEPT# 重启防火墙service iptables restart 12345678910111213141516171819202122232425# 添加用户admin,密码为123456rabbitmqctl add_user admin 123456# 给用户添加管理员角色rabbitmqctl set_user_tags admin administrator# 查看所有用户rabbitmqctl list_users# 查看admin所有权限rabbitmqctl list_user_permissions admin# 清除admin权限[指定权限]rabbitmqctl clear_permissions [-p VHostPath] admin# 查看所有权限[-p test_vhosts] 或指定权限rabbitmqctl list_permissions [-p VHostPath]# 设置admin在VHostPath下的权限rabbitmqctl set_permissions -p VHostPath admin ConfP WriteP ReadP# 删除admin用户rabbitmqctl delete_user admin# 修改admin的密码为123456rabbitmqctl change_password admin 123456# 启用监控插件rabbitmq-plugins enable rabbitmq_management# 关闭监控插件rabbitmq-plugins disable rabbitmq_management tips: 新启动的管理界面只支持本机访问，设置远程操作等都需要先在本机设置。可以使用nginx代理到一个域名之类的来操作，也可以开启远程访问：）","categories":[{"name":"运维","slug":"运维","permalink":"http://www.guofangchao.com/categories/运维/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://www.guofangchao.com/tags/RabbitMQ/"},{"name":"CentOS7","slug":"CentOS7","permalink":"http://www.guofangchao.com/tags/CentOS7/"}],"keywords":[{"name":"运维","slug":"运维","permalink":"http://www.guofangchao.com/categories/运维/"}]},{"title":"生成自签名证书x509","slug":"生成自签名证书x509","date":"2018-09-28T10:53:00.000Z","updated":"2018-09-28T10:55:30.695Z","comments":true,"path":"2018/09/28/生成自签名证书x509/","link":"","permalink":"http://www.guofangchao.com/2018/09/28/生成自签名证书x509/","excerpt":"","text":"第1步：生成私钥openssl genrsa -des3 -out server.key 2048 第2步：生成CSR（证书签名请求）openssl req -new -key server.key -out server.csr 记得Common Name指的是服务器当前的域名或者ip 第3步：删除私钥中的密码12cp server.key server.key.org openssl rsa -in server.key.org -out server.key 第4步：生成自签名证书openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}],"tags":[{"name":"证书","slug":"证书","permalink":"http://www.guofangchao.com/tags/证书/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}]},{"title":"vscode插件收集","slug":"vscode插件收集","date":"2018-08-24T03:44:00.000Z","updated":"2018-08-24T03:44:51.502Z","comments":true,"path":"2018/08/24/vscode插件收集/","link":"","permalink":"http://www.guofangchao.com/2018/08/24/vscode插件收集/","excerpt":"","text":"Quokka.jsQuokka.js 是一个用于 JavaScript 和 TypeScript 的实时运行代码平台。 这意味着它会在你输入后立即运行您的代码，并在您的代码编辑器中显示各种执行结果。 建议你亲自尝试一下。 安装此扩展后，可以按 Ctrl/Cmd(⌘) + Shift + P 显示编辑器的命令选项面板，然后键入 Quokka 以查看可用命令的列表。 选择并运行 “新建JavaScript文件” 命令。 您也可以按（⌘ + K + J）直接打开文件。 您在此文件中键入的任何内容都会立即执行。 类似的扩展 – Code Runner – 支持多种语言，如C，C ++，Java，JavaScript，PHP，Python，Perl，Perl 6等。 Runner 括号配对着色(Bracket Pair Colorizer) 和 彩虹缩进(Indent Rainbow)花括号和园括号是许多编程语言不可分割的部分。在 JavaScript 等语言中，在一屏代码中花括号和园括号可能有多层嵌套，然而缺没有简单的机制来识别这些括号从哪里开始，又在哪里结束对。欢迎使用 括号配对着色(Bracket Pair Colorizer) 和 彩虹缩进(Indent Rainbow)。这是两个不同的扩展。然而，他们就像是一对情侣，可以完美的配合使用。这些扩展将为您的编辑器添加一系列颜色，并使代码块易于辨别和令人愉悦。一旦你习惯了它们，如果 VSCode 没有它们就会让人觉得很平淡。 愚人码头注：彩虹缩进(Indent Rainbow)扩展为每个缩进层级用四种不同颜色交替着色。 TODO高亮通常在进行编码时，你认为可能有更好的方法来执行相同的操作。 这时你留下注释 // TODO: 需要重构 或其他相关的东西。 但是你很容易忘记了这个注释，并将你的代码推送到主版本库(master) 或者生产环境(production)。 但是你如果使用 Todo Highlighter（高亮），这钟请客就不会发生。 它以鲜艳的颜色突显您的 “TODO” / “FIXME” 或代码中的任何其他注释，因此它始终清晰可见。 另外还有一个很好的功能是 List Highlighted annotations 。 它会在控制台中列出了所有 TODO 。 注释高亮 Better Comments支持各种语言 Import Cost(花销)Import Cost 允许您查看导入模块的大小。 这对 Webpack 等打包工具来说是一个巨大的帮助。 您可以查看是导入整个库还是仅导入特定实用程序。 不足之处是它不显示自定义文件或模块的花销。 REST Client作为Web开发人员，我们经常需要使用 REST API。为了检查URL并检查响应，使用 Postman 等工具。但是，当编辑器可以轻松完成相同的任务时，为什么还要使用不同的应用程序呢。欢迎使用 REST Client。它允许您在Visual Studio Code中直接发送 HTTP 请求并查看响应。 自动闭合标记(Auto Close Tag)和自动重命名标记(Auto Rename Tag)自从 React 问世以及它在过去几年中获得的关注度，类 HTML 的 JSX 语法现在很风靡。我们再次在 JavaScript 代码中使用使用标记。任何 Web 开发人员都会告诉您输入标记很麻烦。在大多数情况下，我们需要一种能够快速轻松地生成标签及其子代的工具。VSCode 中内置的 Emmet 就是一个非常好的例子。但是，有时候，你只想要一些简单而简洁的东西。例如自动更新标记，它在您键入开始标记时自动生成结束标记。当您更改同一个标记对时，结束标记会自动更改。 这两个扩展就是这样做的。 它还适用于JSX和许多其他语言，如XML，PHP，Vue，JavaScript，TypeScript，TSX。 GitLens正如其作者所说，GitLens增强了Visual Studio Code中内置的Git功能。 它包含了许多强大的功能，例如通过跟踪代码显示的代码作者，提交搜索，历史记录和GitLens资源管理器。 您可以在 此处 阅读这些功能的完整说明。 我只想说你应该安装这个插件，如果你使用git做任何事情的话。 Indenticator(缩进指示器)Indenticator(缩进指示器) 在视觉上突出显示当前的缩进深度。因此，现在您可以轻松区分在不同层次缩进的各种代码块。 VSCode Icons Beautify代码美化/格式化插件 备选,Prettier — 一个代码格式化工具","categories":[{"name":"工具","slug":"工具","permalink":"http://www.guofangchao.com/categories/工具/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://www.guofangchao.com/tags/插件/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://www.guofangchao.com/categories/工具/"}]},{"title":"mac下安装item2","slug":"mac下安装item2","date":"2018-08-17T06:50:00.000Z","updated":"2018-08-17T06:50:20.846Z","comments":true,"path":"2018/08/17/mac下安装item2/","link":"","permalink":"http://www.guofangchao.com/2018/08/17/mac下安装item2/","excerpt":"","text":"安装首先我们下载的 iTem2 这个软件，比Mac自带的终端更加强大。直接官网 http://iterm2.com/ 下载并安装即可。 安装oh-my-zshgithub连接：https://github.com/robbyrussell/oh-my-zsh 使用 crul 安装：1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 或使用wget：1sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 主题安装成功后，用vim打开隐藏文件 .zshrc ，修改主题为 agnoster：1ZSH_THEME=&quot;agnoster&quot; 应用这个主题需要特殊的字体支持，否则会出现乱码情况，这时我们来配置字体： 使用 Meslo 字体，点开连接点击 view raw 下载字体。 安装字体到系统字体册。 应用字体到iTerm2下，我自己喜欢将字号设置为14px，看着舒服（iTerm -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Change Font）。 重新打开iTerm2窗口，这时便可以看到效果了。 自动提示命令当我们输入命令时，终端会自动提示你接下来可能要输入的命令，这时按 → 便可输出这些命令，非常方便。 设置如下： 克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径下 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 用 vim 打开 .zshrc 文件，找到插件设置命令，默认是 plugins=(git) ，我们把它修改为 1plugins=(zsh-autosuggestions git) 语法高亮 使用homebrew安装 zsh-syntax-highlighting 插件。 配置.zshrc文件，插入一行。 输入命令。 12345brew install zsh-syntax-highlightingsource /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zshsource ~/.zshrc","categories":[{"name":"工具","slug":"工具","permalink":"http://www.guofangchao.com/categories/工具/"}],"tags":[{"name":"iterm2","slug":"iterm2","permalink":"http://www.guofangchao.com/tags/iterm2/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://www.guofangchao.com/categories/工具/"}]},{"title":"用node创建https服务","slug":"用node创建https服务","date":"2018-08-14T08:30:00.000Z","updated":"2018-08-14T08:30:55.276Z","comments":true,"path":"2018/08/14/用node创建https服务/","link":"","permalink":"http://www.guofangchao.com/2018/08/14/用node创建https服务/","excerpt":"","text":"用Node.js创建自签名的HTTPS服务器 创建自己的CA机构 创建服务器端证书 创建客户端证书 将证书打包创建自己的CA机构 为CA生成私钥 genrsa -out ca-key.pem -des 1024```1234- 通过CA私钥生成CSR ```javascript openssl req -new -key ca-key.pem -out ca-csr.pem 通过CSR文件和私钥生成CA证书 1openssl x509 -req -in ca-csr.pem -signkey ca-key.pem -out ca-cert.pem 可能会遇到的问题 你需要root或者admin的权限Unable to load config info from /user/local/ssl/openssl.cnf对于这个问题，你可以从网上下载一份正确的openssl.cnf文件，然后set OPENSSL_CONF=openssl.cnf文件的本地路径 创建服务器端证书 为服务器生成私钥openssl genrsa -out server-key.pem 1024 利用服务器私钥文件服务器生成CSRopenssl req -new -key server-key.pem -config openssl.cnf -out server-csr.pem 这一步非常关键，你需要指定一份openssl.cnf文件。可以用这个12345678910111213141516171819202122232425[req] distinguished_name = req_distinguished_name req_extensions = v3_req [req_distinguished_name] countryName = Country Name (2 letter code) countryName_default = CN stateOrProvinceName = State or Province Name (full name) stateOrProvinceName_default = BeiJing localityName = Locality Name (eg, city) localityName_default = YaYunCun organizationalUnitName = Organizational Unit Name (eg, section) organizationalUnitName_default = Domain Control Validated commonName = Internet Widgits Ltd commonName_max = 64 [ v3_req ] # Extensions to add to a certificate request basicConstraints = CA:FALSE keyUsage = nonRepudiation, digitalSignature, keyEncipherment subjectAltName = @alt_names [alt_names] #注意这个IP.1的设置，IP地址需要和你的服务器的监听地址一样 IP.1 = 127.0.0.1 通过服务器私钥文件和CSR文件生成服务器证书openssl x509 -req -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial -in server-csr.pem -out server-cert.pem -extensions v3_req -extfile openssl.cnf 创建客户端证书 生成客户端私钥openssl genrsa -out client-key.pem 利用私钥生成CSRopenssl req -new -key client-key.pem -out client-csr.pem 生成客户端证书openssl x509 -req -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial -in client-csr.pem -out client-cert.pem HTTPS 服务器代码12345678910111213var https = require('https');var fs = require('fs');var options = &#123; key: fs.readFileSync('./keys/server-key.pem'), ca: [fs.readFileSync('./keys/ca-cert.pem')], cert: fs.readFileSync('./keys/server-cert.pem')&#125;;https.createServer(options,function(req,res)&#123; res.writeHead(200); res.end('hello world\\n');&#125;).listen(3000,'127.0.0.1'); HTTPS 客户端代码1234567891011121314151617181920212223242526272829var https = require('https');var fs = require('fs');var options = &#123; hostname:'127.0.0.1', port:3000, path:'/', method:'GET', key:fs.readFileSync('./keys/client-key.pem'), cert:fs.readFileSync('./keys/client-cert.pem'), ca: [fs.readFileSync('./keys/ca-cert.pem')], agent:false&#125;;options.agent = new https.Agent(options);var req = https.request(options,function(res)&#123;console.log(\"statusCode: \", res.statusCode); console.log(\"headers: \", res.headers); res.setEncoding('utf-8'); res.on('data',function(d)&#123; console.log(d); &#125;)&#125;);req.end();req.on('error',function(e)&#123; console.log(e);&#125;) 将证书打包 打包服务器端证书openssl pkcs12 -export -in server-cert.pem -inkey server-key.pem -certfile ca-cert.pem -out server.pfx 打包客户端证书openssl pkcs12 -export -in client-cert.pem -inkey client-key.pem -certfile ca-cert.pem -out client.pfx 服务器端代码123456789101112var https = require('https');var fs = require('fs');var options = &#123; pfx:fs.readFileSync('./keys/server.pfx'), passphrase:'your password'&#125;;https.createServer(options,function(req,res)&#123; res.writeHead(200); res.end('hello world\\n');&#125;).listen(3000,'127.0.0.1'); 客户端代码12345678910111213141516171819202122232425262728var https = require('https');var fs = require('fs');var options = &#123; hostname:'127.0.0.1', port:3000, path:'/', method:'GET', pfx:fs.readFileSync('./keys/server.pfx'), passphrase:'your password', agent:false&#125;;options.agent = new https.Agent(options);var req = https.request(options,function(res)&#123;console.log(\"statusCode: \", res.statusCode); console.log(\"headers: \", res.headers); res.setEncoding('utf-8'); res.on('data',function(d)&#123; console.log(d); &#125;)&#125;);req.end();req.on('error',function(e)&#123; console.log(e);&#125;)","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/tags/nodejs/"},{"name":"https","slug":"https","permalink":"http://www.guofangchao.com/tags/https/"}],"keywords":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/categories/nodejs/"}]},{"title":"julia安装1.0教程","slug":"julia安装1-0教程","date":"2018-08-11T06:06:00.000Z","updated":"2018-08-11T06:06:42.638Z","comments":true,"path":"2018/08/11/julia安装1-0教程/","link":"","permalink":"http://www.guofangchao.com/2018/08/11/julia安装1-0教程/","excerpt":"","text":"julia是一个新型的语言，它高性能、使用简单、面向广大的开发者。这注定了我们将会在适当的时候使用它来开发各种东西。比如深度学习之类各种框架。 网上的教程大多是基于0.4之类的版本，高一些的也是0.6的。新手接触的时候免不了各种迷茫，完全不知道怎么安装julia。这里提供一份教程给大家。当前使用版本是1.0，api有一些改动，同时pkg也使用了新的方式加载包。 安装julia的安装window、mac和linux三种，前两种需要下载安装包，第三中可以直接通过编译获得。 打开网址https://julialang.org/downloads/，下载我们需要的64位安装包 mac的安装比较简单，这里就略过。安装成功之后可以在应用中找到我们安装的julia应用程序. 双击打开就会看到自动启动了julia的编译器。这里可以输入各种命令，实验一下julia高速的性能吧^_^ 不过不要高兴的太早，到这里仅仅能尝试各种新手教程中指导的变量、语法之类的简单东西。要想真正的开始体验开发，还需要配置我们的环境变量。 添加环境变量其他成熟的语言都已经在安装包内内置了环境变量的设置了。新手安装完之后一时可能想不起来还有这么一个操作。 编辑环境变量配置文件vi .bash_profile 在文件末尾添加我们的julia执行目录，这里注意替换自己的路径1export PATH=$&#123;PATH&#125;:/Applications/Julia-1.0.app/Contents/Resources/julia/bin 编辑完成之后记得执行source .bash_profile 现在在任何一个目录下都可以使用julia命令进入julia的环境或者执行.jl后缀的文件了。 安装包执行julia进入julia的环境，输入?可以查看帮助—-还是先看文档吧，这里的帮助也是在熟悉文档之后更方便。 输入]进入pkg的执行环境，同时可以输入?来查看帮助,这里解释了集中命令的作用。 假设我们要安装Bukdu这个包。在pkg环境下执行安装命令add Bukdu 可以看到下载不少包，静静的等待安装结果吧。 tips:写这篇文章的时候Bukdu这个包还不支持1.0版本，如果安装之后不能用是正常的 测试开发单文件试验新建一个test.jl文件，在文件中输入print(&quot;Hello World!&quot;)。 在当前目录下输入命令julia test.jl即可看到执行的结果 同时也可以试一下各种教程中的变量、方法、类型等写法。 模块加载这里再试一下加载模块是否可用。 新建一个需要调用的模块文件，这里新建一个module.jl。123456789module consoleexport logfunction log(msg) print(msg)endend 在新建一个要执行的jl文件。我们在里面调用刚才编写的模块文件。123456include(&quot;module.jl&quot;)using .console# 调用模块的输出方法,添加\\n换行console.log(&quot;test \\n&quot;)# 同时调用一下自带的错误提示@warn &quot;test base warn&quot; 执行命令看一下刚才的结果","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.guofangchao.com/categories/编程语言/"}],"tags":[{"name":"julia","slug":"julia","permalink":"http://www.guofangchao.com/tags/julia/"},{"name":"教程","slug":"教程","permalink":"http://www.guofangchao.com/tags/教程/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.guofangchao.com/categories/编程语言/"}]},{"title":"nodejs连接远程服务器","slug":"nodejs连接远程服务器","date":"2018-08-10T03:04:00.000Z","updated":"2018-08-10T03:05:58.798Z","comments":true,"path":"2018/08/10/nodejs连接远程服务器/","link":"","permalink":"http://www.guofangchao.com/2018/08/10/nodejs连接远程服务器/","excerpt":"","text":"nodejs使用ssh2这个库可以实现操作ssh访问远程服务器. 将下面的连接地址修改成远程即可实现直接连接远程服务器,同时可以在本地执行各种命令.123456789101112131415161718192021222324252627282930313233343536const Client = require(&quot;ssh2&quot;).Client;const client = new Client();client.on(&quot;ready&quot;, function () &#123; console.log(&apos;ssh已连接!&apos;); client.shell(function (err, stream) &#123; if (err) throw err; process.stdin.setEncoding(&apos;utf8&apos;); let command = false; process.stdin.on(&apos;readable&apos;, () =&gt; &#123; const chunk = process.stdin.read(); if (chunk !== null) &#123; command = true; stream.write(chunk) &#125; &#125;); stream.on(&apos;close&apos;, function () &#123; console.log(&apos;关闭shell&apos;); client.end(); &#125;).on(&apos;data&apos;, function (data) &#123; if (!command) process.stdout.write(data); command = false; &#125;).on(&quot;error&quot;, function (data) &#123; console.log(&apos;err: &apos; + data); &#125;).stderr.on(&apos;data&apos;, function (data) &#123; console.log(&apos;STDERR: &apos; + data); &#125;); &#125;);&#125;).connect(&#123; host: &apos;127.0.0.1&apos;, port: 22, username: &apos;root&apos;, password: &apos;123456&apos;&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/tags/nodejs/"},{"name":"ssh","slug":"ssh","permalink":"http://www.guofangchao.com/tags/ssh/"}],"keywords":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/categories/nodejs/"}]},{"title":"bigpipe分段加载","slug":"bigpipe分段加载","date":"2018-08-10T03:00:00.000Z","updated":"2018-08-10T03:03:42.548Z","comments":true,"path":"2018/08/10/bigpipe分段加载/","link":"","permalink":"http://www.guofangchao.com/2018/08/10/bigpipe分段加载/","excerpt":"","text":"网页分段加载就是在请求返回的时候一截一截的返回. 这里有一个例子:1234567891011121314151617181920router.get(&apos;/&apos;, function (req, res, next) &#123; // res.render(&apos;index&apos;, &#123; title: &apos;Express&apos; &#125;); res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/html&apos;, &apos;Transfer-Encoding&apos;: &apos;chunked&apos; &#125;); res.write(&quot;&lt;html&gt;&lt;/html&gt;&quot;); setTimeout(() =&gt; &#123; res.write(&quot;&lt;body&gt;&lt;/body&gt;&quot;); &#125;, 1000); setTimeout(() =&gt; &#123; res.write(&quot;test3&quot;); &#125;, 2000); setTimeout(() =&gt; &#123; res.write(&quot;test3&quot;); &#125;, 3000); setTimeout(() =&gt; &#123; res.end(&quot;test2&quot;); &#125;, 5000);&#125;); 先要设置head返回的类型是chunked,这样浏览器才会认识分段加载,否则就会直接等待最后结果. 后面使用定时器每隔一秒返回一截数据,浏览器也会适时的重新渲染网页.最后调用end方法结束这次请求.","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.guofangchao.com/tags/前端/"},{"name":"分段渲染","slug":"分段渲染","permalink":"http://www.guofangchao.com/tags/分段渲染/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"使用Sequelize连接数据库","slug":"使用Sequelize连接数据库","date":"2018-08-09T03:03:00.000Z","updated":"2018-08-09T03:05:15.245Z","comments":true,"path":"2018/08/09/使用Sequelize连接数据库/","link":"","permalink":"http://www.guofangchao.com/2018/08/09/使用Sequelize连接数据库/","excerpt":"","text":"Sequelize.js是一款针对nodejs的ORM框架。 使用nodejs连接过数据库的人肯定对数据库不陌生了。如果是直接链接，需要自己建立并管理连接，还需要手动编写sql语句。简单的项目到是无所谓，可是一旦项目设计的东西比较复杂，表比较多的时候整个sql的编写就非常的消耗精力。 在Java、c#等语言中已经有轻量的数据库框架或者解决方案了。在nodejs中我推荐Sequelize。它是一个很成熟的框架，在速度和性能上也非常有优势。而其中最关键的地方就在于，日常开发只需要管理对象的创建、查询方法的调用等即可，极少需要编写sql语句。这一个好处就是省去了复杂的sql语句维护，同时也避免了因sql而引起的不必要的bug。 Sequelize是针对node.js和io.js提供的ORM框架。具体就是突出一个支持广泛，配置和查询方法统一。它支持的数据库包括：PostgreSQL、 MySQL、MariaDB、 SQLite 和 MSSQL。 本文中测试以及API展示地址：github地址 演示Sequelize的调用突出一个简单快捷。具体情况可以感受一下下面的代码。如果有过开发经验的可以略过。1234567Table1.findById(23);//select a,b,c,d from table1 where id=23;Table1.findAll(&#123; where:&#123;a:\"test\",b:76&#125;&#125;);//select a,b,c,d from table1 where a=\"test\" and \"b=76; 在单表查询的时候只需要简单的配置即可完成查询。是不是非常的简单方便呢？ 连接数据库Sequelize的连接需要传入参数，并且可以配置开启线程池、读写分库等操作。 简单的写法是这样的:new Sequelize(&quot;表名&quot;,&quot;用户名&quot;,&quot;密码&quot;,配置) 正常使用中很少使用到所有的参数，这里提供一个常用的模板，只需要修改自己使用的值即可。12345678910const sequelize = new Sequelize('database', 'username', 'password', &#123; host: 'localhost', //数据库地址,默认本机 port:'3306', dialect: 'mysql', pool: &#123; //连接池设置 max: 5, //最大连接数 min: 0, //最小连接数 idle: 10000 &#125;, &#125;); 下面是详细的配置参数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const sequelize = new Sequelize('database', 'username', 'password', &#123; // 数据库类型，支持: 'mysql', 'sqlite', 'postgres', 'mssql' dialect: 'mysql', // 自定义链接地址，可以是ip或者域名，默认本机：localhost host: 'my.server.tld', // 自定义端口，默认3306 port: 12345, // postgres使用的参数,连接类型，默认：tcp protocol: null, // 是否开始日志，默认是用console.log // 建议开启，方便对照生成的sql语句 logging: true, // 默认是空 // 支持: 'mysql', 'postgres', 'mssql' dialectOptions: &#123; socketPath: '/Applications/MAMP/tmp/mysql/mysql.sock', supportBigNumbers: true, bigNumberStrings: true &#125;, // sqlite的存储位置,仅sqlite有用 // - 默认 ':memory:' storage: 'path/to/database.sqlite', // 是否将undefined转化为NULL // - 默认: false omitNull: true, // pg中开启ssl支持 // - 默认: false native: true, // 数据库默认参数,全局参数 define: &#123; underscored: false freezeTableName: false, charset: 'utf8', dialectOptions: &#123; collate: 'utf8_general_ci' &#125;, timestamps: true &#125;, // 是否同步 sync: &#123; force: true &#125;, // 连接池配置 pool: &#123; max: 5, idle: 30000, acquire: 60000, &#125;, isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ&#125;) 定义模型对象在使用之前一定要先创建模型对象。就是数据库中表的名称、使用到的字段、字段类型等。 这里有一个推荐的开发方式。先在nodejs中将对象创建出来，然后调用Sequelize的同步方法，将数据库自动创建出来。这样就避免了既要写代码建表，又要手工创建数据库中的表的操作。只需要单独考虑代码中的对象类型等属性就好了。 如果数据库中已经建好了表，并且不能删除，这个时候就不能自动创建了，因为创建的时候会删除掉旧的数据。 下面是简单的对象创建多数情况下这样就可以了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const users = db.define('t_user'/*自定义表名*/, &#123; id: &#123; type: Sequelize.INTEGER, primaryKey: true, //主键 autoIncrement: true, //自增 comment: \"自增id\" //注释:只在代码中有效 &#125;, //用户名 username: &#123; type: Sequelize.STRING, validate:&#123; isEmail: true, //类型检测,是否是邮箱格式 &#125; &#125;, //密码 pwd: &#123; type: Sequelize.STRING(10), allowNull: false,//不允许为null &#125;, //状态 status: &#123; type: Sequelize.INTEGER, defaultValue: 0,//默认值是0 &#125;, //昵称 nickname: &#123; type: Sequelize.STRING &#125;, //token token: &#123; type: Sequelize.UUID &#125;, create_time: &#123; type: Sequelize.DATE, defaultValue: Sequelize.NOW &#125;&#125;, &#123; //使用自定义表名 freezeTableName: true, //去掉默认的添加时间和更新时间 timestamps: false, indexes:[ //普通索引,默认BTREE &#123; unique: true, fields: ['pid'] &#125;, ]&#125;);//同步:没有就新建,有就不变// users.sync();//先删除后同步users.sync(&#123; force: true&#125;); 数据类型前段将了对象的创建，里面用到了对象的各种类型。这里再介绍一下类型的具体使用方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Sequelize.STRING //字符串,长度默认255,VARCHAR(255)Sequelize.STRING(1234) //设定长度的字符串,VARCHAR(1234)Sequelize.STRING.BINARY //定义类型VARCHAR BINARYSequelize.TEXT //长字符串,文本 TEXTSequelize.TEXT('tiny') //小文本字符串,TINYTEXTSequelize.INTEGER //int数字,intSequelize.BIGINT //更大的数字,BIGINTSequelize.BIGINT(11) //设定长度的数字,BIGINT(11)Sequelize.FLOAT //浮点类型,FLOATSequelize.FLOAT(11) //设定长度的浮点,FLOAT(11)Sequelize.FLOAT(11, 12) //设定长度和小数位数的浮点,FLOAT(11,12)Sequelize.REAL //REAL PostgreSQL only.Sequelize.REAL(11) // REAL(11) PostgreSQL only.Sequelize.REAL(11, 12) // REAL(11,12) PostgreSQL only.Sequelize.DOUBLE // DOUBLESequelize.DOUBLE(11) // DOUBLE(11)Sequelize.DOUBLE(11, 12) // DOUBLE(11,12)Sequelize.DECIMAL // DECIMALSequelize.DECIMAL(10, 2) // DECIMAL(10,2)Sequelize.DATE // 日期类型,DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgresSequelize.DATE(6) // mysql 5.6.4+支持,分秒精度为6位Sequelize.DATEONLY // 仅日期部分Sequelize.BOOLEAN // int类型,长度为1,TINYINT(1)Sequelize.ENUM('value 1', 'value 2') // 枚举类型Sequelize.ARRAY(Sequelize.TEXT) //PostgreSQL only.Sequelize.ARRAY(Sequelize.ENUM) // PostgreSQL only.Sequelize.JSON // JSON column. PostgreSQL, SQLite and MySQL only.Sequelize.JSONB // JSONB column. PostgreSQL only.Sequelize.BLOB // BLOB (bytea for PostgreSQL)Sequelize.BLOB('tiny') // TINYBLOB (bytea for PostgreSQL. Other options are medium and long)Sequelize.UUID // PostgreSQL和SQLite的数据类型是UUID, MySQL是CHAR(36)类型Sequelize.CIDR // PostgreSQL中的CIDR类型Sequelize.INET // PostgreSQL中的INET类型Sequelize.MACADDR // PostgreSQL中的MACADDR类型Sequelize.RANGE(Sequelize.INTEGER) //PostgreSQL only.Sequelize.RANGE(Sequelize.BIGINT) // PostgreSQL only.Sequelize.RANGE(Sequelize.DATE) //PostgreSQL only.Sequelize.RANGE(Sequelize.DATEONLY) //PostgreSQL only.Sequelize.RANGE(Sequelize.DECIMAL) //PostgreSQL only.Sequelize.ARRAY(Sequelize.RANGE(Sequelize.DATE)) // PostgreSQL only.Sequelize.GEOMETRY //PostgreSQL (with PostGIS) or MySQL only.Sequelize.GEOMETRY('POINT') // PostgreSQL (with PostGIS) or MySQL only.Sequelize.GEOMETRY('POINT', 4326)// PostgreSQL (with PostGIS) or MySQL only. 数据类型检测上面可以看到使用validate字段去验证字段的值是否符合标准，这样就可以在入库之前就能知道数据是否符合规则。否则贸然将陌生的数据存入数据库就好像将陌生人带到家里一样，是否安全全靠缘分啊。 Sequelize内置支持的验证还是非常的多的，如果这些都不满意，还可以自己定义一个。12345678910111213141516171819202122232425262728293031323334353637383940validate: &#123; is: [\"^[a-z]+$\",'i'], // 全匹配字母 is: /^[a-z]+$/i, // 全匹配字母，用规则表达式写法 not: [\"[a-z]\",'i'], // 不能包含字母 isEmail: true, // 检查邮件格式 isUrl: true, // 是否是合法网址 isIP: true, // 是否是合法IP地址 isIPv4: true, // 是否是合法IPv4地址 isIPv6: true, // 是否是合法IPv6地址 isAlpha: true, // 是否是字母 isAlphanumeric: true, // 是否是数字和字母 isNumeric: true, // 只允许数字 isInt: true, // 只允许整数 isFloat: true, // 是否是浮点数 isDecimal: true, // 是否是十进制书 isLowercase: true, // 是否是小写 isUppercase: true, // 是否大写 notNull: true, // 不允许为null isNull: true, // 是否是null notEmpty: true, // 不允许为空 equals: 'specific value', // 等于某些值 contains: 'foo', // 包含某些字符 notIn: [['foo', 'bar']], // 不在列表中 isIn: [['foo', 'bar']], // 在列表中 notContains: 'bar', // 不包含 len: [2,10], // 长度范围 isUUID: 4, // 是否是合法 uuids isDate: true, // 是否是有效日期 isAfter: \"2011-11-05\", // 是否晚于某个日期 isBefore: \"2011-11-05\", // 是否早于某个日期 max: 23, // 最大值 min: 23, // 最小值 isArray: true, // 是否是数组 isCreditCard: true, // 是否是有效信用卡号 // 自定义规则 isEven: function(value) &#123; if(parseInt(value) % 2 != 0) &#123; throw new Error('请输入偶数!') &#125;&#125; API略讲Sequelize的API基本覆盖了常用的使用方式，其中单表查询常用的有一下几种。复杂的可以参考更多的API。 查询多条 findAll(opts) 或者 all(opts)查询用的参数普遍通用，只有部分API的有特殊参数。这里展示一次常用参数，下面就略过了。1234567891011121314let list = await model.findAll(&#123; where:&#123; id:&#123;$gt:10&#125;,//id大于10的 name:\"test\" //name等于test &#125;, order:[ \"id\", //根据id排序 [\"id\",\"desc\"]//根据id倒序 ], limit:10,//返回个数 offset:20,//起始位置,跳过数量 attributes:[\"attr1\",\"attr2\"], //返回的字段&#125;);//select attr1,attr2 from model where ...... 通过id查询 findById(id,opts)这里默认数据的主键是id，查询的时候直接通过id查询数据。这里推荐在新建数据库的时候可以添加id作为唯一主键。12let model = await model.findById(12);//select a,b,c from model where id=12; 查询一条记录 findOne(opts)根据条件查询记录，这里的条件一定要填写，不然就是返回第一条数据了。1234let model = await model.findOne(&#123; where:&#123;id:12&#125;&#125;);//select a,b,c from model where id=12; 分页查询 findAndCount(opts) 或者 findAndCountAll分页查询恐怕是另外一个常用方法了。任何一个列表都有需要分页的时候。 这个方法会同时执行2跳语句。123456789let data = await model.findAndCount(&#123; limit:10,//每页10条 offset:0*10,//第x页*每页个数 where:&#123;&#125;&#125;);let list = data.rows;let count = data.count;//select count(*) from model where ...;//select a,b,c from model where .... limit 0,10; 添加新数据 create(model,opts)添加就非常的自在了。简单的只需要传入model对象即可。这里要保证model对象的属性和字段名要一致。如果不一致就会出错。也可以传入配置参数来增加条件等。123456let model= &#123; name:\"test\", token:\"adwadfv2324\"&#125; await model.create(model);//insert into model (name,token) values(\"test\",\"adwadfv2324\"); 查询,不存在就返回默认对象 findOrInitialize(opts)opts.default 默认值对象 这个方法首先会查询数据库，如果没有结果就会返回参数中的default对象。这个比较适合返回默认对象之类的场景。 查询,不存在就新建一个 findOrCreate(opts)或者findCreateFind这个方法用到的情况也比较多。通常用于自动创建不存在的数据。直接就返回了默认值。 有则更新,无则添加 upsert(model,opts) 或者 insertOrUpdate(model,opts)根据主键或者唯一约束键匹配 常用于编辑的时候添加或者更新统一操作。 更新记录 update(model,opts)就是最常用的更新方法，可以传入要更新的model对象，同时用配置参数有条件的区别要更新的对象。 删除记录 destroy(opts)删除有2种情况，一种是物理删除。删除就从表中不存在了。另外一种就是设置paranoid，这个是虚拟删除，默认一个字段表示数据是否删除，查询的时候去掉这个条件即可查询到删除的数据。 恢复记录 restore(opts)恢复多个实例，当启用paranoid时就可以使用这个方法将曾今删除的数据恢复了。 其他常用API 指定字段查询最大值 max(“id”,opts) 指定字段查询最小值 min(“id”,opts) 求和 sum(“id”,opts) 批量添加 bulkCreate([model],opts) 查表结构的信息 describe() 递增 increment(“id”,{by:1}) 递减 decrement(“id”,{by:1}) 统计查询个数 count(opts) 事务Sequelize中的事务比较简单。但是如果有多个事务的话写出来的代码会非常的难看。这也算是Sequelize优化的比较差的地方了。 需要记得transaction参数要一致传递就可以了。其他就是一个正常的Promise调用。12345678910111213141516171819//调用Sequelize初始化之后的sequelize对象return sequelize.transaction(function (t) &#123; //返回最终的Promise return User.create(&#123; firstName: 'Abraham', lastName: 'Lincoln' &#125;, &#123;transaction: t&#125;).then(function (user) &#123; return user.setShooter(&#123; firstName: 'John', lastName: 'Boothe' &#125;, &#123;transaction: t&#125;); &#125;);&#125;).then(function (result) &#123; //主动调用commit提交结果 return t.commit();&#125;).catch(function (err) &#123; //主动回滚操作 return t.rollback();&#125;); 多表联查外键可能算是Sequelize中的一个难点了。这里涉及的东西稍微多一点，我们来慢慢捋一遍。 外键知识点外键的定制作用—-三种约束模式： district：严格模式(默认), 父表不能删除或更新一个被子表引用的记录。 cascade：级联模式, 父表操作后，子表关联的数据也跟着一起操作。也是Sequelize的默认模式。 set null：置空模式,前提外键字段允许为NLL, 父表操作后，子表对应的字段被置空。 使用外键的前提在Sequelize中使用外键需要提前检查一下下面的这些选项，里面有一条出错就会导致设置失败。 表储存引擎必须是innodb，否则创建的外键无约束效果。 外键的列类型必须与父表的主键类型完全一致。 外键的名字不能重复。 已经存在数据的字段被设为外键时，必须保证字段中的数据与父表的主键数据对应起来。 使用示例—默认默认情况下，主键使用的是主表的id字段，外键是使用的按照table+字段的方式建立的外键。一般情况下需要手动指定。12345678//主表指定关系 test1.hasMany(test2, &#123; foreignKey: \"pid\",//外键名称 &#125;); //子表指定关系 test2.belongsTo(test1, &#123; foreignKey: \"pid\",//外键名称 &#125;); 默认就会在子表中添加一条外键记录，指向的就是主表的id。一般情况下这样就能够满足正常的使用了。比如一个主表记录商品信息，一个子表记录多个评论消息。 使用示例—自定义如果主表使用的主键id并不能满足正常的使用，还可以指定某一个固定的字段作为主表中的约束关系。 tips：主表中如果不是使用id作为主要关系，自定义的字段必须添加索引等条件，作为依赖中的关系。 1234567891011121314 test1.hasMany(test2, &#123; foreignKey: \"pid\",//外键字段名 sourceKey: \"pid\",//主键字段名 &#125;); test2.belongsTo(test1, &#123; foreignKey: \"pid\",//关联名 targetKey:\"pid\"//自定义外键字段 &#125;); //等待主键建立成功再建立子表的外键关系 setTimeout(() =&gt; &#123; test2.sync(&#123; force: true &#125;);&#125;, 2500); 使用示例—伪关系实际使用的时候我还是倾向于这种关系。即表中关系已定的情况下仅仅指定外键关系。同步的时候仅仅同步表内容，不同步这个外键关系。 真正的建立可以使用手动建表的时候添加。或者也可以在自动建表结束后异步再执行一次外键关系的添加。 12345678910test1.hasMany(test2, &#123; foreignKey: \"pid\", sourceKey: \"pid\", constraints: false //不同步建立外键关系&#125;);test2.belongsTo(test1, &#123; foreignKey: \"pid\", targetKey:\"pid\", constraints: false //不同步建立外键关系&#125;); 示例实际的操作部分大家可以看github中的test.js。github地址 单表操作Sequelize在查询结果返回之后会返回一个它自定义的对象。这个对象是支持继续操作的，其中具体的值存放在datavalues中。不过可以放心的是在转化为字符串的时候是不会带有任何Sequelize的属性的。 1234567891011//根据条件查询一条数据let model = await test1.findOne(&#123; where:&#123; id:5, name:\"test\" &#125;&#125;);//修改其中的name字段的值model.name=\"更新\";//保存,会自动update数据库中的值model.save(); 联查正常的使用过程中很少会说只需要查询一个表就能结果问题的。这里再说一下2个表查询的时候是怎么使用的。 这里的查询默认已经做好了外键的的关系。不过在使用的时候不做也是可以的，就是在查询的时候性能稍微不好而已。1234567891011//查询主表list的数据//一条list中的数据对应多条item中的数据 let data = await models.List.findAll(&#123; where:&#123;id:5&#125;,//条件,这里jiashe只需查询一条 include: [&#123; model: models.Item, as:\"items\",//返回的对象修改成一个固定的名称 &#125;] &#125;); let list1=data[0];//返回的第一条数据就是要查询的数据 let list2=list1.items;//返回子表数据,items是自定义的名称 总结上面的介绍已经解决了大多数情况下的查询等操作。而且我也相信，真的遇到了瓶颈，解决方案很可能也并不是在Sequelize方面，或者说主要不是Sequelize的问题。比如大数据量的时候分表操作，就涉及到了更多的知识点。 nodejs在做后端方面还处于发展阶段。希望有更多的前端能够接触并了解它。不仅仅在开发过程中对自己是一个增强，在长期的职业规划中也是一个很好的增强自己的武器。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.guofangchao.com/tags/前端/"},{"name":"Sequelize","slug":"Sequelize","permalink":"http://www.guofangchao.com/tags/Sequelize/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"动态RN技术构思","slug":"动态RN技术构思","date":"2018-08-06T12:19:00.000Z","updated":"2018-08-06T12:27:57.932Z","comments":true,"path":"2018/08/06/动态RN技术构思/","link":"","permalink":"http://www.guofangchao.com/2018/08/06/动态RN技术构思/","excerpt":"","text":"RN项目中正常的开发方式: 准备RN壳 准备js代码,开发基础界面,操作交互等 上线,APP请求后端数据 我一直在考虑,是不是可以将本地数据全部放在服务端呢? 远程数据可以缓存在本地 远程数据都可以随时变化 基本不需要发布新代码 这个方案可不可行还不好说.我觉得很有前景,当本地的东西可以随时发布的时候,不仅用户是不需要费事的,后端的同学也不用再考虑兼容旧接口,等待APP更新这些操作了. 下面说一说需要的思路吧 需要一个核心引擎,用来将远程数据渲染成APP上的界面.这个引擎能够分辨View、Button之类的东西.并且能够在需要的时候加上事件.同时还需要能够使用第三方组件之类的东西. 需要一个管理端的渲染程序.这个是受到目前的动态生成网页的提示.既然客户端都可以动态渲染了.那管理端当然也需要可视化操作了. 管理端即时修改,然后保存到服务端.用户进入页面的时候带着页面的缓存token之类的,过期直接下载新的页面. 前期考虑的周到的话只需要服务端直接修改即可做到更新用户的界面. 想想还是很美好的,尤其是现在前端越来越复杂的情况,为了因为无尽的需求,这样一个可视化的界面真的是非常的好用的.","categories":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/categories/react-native/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"},{"name":"想法","slug":"想法","permalink":"http://www.guofangchao.com/tags/想法/"}],"keywords":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/categories/react-native/"}]},{"title":"js高级技巧","slug":"js高级技巧","date":"2018-07-28T13:45:00.000Z","updated":"2018-07-28T13:52:47.685Z","comments":true,"path":"2018/07/28/js高级技巧/","link":"","permalink":"http://www.guofangchao.com/2018/07/28/js高级技巧/","excerpt":"","text":"将数组中的空值去除const arrContainsEmptyVal = [3, 4, 5, 2, 3, undefined, null, 0, “”]; 将数组中重复项清除const uniq = arr =&gt; […new Set(arr)]; 取出对象中的深层属性1234const pluckDeep = path =&gt; obj =&gt; path.split(&quot;.&quot;).reduce((val, attr) =&gt; val[attr], obj);pluckDeep(&quot;a.b.c&quot;)(deepAttr); 将 Stark 家族成员提取出来。注意，目标数据在数组前面，使用 filter 方法遍历整个数组是浪费。123456const takeWhile = f =&gt; ([head, ...tail]) =&gt; f(head) ? [head, ...takeWhile(f)(tail)] : [];const isStark = name =&gt; name.toLowerCase().includes(&quot;stark&quot;);takeWhile(isStark)(houses);","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.guofangchao.com/tags/javascript/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"自定义web框架","slug":"自定义web框架","date":"2018-07-28T09:55:00.000Z","updated":"2018-07-28T09:56:10.420Z","comments":true,"path":"2018/07/28/自定义web框架/","link":"","permalink":"http://www.guofangchao.com/2018/07/28/自定义web框架/","excerpt":"","text":"不会造轮子的程序员不是一个好木匠 以下代码全部放在了github上:链接地址 制定web框架流程我们要做的是一个轻量级，所以一些基础的功能还是需要的。这里制定一个简单的框架启动流程。 这里包含了几个简单的功能。 定制化的配置管理，根据环境变量自动加载 提供基础的工具库，可以自由加入需要的功能（加密，远程请求等） 一个简单使用的日志类，按照日期存储在项目根目录下的logs目录中 可以使用的路由基础方法，通过这个方法注入自定义的路由 一个简单实用的定时任务基础类，继承即可启动 可选择的app.js文件，可以对application对象注入一些自己的东西 定制目录规范通过一个合适的规范可以减少很多开发上的东西。 我们通过在固定的目录中做固定的事情将框架内的不同功能区分开来。1234567891011- config //配置文件 - default.js //默认配置 - development.js //开发环境配置 - production.js //生成环境配置- controller //控制器 - index.js //自定义路由地址- schedule //定时任务文件 - test.js //自定义定时任务- app.js //自定义启动文件- index.js //启动文件,引用duck即可- pm2.js //pm2的配置文件 这里只有根目录下的index.js是必须要的，主要是启动整个项目。config目录下主要是放置配置，这个目录一般情况下省不了。controller目录下放置路由的方法等，也是这个框架最常用的目录。其余的都是可选择的，不添加不影响功能。 基础框架从上面的几点可以看出来，框架基于配置的方式做到动态加载。所以启动的时候会扫一次目录，将有的功能加进去，没有的功能不做处理。 在lib目录下新建一个index.js文件，作为我们的整个框架的核心—-其实就是启动koa并将我们要实现的功能加上去：）123456789101112131415const Koa = require(\"koa\");const KoaBody = require(\"koa-body\");//附加一个根目录const rootPath = process.cwd();let app = new Koa();app.root = rootPath;//处理请求对象app.use(KoaBody(&#123; multipart: true, strict: false, jsonLimit: '10mb', formLimit: '10mb', textLimit: '10mb'&#125;)); 使用过koa的同学可能会非常的熟悉，其实这里就是一个简单的koa初始化过程。不同的地方是后面我们要附加的一些操作。 执行app.js我们给用户留一个可以操作顶层application对象的地方。入口就是这里：假如app.js文件存在就会将初始化中的app对象传进去处理一次再转出来。1234567//加载appcalitiontry &#123; let application = require(app.root + \"/app.js\"); application(app);&#125; catch (error) &#123; Logger.info(error.message);&#125; 执行自定义路由这里我们判断我们的controller目录下的文件。依次加载并将返回的路由对象加载到applicaiton上。这里利用的依然是一个动态加载的原理，将内容在启动阶段载入到内存中并执行它。1234567891011121314//添加路由if (fs.existsSync(app.root + \"/controller\")) &#123; let controller_list = fs.readdirSync(app.root + \"/controller\"); controller_list.forEach(item =&gt; &#123; try &#123; let controller_item = require(app.root + \"/controller/\" + item); if (controller_item) &#123; app.use(controller_item.routes()).use(controller_item.allowedMethods()); &#125; &#125; catch (error) &#123; Logger.info(error.message); &#125; &#125;);&#125; 监听端口正常情况下只需要监听一下端口即可。这里稍微处理了一次，假如用户使用命令退出进程或者进程异常退出，这里就会监听到这个操作。 这个地方可以自定义做一个触发事件，触发applicaiton的停止事件。比如数据库、redis等的连接断开操作。1234567891011121314const port = config(\"port\") || 3000;app.listen(port, function () &#123; Logger.info(\"app已启动:\" + port)&#125;);process.on('SIGINT', function (a) &#123; process.exit();&#125;);process.on('exit', (code) =&gt; &#123; Logger.info(\"app已停止:\" + code)&#125;);process.on('uncaughtException', (code) =&gt; &#123; Logger.info(\"app已停止:\" + code)&#125;);module.exports = app; 启动定时任务定时任务比较简单，只需要判断任务文件是否存在，然后执行即可。123456789101112//启动定时器if (fs.existsSync(app.root + \"/schedule\")) &#123; let schedule_list = fs.readdirSync(app.root + \"/schedule\"); schedule_list.forEach(item =&gt; &#123; try &#123; let schedule_item = require(app.root + \"/schedule/\" + item); if (schedule_item) new schedule_item()._run(); &#125; catch (error) &#123; Logger.info(error.message); &#125; &#125;);&#125; tips：上面的几个方式可以作为一个工具类中的方法存在。 基础支持类、方法上面的仅仅是一个基础的实现。假如你想现在就跑起来，不好意思，它们的依赖还没有实现呢。 基础配置类npm库里已经有一个非常强大的配置加载方式了。这个轮子我们先不造了。npm install --save config安装一下就好了。 基础日志类我们这里使用log4js库来完成日志的打印输出。这里稍微简单的配置一下内部的日志对象。 在lib/logger.js中添加我们自己的日志配置。12345678910111213141516171819202122232425262728293031323334353637383940414243const log4js = require('log4js');log4js.configure(&#123; appenders: &#123; stdout: &#123; type: \"stdout\" &#125;, error: &#123; type: 'dateFile', filename: './logs/error.log', &#125;, info: &#123; type: 'dateFile', filename: './logs/info.log' &#125; &#125;, categories: &#123; default: &#123; appenders: [\"info\", \"stdout\"], level: 'info' &#125;, err: &#123; appenders: ['error', \"stdout\"], level: 'error' &#125; &#125;, pm2: true, pm2InstanceVar: \"node-sso-wechat\"&#125;);const logger = log4js.getLogger('error');const logger2 = log4js.getLogger('info');module.exports = &#123; error() &#123; logger.error(...arguments); &#125;, info() &#123; logger2.info(...arguments); &#125;, warm() &#123; logger2.info(...arguments); &#125;&#125;; 这里我们简单的提供3中日志形式。 一直存在的输出到命令行 输出到info.log中info和warm方法 输出到error.js的error方法 这里将日志分开存主要是为了区分记录日志和错误信息这2中特殊情况。当然，也可以将这些配置放在config中，通过使用中去配置日志。 基础控制器方法我们给使用者提供一个简单的路由方法，这样就不需要用户去主动实现路由了。用户只需要关注具体的路由和实现即可。1234567const Router = require(\"koa-router\");module.exports = function (prefix) &#123; let opts = &#123;&#125;; if (prefix) opts.prefix = prefix; return new Router(opts);&#125; 可以看到我们使用的是koa-router这个库。用户调用的时候还可以传入prefix参数来配置路由的跟目录。 用户只需要使用返回的路由方法即可。 基础定时任务类由于定时任务并不需要参数web的请求返回等过程，所以在设计的时候只需要继承我们的基础类就能实现了。123456789101112131415const schedule = require('node-schedule');/** * 定时任务的基类 * 设置时间,可执行方法 * 默认执行run方法 */module.exports = class &#123; constructor() &#123; this.time = \"\"; &#125; start() &#123;&#125; _run() &#123; schedule.scheduleJob(this.time, this.start); &#125;&#125; 我们仅仅做了3件事就完成了定时任务。 初始化time参数,预留给用户做时间间隔配置 初始化start方法，预留给用户做具体的执行内容 _run方法就是我们自己的执行定时任务的方法，是不能给用户看到的。（当然还是可以重载了。。。） 使用我们的框架一个简单的demo已经放在github上了：链接地址 启动入口在根目录下添加index.js文件，引用我们的框架。1const Duck = require(\"node-duck\"); 自定义配置在根目录下新建config目录，新建default.js默认配置，production.js等环境配置。12345678910111213141516/** * 默认的配置文件 * 不同环境下还会加载不同的配置 */module.exports = &#123; name: \"duck.js\",//给自己用的配置 port: \"3001\",//启动的接口 //初始化的body对象参数 body: &#123; multipart: true, strict: false, jsonLimit: '10mb', formLimit: '10mb', textLimit: '10mb' &#125;&#125; 自定义控制器在根目录下新建controller目录，将我们的路由写在这个目录中。文件的名字对路由没有影响。1234567891011121314151617/** * 测试路由 */const Duck = require(\"node-duck\");//默认跟路由const Controller = new Duck.Controller(\"/\");//首页Controller.get(\"\", function (ctx) &#123; ctx.body = \"hi,duck!\";&#125;)//test目录Controller.get(\"test\", function (ctx) &#123; ctx.body = \"hi,duck!\";&#125;)//导出module.exports = Controller;` 从这里可以看到，我们的路由天生就配置比较简单。只需要配置一个prefix，剩下就简单多了。 自定义定时任务在根目录下新建schedule目录，里面的任何一个文件都必须集成导出的schedule对象，不然会报错的^_^123456789101112131415/** * 测试定时任务 */const Schedule = require(\"node-duck\").Schedule;class testSchedule extends Schedule &#123; constructor() &#123; super(); this.time = \"*/1 * * * * *\"; &#125; start() &#123; console.log(\"执行一次\", Date.now()); &#125;&#125;module.exports = testSchedule; 这里使用的时间配置是cron的格式:123456789* * * * * *┬ ┬ ┬ ┬ ┬ ┬│ │ │ │ │ ││ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)│ │ │ │ └───── month (1 - 12)│ │ │ └────────── day of month (1 - 31)│ │ └─────────────── hour (0 - 23)│ └──────────────────── minute (0 - 59)└───────────────────────── second (0 - 59, OPTIONAL) ex: 每秒执行一次&quot;*/1 * * * * *&quot; 每分钟的第一秒执行一次&quot;1 * * * * *&quot; 第2到5秒执行一次&quot;2-5 * * * * *&quot; time参数也可以传Date对象 扩展到这里的时候一个框架的基础架构以及demo展示都已经做完了。如果你还有自己更多的需求，也可以在这个的基础上扩展一下。 扩展utils，给自己添加更多的工具 扩展插件，添加数据库操作类等方法 扩展事件，将application的各种事件扩展出来 总结写这个框架最初的目的可能就是用不惯其他框架吧。好用的又封装太厉害了。封装不那么厉害的实现又非常的复杂。既然如此，干脆自己写一个好了。反正这玩意也不是一个多难的东西，再说了我还可以自己往上面安装各种奇怪的功能。 我将我自己的想法分享出来，希望有需要的能够从中有一些收获。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/categories/nodejs/"}],"tags":[{"name":"koa","slug":"koa","permalink":"http://www.guofangchao.com/tags/koa/"},{"name":"框架","slug":"框架","permalink":"http://www.guofangchao.com/tags/框架/"}],"keywords":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.guofangchao.com/categories/nodejs/"}]},{"title":"xcode历史版本下载","slug":"xcode历史版本下载","date":"2018-07-19T03:18:00.000Z","updated":"2018-07-19T03:19:36.160Z","comments":true,"path":"2018/07/19/xcode历史版本下载/","link":"","permalink":"http://www.guofangchao.com/2018/07/19/xcode历史版本下载/","excerpt":"","text":"xcode升级太高了? basesdk版本需要改动了? 打开网站:https://developer.apple.com/download/more/ 搜索xcode即可看见历史版本,也可以从里面解压出来各版本的sdk","categories":[{"name":"ios","slug":"ios","permalink":"http://www.guofangchao.com/categories/ios/"}],"tags":[{"name":"xcode","slug":"xcode","permalink":"http://www.guofangchao.com/tags/xcode/"},{"name":"ios","slug":"ios","permalink":"http://www.guofangchao.com/tags/ios/"}],"keywords":[{"name":"ios","slug":"ios","permalink":"http://www.guofangchao.com/categories/ios/"}]},{"title":"hping安装教程","slug":"hping安装教程","date":"2018-07-16T04:32:00.000Z","updated":"2018-07-16T04:33:18.204Z","comments":true,"path":"2018/07/16/hping安装教程/","link":"","permalink":"http://www.guofangchao.com/2018/07/16/hping安装教程/","excerpt":"","text":"准备 安装yum install epel-release yum -y install gcc libpcap-devel tcl-devel 下载 使用wget命令下载wget http://www.hping.org/hping3-20051105.tar.gz 解压tar -zxvf hping3-20051105.tar.gz 修改文件 vi bytesex.h 修改如下: 1234#if defined(__i386__) \\ || defined(__x86_64__)\\ || defined(__alpha__) \\ || (defined(__mips__) &amp;&amp; (defined(MIPSEL) || defined (__MIPSEL__))) 配置并安装./configure make ln -s /usr/include/pcap.h /usr/include/net/bpf.h make strip make install","categories":[{"name":"hping","slug":"hping","permalink":"http://www.guofangchao.com/categories/hping/"}],"tags":[{"name":"hping","slug":"hping","permalink":"http://www.guofangchao.com/tags/hping/"}],"keywords":[{"name":"hping","slug":"hping","permalink":"http://www.guofangchao.com/categories/hping/"}]},{"title":"git同时推送2个仓库","slug":"git同时推送2个仓库","date":"2018-07-16T03:39:00.000Z","updated":"2018-07-16T03:39:57.211Z","comments":true,"path":"2018/07/16/git同时推送2个仓库/","link":"","permalink":"http://www.guofangchao.com/2018/07/16/git同时推送2个仓库/","excerpt":"","text":"怎么样将一个本地git仓库推送到2个不同的远程仓库呢? 方法一 本地仓库添加到远程网站,正常来即可 使用命令git remote add github https://github.com/xxxx添加新的仓库地址 推送第一个仓库git push origin master:master 推送第二个仓库git push github master:master 方法二 添加第二个仓库git remote set-url --add oginin https://github.com/xxxx 推送修改到所有仓库git push origin master:master","categories":[{"name":"git","slug":"git","permalink":"http://www.guofangchao.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.guofangchao.com/tags/git/"}],"keywords":[{"name":"git","slug":"git","permalink":"http://www.guofangchao.com/categories/git/"}]},{"title":"react-native动态tab组件","slug":"react-native动态tab组件","date":"2018-07-06T07:31:00.000Z","updated":"2018-07-06T07:34:16.507Z","comments":true,"path":"2018/07/06/react-native动态tab组件/","link":"","permalink":"http://www.guofangchao.com/2018/07/06/react-native动态tab组件/","excerpt":"","text":"在APP中免不了要使用tab组件,有的是tab切换,也有的是tab分类切换. 这些组件分成下面两种. 第一种非常简单,同时大多数第三方组件都能达到效果.这里重点讲述第二种,我们要让第二种组件不仅能左右滑动,同时还能够在点击的时候自动滑动,将点击的位置滑动到正中间. 准备我们先来分析一波.一个滑动组件在APP上是一种什么状态. 这里可以看出,tab组件需要考虑到长度超过APP的屏幕,并且在超过之后能够滑动. 同时计算出当前位置需要滑动多少距离才能够将位置居中.需要滑动的位置=点击位置的左边距-APP屏幕/2+点击位置的宽度/2 这个公式也就是我们自动滑动的核心了. 开发使用ScrollView组件承载tab项,这样就可以非常简单的达到滑动的效果.同时添加horizontal、directionalLockEnabled、showsHorizontalScrollIndicator、snapToAlignment几个属性.12345678&lt;ScrollView ref=&#123;e =&gt; this.scroll = e&#125; horizontal directionalLockEnabled showsHorizontalScrollIndicator=&#123;false&#125; snapToAlignment=\"center\"&gt; &#123;this.props.data.map((item, index) =&gt; &#123;/*具体项*/&#125; )&#125;&lt;/ScrollView&gt; 使用TouchableOpacity包裹内容项,同时调用setLaout方法将每个项的宽高等属性记录下来,为我们后面计算当前位置做准备.1234567&lt;TouchableOpacity onPress=&#123;() =&gt; this.setIndex(index)&#125; onLayout=&#123;e =&gt; this.setLaout(e.nativeEvent.layout, index)&#125; key=&#123;item.id&#125; style=&#123;tabBarStyle.itemBtn&#125;&gt; &lt;Text style=&#123;[tabBarStyle.item, this.state.index === index ? tabBarStyle.active : null]&#125; &gt; &#123;item.name&#125;&lt;/Text&gt; &lt;View style=&#123;[tabBarStyle.line, this.state.index === index ? tabBarStyle.active2 : null]&#125;&gt; &lt;/View&gt;&lt;/TouchableOpacity&gt; 记录每个项渲染之后的位置,将这些值存在变量里,为后面计算做准备.1234567laout_list = []setLaout(layout, index) &#123; //存单个项的位置 this.laout_list[index] = layout; //计算所有项的总长度 this.scrollW += layout.width;&#125; 接下来就是点击自动变换位置的计算了.12345678910111213141516171819setIndex(index, bl = true) &#123; //先改变点击项的颜色 this.setState(&#123; index &#125;) //兼容错误 if (!this.scroll) return; //拿到当前项的位置数据 let layout = this.laout_list[index]; let rx = deviceWidth / 2; //公式 let sx = layout.x - rx + layout.width / 2; //如果还不需要移动,原地待着 if (sx &lt; 0) sx = 0; //移动位置 sx &lt; this.scrollW - deviceWidth &amp;&amp; this.scroll.scrollTo(&#123; x: sx, animated: bl &#125;); //结尾部分直接移动到底 sx &gt;= this.scrollW - deviceWidth &amp;&amp; this.scroll.scrollToEnd(&#123; animated: bl &#125;); //触发一些需要的外部事件 this.props.onChange &amp;&amp; this.props.onChange(index);&#125; 最后上一张结果图: gitee地址 github地址","categories":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/categories/react-native/"}],"tags":[{"name":"tab","slug":"tab","permalink":"http://www.guofangchao.com/tags/tab/"}],"keywords":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/categories/react-native/"}]},{"title":"服务器安装node等脚本","slug":"服务器安装node等脚本","date":"2018-06-13T09:57:00.000Z","updated":"2018-06-13T10:02:20.326Z","comments":true,"path":"2018/06/13/服务器安装node等脚本/","link":"","permalink":"http://www.guofangchao.com/2018/06/13/服务器安装node等脚本/","excerpt":"","text":"为了快速简单安装服务器环境,这里提供了一些脚本. 下面的软件都放在根目录下的soft文件夹中,使用之前需要提前创建好. 安装node12345678910#!/bin/bashcd /soft#更新系统g++yum install gcc gcc-c++#下载安装nodewget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gztar -zxvf node-v8.9.4.tar.gzcd node-v8.9.4 &amp;&amp; ./configuremake &amp;&amp; make install 安装mysql12345678#!/bin/bashcd /softwget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum install mysql-serverservice mysqld start 启动不成功需要手动找原因…. 手动设置远程连接等项 安装nginx12345678910#!/bin/bashcd /softyum install -y pcre pcre-develyum install -y zlib zlib-develyum install -y openssl openssl-develwget https://nginx.org/download/nginx-1.14.0.tar.gztar -zxvf nginx-1.14.0.tar.gz &amp;&amp; cd nginx-1.14.0./configuremake &amp;&amp; make install 默认安装在/usr/local/nginx/下 安装redis123456#!/bin/bashcd /softwget http://download.redis.io/releases/redis-4.0.6.tar.gztar -zxvf redis-4.0.6.tar.gz &amp;&amp;cd redis-4.0.6make &amp;&amp; make install redis需要手动设置后台运行/端口/密码等项","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/tags/服务器/"},{"name":"node","slug":"node","permalink":"http://www.guofangchao.com/tags/node/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}]},{"title":"react-native定时器","slug":"react-native定时器","date":"2018-05-12T04:11:00.000Z","updated":"2018-05-12T04:12:05.969Z","comments":true,"path":"2018/05/12/react-native定时器/","link":"","permalink":"http://www.guofangchao.com/2018/05/12/react-native定时器/","excerpt":"","text":"react-native中有时候需要定时执行一些后台任务,比如定时发送消息,定时统计数据等.这个时候就需要使用另外注册一个视图来做这些东西了,不然在同步任务中做这些任务,一旦任务比较耗时就会卡住后面的进程,甚至导致后面的进程不再渲染页面. 注册另外一个入口在合适的位置:页面启动或者某个需要的时候,注册并启动我们的另外一个视图.这个时候其实相当于启动了另外一个线程. 这里注意一下,这个视图里的东西千万不要直接刷新UI相关的数据,所有的内容都应该是内存相关的.123AppRegistry.registerRunnable('RunableTask', TaskRun)AppRegistry.runApplication('RunableTask', &#123;&#125;); 启动定时器调用init方法,启动我们自己的定时器刷新方法,这里我暂时定义1秒刷新一次,低于1秒间隔的定时器将不在执行.这里也是为了防止部分人设置低间隔的定时器导致APP崩溃. 这里使用react-native内部提供的requestAnimationFrame方法,每次刷新的时候先判断一次是否可以执行任务.1234567891011121314151617181920const tasks = new Map();let currDate = Date.now();/** * 初始化 */exports.init = function () &#123; global.requestAnimationFrame(run);&#125;/** * 执行,每秒执行一次 * 保证秒级工作正确 */function run() &#123; const now = Date.now(); if (now &gt; currDate + 1000) &#123; currDate = now; tasks.forEach(item =&gt; item.preStart(now)); &#125; global.requestAnimationFrame(run);&#125; 任务基类所有的任务都需要继承这个基类,定时器运行的时候也会通过基类内部的方法去判断是否需要执行方法.这里对外实现了一个timer是时间间隔,单位是毫秒,还有一个start方法用来给每个任务使用的. 通过每次执行preStart方法判断下次执行的时间到了没有来决定是否执行自定义方法.如果到了同时还要计算下一次的时间并存好.12345678910111213141516171819202122232425262728/** * 基础工作类 */class Jobs &#123; name = \"base\"; /** * 下次执行时间戳 */ nextTime = 0; /** * 重载:时间间隔 */ timer = 0; /** * 预启动 */ preStart(now) &#123; if (this.timer &lt; 1000) return; if (this.nextTime &gt; now) return; if (this.nextTime === 0) return this.nextTime = now + this.timer; this.nextTime += this.timer; this.start(now); &#125; /** * 重载:执行一次设置的方法 */ start() &#123; &#125;&#125; 实现并加入将设置好的任务加入全局的map示例中,运行的时候会从这个示例中取需要的任务出来.1234567891011121314151617/** * 添加一个工作 * @param &#123;*&#125; name 名称 * @param &#123;*&#125; time 时间 * @param &#123;*&#125; fn 执行函数 */const addJob = (name, Job) =&gt; tasks.set(name, new Job())exports.addJob = addJob;/** * 取消任务 * @param &#123;*&#125; name */const cancelJob = name =&gt; tasks.delete(name);exports.cancelJob = cancelJob; 测试任务这里模拟一次定时发送统计消息. 另外一个地方实现了将每次需要发送的消息存入内存中,这里只负责取出需要发送的消息. 设置3秒执行一次发送任务,如果数量比较少就修改定时任务的间隔,后面的任务延迟发送. 如果后台接收一次大量的数据,也可以将多次统计合并为一次统计,请求的个数会更少一些.12345678910111213141516171819/** * 定时触发统计方法 */class TrackJob extends Jobs &#123; timer = 3000; start() &#123; let list = TackList(); if (list.length &gt; 10) &#123; this.timer = 3000; &#125; else &#123; this.timer = 5000; &#125; list.forEach(item =&gt; &#123; request.trackData(item.url, item.data); log(\"埋点事件\", item.data); &#125;) &#125;&#125;addJob(\"Track\", TrackJob); 更多扩展在目前的基础上扩展时间间隔的设定方式,实现固定时间日期执行任务.这里可能需要app一直活着才能保证. 加入执行次数,执行超过一定的此时就不再执行.","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"},{"name":"定时器","slug":"定时器","permalink":"http://www.guofangchao.com/tags/定时器/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"git常用命令","slug":"git-command","date":"2018-04-01T08:48:00.000Z","updated":"2018-04-01T09:02:25.355Z","comments":true,"path":"2018/04/01/git-command/","link":"","permalink":"http://www.guofangchao.com/2018/04/01/git-command/","excerpt":"","text":"git常用命令小结: 123456789101112git version # → git版本git branch # → 查看本地所有的分支git branch -r # → 查看所有远程的分支git branch -a # → 查看所有远程分支和本地分支git branch -d &lt;branchname&gt; # → 删除本地branchname分 git branch -m brancholdname branchnewname # → 重命名分支 git branch &lt;branchname&gt; # → 创建branchname分支git checkout &lt;branchname&gt; # → 切换分支到branchnamegit checkout -b &lt;branchname&gt; # → 等同于执行上两步，即创建新的分支并切换到该分支git checkout -- xx/xx # → 回滚单个文件git pull origin master:master # → 将远程origin主机的master分支合并到当前master分支,冒号后面的部分表示当前本地所在的分支git push origin -d &lt;branchname&gt; # → 删除远程branchname分支 123456git fetch --p # → 更新分支git status # → 查看仓库状态git add xx # → 把xx文件添加到暂存区去git commit -m &apos; &apos; # → 提交文件 -m 后面的是注释git commit -am(-a -m) # → 提交所有的修改，等同于上两步git commit --amend # → 将暂存区和当前commit合并创建一个新commit去替换当前commit 123git stash # → 把当前的工作隐藏起来 等以后恢复现场后继续工作git stash pop # → 恢复工作现场（恢复隐藏的文件，同时删除stash列表中对应的内容）git fetch --all # → 将远程主机的更新全部取回本地 12345git merge origin/master # → 在本地（当前）分支上合并远程分支git merge --abort # → 终止本次merge，并回到merge前的状态（👍）git pull origin master # → 从远程获取最新版本并merge到本地等同于git fetch origin master + git merge origin/master（前者更安全一些）git push origin master # → 将本地master分支推送到远程origin主机的master分支 123456git log xx # → 查看xx文件的commit记录git log -p xx # → 查看xx文件每次提交的diffgit log --pretty=oneline xx # → 查看xx文件提交的历史记录（只显示哈希值和提交说明）git log --pretty=raw # → 查看commit之间的父子关系（root commit是没有父提交的）git log --graph # → 查看当前分支commit生成的树状图git diff HEAD HEAD^1 -- xx # → 查看xx文件不同版本之间的差异 1git diff HEAD~1 # → 显示父节点的提交 1git reset --hard origin/master # → 将本地master与远程master同步 git revert会增加一条新的commit，它的内容与指定commit的修改是相反的，两次相互抵消从而达到撤销的效果，并且在commit历史中，会存在两条提交，一条原始commit，一条它的反转commit，而git rebase –onto是直接将commit从历史记录中直接删除。 1git tag -l version1.* # → 只会列出1.几的版本","categories":[{"name":"运维","slug":"运维","permalink":"http://www.guofangchao.com/categories/运维/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.guofangchao.com/tags/git/"}],"keywords":[{"name":"运维","slug":"运维","permalink":"http://www.guofangchao.com/categories/运维/"}]},{"title":"nginx自动跳转https","slug":"nginx自动跳转https","date":"2018-03-30T10:14:00.000Z","updated":"2018-03-30T10:15:03.180Z","comments":true,"path":"2018/03/30/nginx自动跳转https/","link":"","permalink":"http://www.guofangchao.com/2018/03/30/nginx自动跳转https/","excerpt":"","text":"一、按照如下格式修改nginx.conf 配置文件，80端口会自动转给443端口，这样就强制使用SSL证书加密了。访问http的时候会自动跳转到https上面。12345678910111213server &#123;listen 80;server_name www.域名.com;rewrite ^(.*) https://$server_name$1 permanent;&#125;server &#123;listen 443;server_name www.域名.com;root /home/www;ssl on;ssl_certificate /etc/nginx/certs/server.crt;ssl_certificate_key /etc/nginx/certs/server.key;&#125; 二、修改配置文件后，重启nginx。","categories":[{"name":"运维","slug":"运维","permalink":"http://www.guofangchao.com/categories/运维/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.guofangchao.com/tags/nginx/"}],"keywords":[{"name":"运维","slug":"运维","permalink":"http://www.guofangchao.com/categories/运维/"}]},{"title":"使用js开发数据库","slug":"使用js开发数据库","date":"2018-03-30T03:40:00.000Z","updated":"2018-03-30T10:54:47.215Z","comments":true,"path":"2018/03/30/使用js开发数据库/","link":"","permalink":"http://www.guofangchao.com/2018/03/30/使用js开发数据库/","excerpt":"","text":"前端很多时候还是需要保存一些数据的，这里的保存指的是长久的保存。以前的思想是把数据保存在cookie中，或者将key保存在cookie中，将其他数据保存在服务器上。 这几个场景用处很多，也非常的成熟好用。但是我还是想要一种能够长久的保存在本地的数据，类似数据库或者类似web sql。 新一代浏览器基本都支持了本地数据库，需要用的时候直接使用就好了。实在不行还可以使用Storage将就一下。 假如我需要的是一个数据库那种功能并且没有兼容的存储方式呢？加入我还要加密存储这些东西在本地呢？加入我要存的东西非常多呢？ 目前我在使用ReactNative的时候确实遇到了这种情况。我需要将非常多的数据存在本地。有人说了，直接使用sqlite不就好了么？ 好啊，完全可以啊。我这里仅仅是本着前端的态度去开发而已。假如有的同学不需要sqlite呢，只需要一个简单的，能够存储一些大量数据的方式呢？ 使用场景可能有很多，实现的底层也可以随便替换，甚至实现方式都可以随便写写。这里我本着前端创造世界的态度来做一个非正式的、前端好使的数据存储库。 底层存储这里的使用场景是ReactNative，所以我使用的是RN的AsyncStorage。 将所有要保存的数据转成对象，并转化为字符串。这里的核心思想就是序列化。将所有数据当成字符串来存。12345678import &#123; AsyncStorage &#125; from 'react-native';exports.setItem = async (key, value) =&gt; &#123; let item = JSON.stringify(&#123; v: value &#125;); return await AsyncStorage.setItem(key, item);&#125; 当读取的时候也需要做一次转化，将字符串转成当初存入的数据。1234567exports.getItem = async (key) =&gt; &#123; let item = await AsyncStorage.getItem(key); if (!item) &#123; return null; &#125; return JSON.parse(item).v || null;&#125; 需要特殊处理的是列表的获取。RN有一个根据多个key返回多条数据的api。它返回的是一个数组对象，数组序号0是数据存储的key值，序号1才是数据存储的具体字符串。12345exports.getlist = async (keys) =&gt; &#123; let list = await AsyncStorage.multiGet(keys); list = list.map(item =&gt; JSON.parse(item[1]).v || null); return list;&#125; 其他用到的几个方法也顺便拿出来吧。这里多嵌套一层，跟上面的保持队形。12345exports.removeItem = async (key) =&gt; await AsyncStorage.removeItem(key);exports.removeItems = async (keys) =&gt; await AsyncStorage.multiRemove(keys);exports.allKeys = async () =&gt; await AsyncStorage.getAllKeys(); 底层优化上面只是简单的实现，如果没有特殊需求也就差不多了。但是，想要更进一步的可以考虑开始优化了。 比如，优化json转化的速度。我们使用JSON对象的方法去转化的时候其实还有一个判断数值类型的过程。如果我们把数据的类型提前定义好。再转化的时候就不需要再判断了。 可以定义一个model对象，将这个表需要的字段预先定义好。可以查看一下Sequelize的定义方式。按照关系行数据库的方式来搞这个事情就很简单了。123456789101112131415161718192021222324252627282930313233//用户对象const users = db.define('t_users', &#123; id: &#123; type: Sequelize.INTEGER, primaryKey: true, &#125;, //用户名 username: &#123; type: Sequelize.STRING &#125;, //密码 pwd: &#123; type: Sequelize.STRING &#125;, //状态 status: &#123; type: Sequelize.INTEGER &#125;, //昵称 nickname: &#123; type: Sequelize.STRING &#125;, //token token: &#123; type: Sequelize.STRING &#125;, create_time: &#123; type: Sequelize.TIME &#125;&#125;, &#123; freezeTableName: true, timestamps: false,&#125;); 实现存储我们这里参考一下关系型数据库的实现。 首先需要分表和分库。这样在存入数据的时候可以更少的关注这方面的信息，将主要精力放在数据操作上。12345678constructor(tableName = \"table\", db = \"db\") &#123; //检查库,表是否存在 //初始化索引表 this.db = db; this.tableName = tableName; this.tableKey = db + \"_\" + tableName; this.init(); &#125; 将它们分开存储在当前对象内部，在创建对象的时候就可以根据不同的库、表创建不同的操作方法。这里使用的是class，每个表都对应一个单独的对象。 由于我们使用的是RN提供的存储方法，所以这里的添加和更新其实是一个方法。在添加的时候会根据当前时间戳创建一个唯一id，使用这个id作为key存储在数据库中。所以在使用的时候不需要再单独存入id，不过如果你觉得这个id跟你需要的有差别也可以自己定义一个id来作为key值存储。1234567//添加和更新 async add(data = &#123;&#125;) &#123; if (data.constructor !== Object) return; if (!data._id)data._id = uuid(); await setItem(this.tableKey + \"_\" + data._id, data); return data; &#125; 在获取的时候单独提供了一个根据id获取的方式。这里考虑的是通过id获取非常的简单方便，对于某些数据完全可以快速读取，没必要一行一行的去查询。12345678/** * 通过id查询 * @param &#123;*&#125; id */async getById(id) &#123; if (!id) return &#123;&#125;; return await getItem(this.tableKey + \"_\" + id);&#125; 相对于根据id查询来说，模糊查询确实很慢，如果不是真实需要，还是不要使用这种模糊查询的好。这里提供了一个自定义查询的方法，可以根据返回的对象判断是否需要这行数据。同时也可以添加top参数来限制返回的数量。使用这个参数也可以在数据很多的时候提高性能。1234567891011121314/** * 通过过滤方法查询 * @param &#123;*&#125; fn */async get(fn, top = 0) &#123; let keys = await allKeys(); if (keys.length == 0) return []; if (top &gt; 0 &amp;&amp; keys.length &gt; top) keys.length = top; const listkey = keys.filter(item =&gt; item.indexOf(this.tableKey + \"_\") === 0); if (listkey.length == 0) return []; let list = await getlist(listkey); list = list.filter(item =&gt; fn(item)); return list;&#125; 最后把删除和清空的方法加上，这样一个简单的删除库就完成了。1234567891011121314151617 /** * 删除 * @param &#123;*&#125; id */async delete(id) &#123; if (!id) return &#123;&#125;; await removeItem(this.tableKey + \"_\" + id);&#125;/** * 清空表 */async clear() &#123; let keys = await allKeys(); const listkey = keys.filter(item =&gt; item.indexOf(this.tableKey + \"_\") === 0); if (listkey.length == 0) return; removeItems(listkey);&#125; 使用的时候只需要创建对象，然后在需要的地方调用即可。使用起来简单又方便，再加上优化之后的情况甚至可以当成客户端的redis来使用。1234567891011121314151617//初始化数据库let db=new JSDB(); //添加一个自定义数据db.add(&#123;name:\"test\",key:\"abc\"&#125;); //根据id获取数据db.getById(\"1223467890\"); //根据条件查询数据db.get(d=&gt;d.name===\"test\"); //删除对应的数据db.delete(\"1223467890\"); //情况所有数据db.clear() 优化创建首先要优化的就是对象的创建。每个对象创建其实都是一个很大的消耗，如果能把这个消耗降低岂不是美滋滋！ 这里我们借鉴数据库池的概念，实现一个对象池的方法。在对象创建之后并没有直接返回，要在经过池的操作。 将对象放入池内，并在页面销毁的时候重置为一个空对象。下次请求创建的时候就不必再创建新的了。直接赋值表、库的名称就可以使用了。内存毫无变化，并且有点想笑。 优化查询每次查询都需要去读Stroage还是很麻烦的，尤其这个操作是异步操作，是需要发消息到native端的。 我们可以将上次读取的数据先存在一个变量中，如果下次还需要使用这行数据，就完全不需要再去读取了。这样就可以很简单的提供读取速度。12345678910111213141516171819//按照使用情况保存数据到缓存async getById(id) &#123; if (!id) return &#123;&#125;; id = this.tableKey + \"_\" + id; //如果有缓存 if (this.cacheList.has(id)) &#123; let tmp = this.cacheList.get(id); //如果过量了 if (this.cacheKeyList.length &gt; 20) &#123; this.cacheKeyList.push(id); let k = this.cacheKeyList.shift(); this.cacheList.delete(k); &#125; return tmp; &#125; this.cacheKeyList.push(id); this.cacheList.set(tmp); return await getItem(id);&#125; 这个方式还可以继续优化。将变量中保存的数据限制数量，防止数量太多超过了APP的限制。还可以将这个保存的时限做一个逻辑判断，常使用的数据放在里面，不常用的就找机会删除。 使用这种方式也可以优化变量中数据的有效性，减少变量占用内存的大小。不过实现的方式尽量不要使用定时器的形式，可以考虑使用触发式的。在条件满足的时候再触发删除动作。 优化写入上面提到读取的时候需要放入变量来提高读取速度。我们顺便想到写入的速度是不是也可以提高啊？ 我们将要存的数据放在临时的变量里，如果查过我们设置的时间或者数据长度查过我们设置的数量就触发一次保存操作。 这里要注意，保存数据的变量和存入时候使用的变量要交替使用，防止出现丢数据的情况。 比如：存的时候使用变量1，在写到数据库之前，将要存的对象改成变量2，然后读取变量1的数据并存入数据库中。这就是双缓存写入。 当然还是要判断一次APP的退出事件的，如果APP退出了，请一定要把变量中的内容保存一次，不然你的心血就全丢了。 注意写入要和上面的读取结合起来，不然就会发现写入的数据会有一个很大的延迟。123456789101112131415161718192021 //添加和更新async add(data = &#123;&#125;) &#123; if (data.constructor !== Object) return; data._id = uuid(); const key = this.tableKey + \"_\" + data._id this.writeList.set(key, data); this.write(); //this.read(); return data;&#125;//写入的实现,now立马写入write(now = false) &#123; if (now || this.writeList.size &gt; 20) &#123; let tmp = this.writeList; this.writeList = this.backWriteList; this.backWriteList = tmp; this.backWriteList.forEach((v, k) =&gt; &#123; setItem(k, v); &#125;) &#125;&#125; 好了，一个简单的数据库就完成了。想要使用的可以先在npm上搜索react-native-jsdb这个库。我已经将第一部分实现放在了npm上，后续的优化也会满满的开源出来的。 npm仓库地址","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"},{"name":"database","slug":"database","permalink":"http://www.guofangchao.com/tags/database/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"RN的缓存策略探索","slug":"app缓存策略探索","date":"2018-03-28T11:26:00.000Z","updated":"2018-03-28T11:33:17.961Z","comments":true,"path":"2018/03/28/app缓存策略探索/","link":"","permalink":"http://www.guofangchao.com/2018/03/28/app缓存策略探索/","excerpt":"","text":"最近使用RN做APP，时间长了总是觉得接口请求是在太频繁。遂想到，不如给接口做个缓存吧。 这里申明一下，我是从前端开始接触RN，然后到APP的。对于APP原本是使用什么样的缓存策略还真的没有去深入了解。这里本着将前端的思想带入APP的原则来探讨一下使用RN来做接口部分的缓存策略。 服务器接口缓存最开始的时候只是希望减轻服务器压力，减少不必要的计算过程。比如用户数据没变化的时候就不需要去计算用户的各种数据，直接使用缓存就好了。 这里将服务器的接口返回数据根据策略缓存在redis中，然后根据上次更新之后的时间戳来判断是否需要重新计算缓存中的数据。 有人可能开始质疑。这个数据本来就是放在缓存中的，尤其是用户数据，根本不可能实时去计算。这里稍微说一下这个方案的背景。 后端计算和更新的数据其实已经存在在redis中了，但是在业务比较复杂的情况下，有些数据其实还是需要去获取的。这里的缓存其实类似于一个http的缓存。它的本意只是为了缓存最终接口需要返回的数据。这里使用redis去存储本来只是一个过度方案。打算使用这个方案的同学可以去关注一下varnish，这个才是真正的http缓存。 使用APP缓存这个阶段其实才开始算真正的缓存。 APP端会把第一次从接口获取到的数据缓存在本地，并且返回接口的时间戳。当下一次请求的时候直接带上这个时间戳去请求。 服务器根据这个时间戳去判断接口是否有更新，或者也可以定一个固定的时间。在这个时间段内默认缓存不过期。服务器返回304这样的http code。APP根据这个code判断缓存未过期，直接使用本地缓存的接口信息。 这样有很多好处： 减少不必要的计算 关键时刻可以立马更新接口数据，甚至可以灰度更新某些地区的、ip的用户缓存 不返回大块的数据，加速了请求速度 如果遇到网络错误，可以直接使用缓存的信息。相当于离线APP 使用接口hash将接口返回的数据看过一段固定的字符串，每次都计算字符串的hash值。这样可以更加方便的判断接口返回数据是否需要更新。 在上一步的策略中，接口返回的数据根据时间戳其实是根据接口更新的时间来定的。加入接口更新了，但是数据并没有变化，这个时候就会产生一次额外的请求。用户多的时候也是一个非常流量的操作。 如果使用hash来判断接口是否需要更新，这样就可以直接免去了这种无用的更新操作。相比上一个版本更加的高效。不过服务端计算hash让整个项目的复杂度又高了不少。这个就要考虑这样做是否值得了。 如果原有的更新策略已经完成了。比如刷新redis的策略已经做完了。其实这个时候将redis中的数据做一次hash也不费事，这样也可以非常简单的将缓存策略升级。 使用APP过期策略这里再提出一个更加激进的策略。假如某些接口的更新速度非常慢，我叫这些接口静态接口。那么每次的304请求是不是非常多余？ 这里就将这种接口设置一个固定的过期时间。在这个过期时间内，每次请求接口都会使用本地缓存，直到过期之后采取请求远程接口。 有人提出说，这种策略在后端有更新的时候不能即时的更新数据。别着急，更新数据也可以非常及时。 在所有接口之后，在新增一个本地缓存策略接口。将上述几个接口的状态放在这里。每次都请求后端接口，让后端来判断这个接口是否需要更新。比如：请求hash，如果需要更新就返回最新状态，不需要更新就不返回数据。 其他的静态接口在请求之前都会使用这个状态比较一次。如果需要更新就发请求，不需要更新就使用本地缓存。这样就完美的解决了接口缓存的问题。从一个每次都要请求接口变成了部分接口快速返回304，部分接口不请求。 RN开发的APP可以非常快的发布版本（热更新），同时开发的时候由于js的原因也会非常的灵活。这个时候使用上面的缓存策略会更加简单方便。 通过上述几个策略就可以减少非常多的无用请求。比如后端的热配置信息，很多时候其实没有改动，完全可以使用静态接口的策略。 进入APP的时候也可以先使用旧的数据展示列表，然后伺机更新。当然详情也和过期下架的产品还是要即时的排除掉的。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"},{"name":"app","slug":"app","permalink":"http://www.guofangchao.com/tags/app/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"修改centos的欢迎界面","slug":"修改centos的欢迎界面","date":"2018-03-28T04:34:00.000Z","updated":"2018-03-28T04:34:37.488Z","comments":true,"path":"2018/03/28/修改centos的欢迎界面/","link":"","permalink":"http://www.guofangchao.com/2018/03/28/修改centos的欢迎界面/","excerpt":"","text":"123456789101112131415161718192021 * , _/^\\_ &lt; &gt;* /.-.\\ * * `/&amp;\\` * ,@.*;@, /_o.I %_\\ * * (`&apos;--:o(_@; /`;--.,__ `&apos;) * ;@`o % O,*`&apos;`&amp;\\ * (`&apos;--)_@ ;o %&apos;()\\ * /`;--._`&apos;&apos;--._O&apos;@; /&amp;*,()~o`;-.,_ `&quot;&quot;`)* /`,@ ;+&amp; () o*`;-&apos;;\\ (`&quot;&quot;--.,_0o*`;-&apos; &amp;()\\ /-.,_ ``&apos;&apos;--....-&apos;`) * * /@%;o`:;&apos;--,.__ __.&apos;\\ ;*,&amp;(); @ % &amp;^;~`&quot;`o;@(); * /(郭方超的 技术博客 空间\\ `&quot;=&quot;==&quot;&quot;==,,,.,=&quot;==&quot;===&quot;` __.----.---&apos;&apos;#####---...___...-----._ 如果你的服务器已登录就提示上面的这一段信息是不是很漂亮啊。如果你还不知道怎么设置就来看看下面的教程吧。 这段信息其实存储在服务器的etc目录下:/etc/motd。只要使用vim打开即可看到默认的一段信息。如果你的服务器是阿里云，默认的是你的服务器名字等简单的一段信息。登录的时候也非常没有趣味。 提示:可以使用一点颜色,让显示更有趣 也可以修改脚本,当用户登录的时候显示用户的信息。比如修改root下的脚本。vi /root/.bash_profile 这里就非常随意了，直接在最后面加echo输出即可。也可以使用变量输出诸如磁盘用量等信息。12echo -e &quot;\\e[1;34mThis is a blue text.\\e[0m&quot;echo df","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/tags/服务器/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}]},{"title":"前端如何拥有自己的服务器","slug":"前端如何拥有自己的服务器","date":"2018-03-28T04:00:00.000Z","updated":"2018-03-28T04:00:39.414Z","comments":true,"path":"2018/03/28/前端如何拥有自己的服务器/","link":"","permalink":"http://www.guofangchao.com/2018/03/28/前端如何拥有自己的服务器/","excerpt":"","text":"前言作为前端开发者一直都在关注浏览器的行为、表现。但是时间长了免不了要接触到后端的知识、服务器的知识。尤其是在前端技术爆发式发展的当下，前端慢慢的渗透到了更多的领域。比如，使用 express/koa 创建 http 服务，使用React-Native开发Android和IOS通用的APP，甚至使用node开发系统、嵌入式程序等。这个时候，我的内心开始蠢蠢欲动，我们能做的不仅仅是网页。 首先，我需要一台服务器。上面有我需要的各种有用的库，每当我有新的想法需要实践的时候我就拿出来搞一波，简单快速成型。我不必依赖后端同事，我也不想占用公司的资源，哪怕是创业或者我想开发自己的软件/库，我也不会有任何的问题。 来看这篇文章的同学想必都是需要这么一个服务器的，刚开始学习的时候，我不建议大家使用复杂的环境，这个会带来大量的调试成本，同时页会遇到很多不可预知的错误，这里我推荐使用云服务器（其他同学可以使用虚拟机，效果也可以），大家根据我的教程就可以轻松愉快的创建一个完整的服务器。 准备我需要以下这些来完成后面的工作。 1.一个域名：下面将讲解使用 Nginx 管理自己的各个服务，一个域名是必不可少的，如果你经常使用域名那就更好了。2.一台Linux服务器：这篇文章主要在 Linux 上做各种开发，Window 的没有什么难度，网上也有很多教程，这里就不介绍了。作为一个服务器怎么能用 Windows 呢?3.如果使用 Windows 电脑做个人电脑，我这里推荐大家安装一个 xshell 做为连接服务器的工具，这个软件非常好用，其他诸如 Mac/Ubuntu 的请使用电脑自带的终端。 创建自己的服务器使用云服务器我这里推荐使用云服务器，相比使用自己的服务器，云服务器有很多方便的地方，而且云服务器提供一个一周的试用版，用起来非常的方便。 创建一个轻量级的服务器阿里云可以购买一台可使用一周的服务器，这个服务器正好用来做这次开发（已有的请跳过）。 登录阿里云，进入购买 CES 的地方，链接地址请单击这里。 依次选择： 计费方式：包年包月。 地域：华北5（当前华北5有优惠）。 实例：请寻找1vCPU、1G内存的实例（我最终选择了突发性能实例 t5）。 镜像：选择CentOS 7.4 （现在后端普遍使用6+的版本，7相比6有了很大改进，前端选择7可以减少很多麻烦），勾选安全加固。 云盘：40G高效云盘。 公网带宽：勾选自动分配公网 IP，选择1M带宽。 安全组：选择默认安全组，并勾选http80端口和http443端口。 购买周期：选择1周。 最终结果：我们的服务器主要做网站类的开发，所以有针对性需求的用户可以考虑将内存增大，其他在需要的时候采取考虑。 使用虚拟机如果你打算使用虚拟机，这可能会增加你的开发难度，而且效果可能和在自己的电脑上直接开发没有太大区别，这里虽然不推荐，我还是稍微讲一下吧。下面演示一下使用VM12虚拟机以及Ubuntu系统来安装一个虚拟机，安装是在windows系统下进行，这也是大多数安装虚拟机的场景了。 下载要安装的系统Ubuntu，下载地址。 下载安装VMware，这个请自行百度，产品激活密钥等也可以通过百度解决。 打开VM并创建一个虚拟机： 选择自定义： 单击下一步按钮直到这一步： 请输入一个已经存在的位置： 默认的配置已经足够了，请注意电脑的剩余空间： 下一步并选择硬件： 选择第一步下载的镜像： 下一步直到完成。此时已经可以启动虚拟机了： 选择中文简体，这也是选择ubuntu的一个重要原因： 这一步比较重要的是取消掉下载更新，不然你得到一个下载中的状态，国内网络不太好，下载会比较吃力，这里就直接取消了： 第一次安装的时候直接清除就好了： 点击下一步依据个人喜好选择键盘布局/位置等，然后输入自己的用户名密码就开始正式的安装了： 到这里就安装好了：以上基本就可以安装好一台虚拟机了，实际的使用上和一台真实的机器并没有太大的区别，剩下的请各位自行探索。本文主要介绍的还是在云服务器上的开发。 安装自己的开发环境到这里就可以开始第一次在Linux上开发了，是不是很兴奋? 连接到服务器Linux服务器不像window那样有一个可视化的界面，window/mac连接的时候也不像远程桌面那样方便。这里连接服务器需要使用命令才行。 window连接服务器好消息是window下有一款神器:xshell，命令可以很方便的输入到一台服务器或者多台服务器上，用户密码也可以很方便的保存在本地，多个服务器还可以分组，你要做的就是专注于眼前的服务器开发。 这个软件多用于常年跟服务器打交道的同学那里。如果你没有，可以找他们要一个。 首先你需要安转一个xshell，下载需要填一些信息，最方便的就是问同事要一个，安装非常简单，要注意的是安装的时候需要选择个人开发使用，不然安装好之后发现需要交钱才能用就坑了。 安装好之后你就可以把自己的服务器ip、用户名、密码都填好了，以后只需要鼠标一点就进入了自己的服务器了。 需要注意的是，选择一下默认的字符，不然你的中文会变成乱码。 连接之后的界面是下面这样。 首先有一个进入服务器的提示，然后下面就是熟悉的命令行了，不同的是前面那段显示的规则是用户名@机器名。 Mac连接服务器Mac连接服务器可以使用自带的终端应用，也可以自己下载一个iTerm2，这里我推荐使用iTerm2，可以方便的使用不同的主题，添加各种有用的插件。 打开iTerm2，输入连接命令ssh 用户名@ip地址然后回车，你会看到提示你输入密码，这个时候输入你在购买服务器的时候设置的密码就好了。 只要密码正确，你就可以进入服务器了，依旧是熟悉的命令行模式。 你会在第一时间看到服务器反馈的上次登录信息，欢迎信息，然后是命令行的提示，前面的显示规则是用户名@机器名，这里的欢迎信息是我自己改的，有兴趣的同学可以自行探索（比如显示一个美女）。 几个常用的命令要想使用Linux系统服务器做开发，不懂几个常用命令怎么行？ ssh 用户名@ip，连接服务器的命令。 cd 绝对路径/相对路径，跳转到路径对应的目录下。 rm 文件名，删除文件。 rm -rf 目录路径，删除目录以及目录下的所有文件，谨慎操作! ls [-a]，查看当前目录下的文件和目录，加-a参数可以查看所有文件，包括隐藏文件（.开头的文件是隐藏文件，默认是看不见的）。 ll，查看当前目录下的文件详情，可以文件的权限，遇到没有权限执行的情况下可以使用这个命令查看。 pwd，查看当前路径的完整路径，不知道自己在哪儿的时候可以使用这个命令查看。 which 名字，在几个默认位置查找改名字，比如查找pm2安装在哪个地方了。 mkdir 目录名，创建一个空目录。 cat 相对/绝对文件路径，查看文件的内容，多为查看日志或者其他文本文件。 cp 文件路径 目标路径，复制一个文件到另外一个地方。 mv 文件路径 目标路径，移动一个文件到另外一个地方，也可以重命名。 ps -aux，显示当前进程，有时候需要用这个查看进程是否存活。 kill -9 进程id，结束进程，进程id就是上一条命令查到的pid。 tar -zxvf 文件，解压缩文件。 tar -zcvf 压缩后的文件 要压缩的文件/目录，压缩文件。 vi 文件路径，使用vim进入文件的编辑模式。 vi退出文件，按下esc键保证退出编辑模式，输入:q或者:q!强制退出。 vi编辑，按下i左下角会提示进入编辑模式，然后就是正常的输入文字，再按esc键退出编辑模式。 vi保存编辑结果，按下esc键保证退出编辑模式，输入:x保存并退出。 后面还有很多内容,包括: 如何购买一个阿里云服务器？服务器的选择、系统的选择、怎么挑选最合算？ 安装 Node、PM 2 并备份系统； 安装 MySQL、Redis、Nginx 并配置安全规则，防止服务器被扫描； 部署一个简单的 Express 服务； 简单的数据库连接、PM2 守护、Nginx 端口映射； 写自己的脚本、真正的做到一键部署、一键重启。 文章地址:点击跳转","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/tags/服务器/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"使用Varnish加速http","slug":"使用Varnish加速http","date":"2018-03-28T03:17:00.000Z","updated":"2018-03-28T03:17:53.633Z","comments":true,"path":"2018/03/28/使用Varnish加速http/","link":"","permalink":"http://www.guofangchao.com/2018/03/28/使用Varnish加速http/","excerpt":"","text":"varnish是一个http缓存方案。它使用纯内存作为缓存对象，所以在速度上非常有优势。如果打算加速web服务器的图片等静态资源或者cookie、某些变动不频繁的接口等资源都可以使用Varnish来做加速。 普通情况下也可以使用nginx来做缓存，但是ngxin毕竟主业是反代。如果遇到大规模使用的情况下还是换个专业的吧。 可以使用安装包安装,这里给出一个在Red Hat和centos上安装的地址:https://packagecloud.io/varnishcache/varnish60/install#manual-rpm 也可以使用源代码安装git clone https://github.com/varnishcache/varnish-cache 还需要安装下面的几个依赖 autoconf automake jemalloc-devel libedit-devel libtool ncurses-devel pcre-devel pkgconfig python-docutils python-sphinx 之后编译源代码1234cd varnish-cachesh autogen.shsh configuremake 也可以在编译的时候做一次检测1make check 最后只需要安装到系统中就可以了1sudo make install 之后可以启动varnish服务了1service varnish start","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}],"tags":[{"name":"varnish","slug":"varnish","permalink":"http://www.guofangchao.com/tags/varnish/"}],"keywords":[{"name":"服务器","slug":"服务器","permalink":"http://www.guofangchao.com/categories/服务器/"}]},{"title":"React Native 实战：构建电商 App","slug":"React-Native-实战：构建电商-App","date":"2018-03-28T02:23:00.000Z","updated":"2018-03-28T02:24:44.903Z","comments":true,"path":"2018/03/28/React-Native-实战：构建电商-App/","link":"","permalink":"http://www.guofangchao.com/2018/03/28/React-Native-实战：构建电商-App/","excerpt":"","text":"课程介绍React Native 充分利用了 Facebook 的现有轮子，是一个很优秀的集成作品，使用 RN 即可做到无需编译就能远程热更新 App，再加上友好的开发方式、快到爆炸的开发效率、RN 已经完爆了其他的 App 开发方式，即使是一个初入前端的开发者也能迅速开发一套 iOS、Android 双平台的 App。 文章中将分三个部分讲解 RN 的开发。通过开发一个比较完整的电商 App 来逐步带领读者走入 React Native 的世界。读者可以从中汲取到完整的项目经验，从菜鸟到精通也只需要学完这个达人课即可。 第一部分主要讲述封装基本组件、简单页面的开发：这个阶段主要解决开发中遇到的兼容问题，在文中会提出解决方案、避免无用的代码。 第二个部分将讲述复杂的业务逻辑：让第一次做开发的读者也能非常快速的适应业务形态，让开发有底气、不再受制于产品的约束。 第三部分将讲述性能的极致优化、热更新、统计等这些 App 必须的东西，让开发的 App 能够真正的比得上原生 App 和混合 App。 该课程已经上线,需要订阅的同学可以点击查看课程地址","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"使用ReactNative的心得","slug":"ReactNative中遇到的问题","date":"2018-03-27T11:09:00.000Z","updated":"2018-03-27T11:15:25.477Z","comments":true,"path":"2018/03/27/ReactNative中遇到的问题/","link":"","permalink":"http://www.guofangchao.com/2018/03/27/ReactNative中遇到的问题/","excerpt":"","text":"适配iPhoneXRN版本0.52之后提供了适配iPhoneX的组件SafeView。不过单独这个是不行的，还需要在ios中修改配置，把视图从一个短小的区域拉伸到全屏的大小。 这里通过修改设置打开默认的安全区域。 由于之前使用的还是旧版的RN，这里我为了兼容旧的版本做了一个js的判断。通过判断高度是否符合812来判断是否iPhoneX。同时有一个小小的缓存，不需要每次都重复判断。这里的1.0.6是开始使用新能力的版本号。 添加额外的线程有些功能其实没必要跑在UI线程上。这些东西如果放在组件里反而不是那么融洽。甚至有时候会对正常的逻辑产生影响。 可以使用下面的方式注册一下额外的层。这个不显示UI，但是可以用来更新一些缓存，返回远程数据等。123AppRegistry.registerRunnable(&apos;RunableTask&apos;, TaskRun)AppRegistry.runApplication(&apos;RunableTask&apos;, &#123;&#125;); 在线上产品中就是利用了这一个层做了一些额外的事情。这里我使用事件触发的形式来做正常组件和这一个层的通知。 需要小心一点。如果在这一层做了定时器、循环事件等操作，记得要取消掉，不然事件就会变成两次。 缓存APP还是需要缓存的。这里可以缓存一些上次打开的数据，比如广告、用户信息等。 在打开APP的时候可以先用这些数据走正常的流程，然后在用一个异步的任务去鉴定、更新这些数据。这样下来可以让APP打开非常流畅，同时用户也不会发现数据变化大等异常。这些同时也是需要后端接口数据支持的。 关于Alert、Modal正常情况下Alert、Modal是独立于当前组件View之上的。如果这个时候遇到意外情况。比如组件销毁、暂停等情况下Alert还未销毁。这个时候就会发生比较严重的错误。 Alert大多数会报错，APP闪退。 Modal部分会报错，部分会暂停，失去事件等操作。导致APP一直停留在Modal视图上，用户也不能操作任何东西。时间长了系统就会判断APP未响应等等。 如果你不想处理这些东西，可以考虑使用一个自定义的Alert或者内嵌在组件中的View来代替Modal。 自定义组件在APP中其实有些属性是要经常用到的。比如Text组件的禁止使用系统字体大小，Image的缩放方式等。这些组件在平常使用过程中会经常重复添加各种属性，可以将这些组件独立出来，并且使用更加语义化的属性名来代替RN提供的使用方式。 在这个的基础上还可以将按钮、卡片等组件进一步抽象出来。对于不使用第三方开源组件的项目来说还是很有必要的。 解决遇到的问题使用RN开发会遇到很多问题，这些问题都可以在RN的Issues中找到答案。如果还没有就上google去搜一下，这个要求使用科学上网的形式。 有些问题需要修改RN的代码。不要怕麻烦，如果是js部分的修改，直接将下载的包修改成可上传的包就行了。这里记得上传到私有npm库中。如果是native的问题最好是在自己的native代码中覆盖掉旧的代码，毕竟前端去编译RN的源代码还是有很大的风险的。 不要去百度，百度真的没有答案。 按钮RN提供的按钮其实很丑，正常开发的时候大家都是使用自定义的按钮。 使用这种模式做出来的按钮非常漂亮，也更能符合设计的结果。不过使用的时候尽量不要给按钮本身加样式，有样式尽量添加到内部的View等组件上。 向下兼容RN使用的过程中我们升级了一个大的版本，从0.40系列升级到了0.50系列。由于大部分手机用户还存在不愿意升级APP的情况，向下兼容成了唯一的选择。 我使用的策略是修改源代码。。。。 比如升级0.53的时候发现有些native组件名变了。原来使用的是RCTMultilineTextInputView，现在变成了RCTTextView。不管RN出于什么理由改变了这个组件名字，造成的结果就是现在的旧代码不能跑在新的APP壳下。 我们可以打印出NativeModules的UIManager对象看看。 而兼容也是从这里开始做的。我们判断一下当前的RN是否在UIManager中提供了对应的原生组件即可判断当前的环境是否正确的环境。 比如要升级到53，修改53的源代码react-native/Libraries/Components/TextInput/TextInput.js。1234567891011121314//安卓的没变化,要排除if (Platform.OS === 'android') &#123; var AndroidTextInput = requireNativeComponent('AndroidTextInput', null);&#125; else if (Platform.OS === 'ios') &#123;//如果支持RCTTextView,既新APP if(UIManager.RCTTextView)&#123; var RCTMultilineTextInputView = requireNativeComponent('RCTTextView', null); var RCTSinglelineTextInputView = requireNativeComponent('RCTTextField', null); &#125;else&#123; //其他情况 var RCTMultilineTextInputView = requireNativeComponent('RCTMultilineTextInputView', null); var RCTSinglelineTextInputView = requireNativeComponent('RCTSinglelineTextInputView', null); &#125;&#125; 使用类似这样的手段就能区别两种APP壳的环境。用户在使用的时候也不至于要必须升级APP才能使用新版APP的功能了。 使用RN开发APP确实非常快，但是各位在开发中还是不要忘记钻研RN的源代码。很多解决方案其实很简单，有些时候可能只是由于低版本的APP不支持而导致的。 如果你想对RN有一个进一步的了解，还需要对原生的代码也有一定的了解。当然正常情况下还是有位这方面的同事一起开发比较好。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"科学而自由的上网指南","slug":"科学而自由的上网指南","date":"2018-03-25T09:03:00.000Z","updated":"2018-03-25T09:04:06.079Z","comments":true,"path":"2018/03/25/科学而自由的上网指南/","link":"","permalink":"http://www.guofangchao.com/2018/03/25/科学而自由的上网指南/","excerpt":"","text":"前段时间和谐大神比较厉害,我辈码农的很多自由上网工具都被墙掉了.我也是其中的一员…. 其实我基本上是不用的,国内的资源很多很丰富.在大多数时候一个百度就解决了问题了.偶尔遇到一些比较奇怪的问题才会去了解一下国外大神的想法.这个时候就有很大的可能遇到打不开的情况.凑巧这个时候之前用的收费工具不能用了.真的是让人着急啊. 索性我还是自己想办法吧.别人搭的商业服务不行,这里我就自己搭一个纯私人的服务算了. 首先要选择一个合适的服务器.这里首先就排除了阿里腾讯等国内大公司产品,其次亚马逊这种费钱的大户也是不考虑的.这里稍微推荐几个靠谱的专业服务器提供商. Vultr.机房遍及各大州,资源非常丰富.正常服务器500G/月流量,512MB的内存.价格为2.5$/月.不过很多时候有优惠,可以拿到1.5$/月的服务器.通过优惠地址还可以在第一次购买的时候增加更多优惠.优惠地址:https://www.vultr.com/?ref=7331073 sugarhosts.提供Sata和SSD两种硬盘VPS,49￥/月. 搬瓦工.机房非常多,目前年付低至19.99美金，多机房可选/切换. 如果你打开vultr之后发现可以购买1.5$的服务器,不要犹豫,马上下手吧.这个服务器几乎是全网最便宜的了.如果没有也可以换换搬瓦工,20$/年算下来也是非常便宜了.一月才用了1G的流量…. 我这里就是买了一个1.5$的服务器.速度算不上快,但是看个facebook的视频还是可以的.系统挑的是centos7, 在vultr上面购买服务器之后需要安装ss才能安全自由的上网.可以在github上面搜索源代码https://github.com/search?utf8=%E2%9C%93&amp;q=ShadowSocks&amp;type= 第一个就是ss的地址,打开之后看到的是一个默认的空地址.其实这里是个假象,只需要切换到master分支即可.https://github.com/shadowsocks/shadowsocks/tree/master 这里顺便提供一个ss管理端的地址https://github.com/orvice/ss-panel/tree/master 执行一键安装脚本.这里使用的是别的大神整理好的脚本,直接安装成功.这个脚本是centos上安装的脚本.别的系统没有试过,不确定是否可行.123wget --no-check-certificate -O shadowsocks-libev.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.shchmod +x shadowsocks-libev.sh./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log 安装过程中会提示输入ip/端口等信息.12345Congratulations, Shadowsocks-libev server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_method 到这里基本上就安装成功了,有一些改动也可以根据官网的教程来修改配置文件. 也可以自己优化ss的效率,提高ss的速度.这里推荐一个优化文章,链接地址 ss已经停止更新了,有兴趣的可以转向研究ss的进阶版本ssr.","categories":[{"name":"资源","slug":"resource","permalink":"http://www.guofangchao.com/categories/resource/"}],"tags":[{"name":"自由","slug":"自由","permalink":"http://www.guofangchao.com/tags/自由/"},{"name":"科学","slug":"科学","permalink":"http://www.guofangchao.com/tags/科学/"}],"keywords":[{"name":"资源","slug":"resource","permalink":"http://www.guofangchao.com/categories/resource/"}]},{"title":"使用google的免费服务运行机器学习代码","slug":"使用google的免费服务运行机器学习代码","date":"2018-03-23T02:14:00.000Z","updated":"2018-03-23T02:15:00.418Z","comments":true,"path":"2018/03/23/使用google的免费服务运行机器学习代码/","link":"","permalink":"http://www.guofangchao.com/2018/03/23/使用google的免费服务运行机器学习代码/","excerpt":"","text":"如果你想学习机器学习,但是又没有一个自己的环境/显卡.这里告诉大家一个好消息,google上面有一个免费的机器学习环境可以使用了. 在google搜索google colab,打开搜索到的地址:https://colab.research.google.com 默认会提示创建一个新的记事本.这是因为google提供的是一个笔记本的环境,所有的代码都是存储在一个个的记事本中的. 这个时候可以点击取消查看默认的案例. 从案例中可以看到代码和文档是直接结合在一起的,同时可以在代码的最下面看到执行的结果.这里稍微注意下一下,每段代码都是单独的一行. 可以在之前的界面点击创建,也可以在左上角的文件中选择创建.可选的有python2和python3这两种版本,根据自己的喜好来选择就好. 创建之后记得选择执行代码程序下的更改运行时类型. 在下面的硬件加速器中选择GPU,这样之后的代码就运行在gpu上了.再也不怕家里的电脑没gpu了. 这里添加一行代码,输入下面的一个案例.然后点击左侧的运行按钮,这样就可以在下面看到运行的结果了.1234567import matplotlib.pyplot as pltimport numpy as npx = np.arange(20)y = [x_i + np.random.randn(1) for x_i in x]a, b = np.polyfit(x, y, 1)plt.plot(x, y, 'o', np.arange(20), a*np.arange(20)+b, '-');","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.guofangchao.com/categories/机器学习/"}],"tags":[{"name":"google","slug":"google","permalink":"http://www.guofangchao.com/tags/google/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.guofangchao.com/categories/机器学习/"}]},{"title":"hexo添加seo优化","slug":"hexo添加seo优化","date":"2018-03-22T06:26:00.000Z","updated":"2018-03-22T06:43:35.341Z","comments":true,"path":"2018/03/22/hexo添加seo优化/","link":"","permalink":"http://www.guofangchao.com/2018/03/22/hexo添加seo优化/","excerpt":"","text":"站点收录一般来说你的网站搭建好后依旧是无法在各大搜索引擎中搜到的，具体可以通过在搜索引擎输入site:你的域名验证。所以你需要提交你的站点到各大搜索引擎： https://ziyuan.baidu.com/linksubmit/url https://www.google.com/webmasters/tools/home?hl=zh-CN 文件收录:1.需要先下载验证文件，将下载的文件放到站点根目录/source文件下2.在站点配置文件中找到skip_render:修改： 1234skip_render: - README.md - CNAME - baidu_verify_XXXXXXXXXX.html #下载的文件名 token验证1.把图中马赛克部分的token复制下来2.打开主题配置文件，搜索site_verification，修改： 添加站点地图sitemap安装hexo的sitemap网站地图生成插件12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save","categories":[{"name":"资源","slug":"resource","permalink":"http://www.guofangchao.com/categories/resource/"}],"tags":[{"name":"seo","slug":"seo","permalink":"http://www.guofangchao.com/tags/seo/"}],"keywords":[{"name":"资源","slug":"resource","permalink":"http://www.guofangchao.com/categories/resource/"}]},{"title":"react-native:一场APP中的革命","slug":"react-native-一场APP中的革命","date":"2018-03-20T03:35:00.000Z","updated":"2018-04-01T08:44:11.165Z","comments":true,"path":"2018/03/20/react-native-一场APP中的革命/","link":"","permalink":"http://www.guofangchao.com/2018/03/20/react-native-一场APP中的革命/","excerpt":"","text":"记得从2010年开始，前端就逐渐绽放光芒。 在那之前的我还是一个勤恳的后端工程师，每天的工作就是一边干着后端代码一边还要写一点table之类的前端代码。嗯，也算不上前端，仅仅是一个又一个表格的嵌套而已。那个时候的前端真的是个垃圾啊。 也就在那一年，我第一次转做开发web应用，依然记得跟我配合的是一个可爱的前端妹子。从前端妹子身上我学到了基础的前端开发方式，也就是在那一年我认识了锋利的jquery。那是怎样一种不同的语言啊，简单快速、上手就能使用、即时产生效果。一些好看的效果实现出来真的是又快速又简单。我回头看了看无趣的java代码…..嗯，小妹妹教教我好不好？ 从此真可谓一发不可收拾啊。我从jquery入门的前端，又回头研究了原生的各种使用姿势。一座新世界的大门从此向我打开。我开始制作各种有意思的小组件。有改了好几个版本的无限循环的轮播图一个系列。电脑手机上自适应网页宽度的各种姿势。导航等菜单中使用到的下拉列表的各种特效。各种效果的网页加载使用的loading动画。一路走来我深深的喜欢上了这种写完就能看效果，而且效果还日常爆炸的技术。 当我以为这就是前端的全部的时候，我看到了模块化技术。原来我之前骑的是自行车，果然我还是太年轻了。模块解决了大型项目分工合作的问题，顺便让网页加载的更加流畅，一举多得莫不过如此把。 我以为模块化已经非常厉害了，但是牛人的世界我不懂。后面有陆续遇到了gulp、babel、webpack，一个更比一个厉害，它们的思想真正让我知道，世界还可以这样子。至于后来遇到的了SPA应用，嗯，这个spa有点爽。果然，在一个适当的机会，我当机立断转战vueJs。 在不知不觉中前端的触角已经蔓延到了整个世界。尤其是在我们有了nodejs之后。曾经的一个脚本语言，由于各路神仙的加入，再加上它天生的开源基因，一个广阔的世界已经在向各位前端开发者走来。还有什么是我们做不到的呢？ 在之前一直想要做一个自己的APP。但是开发一个APP非常的麻烦，不仅仅是还需要学习安卓的开发语言和模式，同时要开发ios还需要再学习一套oc的东西，如果你还要兼容swift设置wp….我的天，想想就不开心一整天。 仔细想想我还能回忆曾经上手安卓代码的那段艰难岁月。下了一整天的SDK，后来才发现可以找国内的源。搞了一天的编辑器，最后还是屈服于Android studio，那个时候真的很少有好用的IDE。复杂的配置、艰难的界面布局、状况频出的开发过程。。。。。心酸啊。本来好好的学习心态也只剩下了无尽的挣扎。 我在想facebook的开发者们也肯定是这么想的，不然不会出现react-native。这真的是一个天才的想法，一下子解决了很多疑难杂症。虽然它目前还处在测试版本，这决定了它还有很多问题，开发的时候也许会遇到一些麻烦。但是核心的问题确实被真正的解决了，开发一个APP再也不是巨大的工作量了。 不需要一个陡峭的学习曲线，一个前端开发者就可以快速开发一个自己的APP。不在需要多个团队配合，一个团队搞定所有平台。顺便使用nodejs搭建一个后端接口，再配合MongoDB或者MySQL，完美！ 当我使用几天的时间开发完一个完整的APP的时候，我最大的感受就是—爽。 真的不需要再费力发布APP客户端了。一次安装永久最新，只需要更新服务器的js版本就能做到让用户更新最新的UI界面。升级过程用户完全无感知。客户端版本升级？那是什么。 再也不需要做2套代码了。开发iOS和Android只需要一套前端代码。在强大的社区帮助下，RN几乎支持所有的原生功能。一个团队只需要配备一个懂原生的开发就能轻易添加各种自定义的原生支持，想要加速某些方面只需要随着自己的心意自定义就好了，RN提供了完整的自定义流程。还有什么不满足？ 不需要做什么原生的开发，一个稍微复杂的APP就可以诞生出来。这得益于活跃的社区和热情的开源共享者。只需要npm和react-native短短一条命令，就跟安装web的第三方包一样简单。native就已经安装好了你需要的各种包，一切都是那么的简便。开发效率翻倍的提升。需要的开发人员翻倍的下降。 往常两个团队才能开发的项目，现在只需要一个团队。如果是简单项目甚至两三个人就搞定了。如果前端开发同学比较全面的话….仔细想想吧，一个前端搞APP，一个前端搞接口，一个前端搞DB。哇！前端搞定整个项目。 如果你真的想要学习一下这种高大上的技术，请在gitbook.cn上搜索react-native的实战达人课。一个真实的案例加一个资深的老师教你开发一个完整的电商APP。 前端才是真正的艺术，哈！ 正版课程地址","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"成就匹配算法解析","slug":"成就匹配算法解析","date":"2018-03-16T15:26:00.000Z","updated":"2018-03-20T06:35:03.829Z","comments":true,"path":"2018/03/16/成就匹配算法解析/","link":"","permalink":"http://www.guofangchao.com/2018/03/16/成就匹配算法解析/","excerpt":"","text":"今天遇到一个问题： 有4个固定的成就，每个成就对应一个数字。用户的积分超过这个数字自动获得这个成就将这个方法作为一个公用的方法 考虑如下：1.必须是一个单独的方法（多余）2.输入参数固定为积分数量3.输出参数包括当前成就名称，到达下一级需要的积分，下一级成就名称4.扩展要好，下次修改不用改太多5.性能要好，不能出问题 以下是JavaScript的实现版本。 123456789101112131415161718/***输入积分数，返回成就信息集。包含积分+1操作*num &#123;Number&#125; 当前积分数量*return num &#123;Number&#125; 距离下一级需要的积分数量*return type &#123;String&#125; 当前达到的成就名称*return next &#123;String&#125; 下一级的成就名称*/function test(num)&#123; var score_list=[0,500,2000,7000,16999]; var type_list=[\"\",\"专访\",\"百科\",\"群展\",\"个展\"]; var index=score_list.length-1; while(num&lt;score_list[index])index--; return &#123; num:score_list[index+1]-num, type:type_list[index], next:type_list[index+1] &#125;&#125; 可以考虑将2个数组放在外面节约一下空间，我这边的实际情况就不需要考虑了。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"算法","slug":"suanfa","permalink":"http://www.guofangchao.com/tags/suanfa/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"AppRegistry详细解析","slug":"AppRegistry详细解析","date":"2018-03-16T15:14:17.000Z","updated":"2018-03-16T15:16:28.673Z","comments":true,"path":"2018/03/16/AppRegistry详细解析/","link":"","permalink":"http://www.guofangchao.com/2018/03/16/AppRegistry详细解析/","excerpt":"","text":"在React-native中有一个api叫AppRegistry。这是RN中的一个重要api。 接口介绍 static registerComponent(appKey, componentProvider, section?)注册组件，js中非常重要的一步，只有这里注册了，native code中才会找到要执行的js。 static registerRunnable(appKey, run)注册一个新的线程，通过第一个参数来区分，第二个参数是一个方法。 static runApplication(appKey, appParameters) #根据key来执行对应的应用（例如使用Runable注册的）。如果appKey不存在会报错。 static getAppKeys()获取注册的所有线程。其中包括第一步注册的Component和后面注册的Runable static unmountApplicationComponentAtRootTag(rootTag)结束应用，不传参数默认结束appKeys中的第一个 static registerHeadlessTask(taskKey, task)创建一个任务，这个线程不支持UI。 static startHeadlessTask(taskId, taskKey, data)执行对应的任务。（暂不支持） static registerSection(appKey, component)注册一个切片 解释 appKey用到这个参数的地方，使用方法都一样 registerHeadlessTask这个方法的第二个参数是一个方法，要求返回的是一个Promise对象","categories":[],"tags":[],"keywords":[]},{"title":"04.基础-组件和商品详情","slug":"04-基础-组件和商品详情","date":"2018-03-14T14:40:00.000Z","updated":"2018-03-14T15:19:25.735Z","comments":true,"path":"2018/03/14/04-基础-组件和商品详情/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/04-基础-组件和商品详情/","excerpt":"","text":"知识点：1.使用路由跳转内页2.开发完整的商品详情页3.弹出选择数量 前面的代码已经加入git仓库，链接地址。讲项目放在本地的同学也可以试着将代码放到仓库里。这个地方可以使用单独的分支合并到master，也可以直接覆盖带master分支。 为了能够更直观的看到每次提交的代码，我尽量把每一节的内容都做一次提交，备注也会写的非常清楚.另外我也会不定时的增加各种注释到代码里。一般情况只需要切换到不同的提交时间点即可看到当时使用的代码了。 添加页面和跳转在src目录下添加一个新的目录detail，用来放新加入的详情页。新建goods.js，并写几行简单的代码。 在src下的index.js中，将新建的页面加入到路由里。 这样新建的详情页就加入了路由管理，只要在需要跳转的时候执行传入路由的名字就可以了。这里改造home页，将几个地方的跳转改成刚才的路由名称就可以了。 点击商品就会发现已经可以跳转到详情页了，但是现在详情页什么都没有。同时也不能返回到上一页。 自定义顶部在src下新建一个component目录，用来存放头部组件以及以后会用到的一些其他组件。将组件抽成一个公用的组件是一个非常明智的方法，它会让你省下很多的时间。最好的做法就是做一个兼容很多情况的组件，然后使用继承的方法做一些参数的重载。 改造这个组件，让ios的顶部和安卓的顶部高度一致，把ios顶部的系统组件露出来。默认情况下ios顶部在小图标下面，安卓则有一个系统的顶部横条，小图标不影响正常的界面。 顶部组件默认有一个中间的标题，下面再加一个默认的左侧返回键。返回键使用的是路由组件的gobanck方法。右侧给一个自定义右侧按钮的方法。 把这个自定义组件放在详情页，然后给一个title值。一个简单的顶部组件就做完了。 刷新页面看效果，点击一下返回键，看看是不是可以用了。 详情页顶部上半部分包括头图和几个属性介绍。 详情页的所有内容使用ScrollView包裹。这是一个比较简单的列表组件，使用非常方便。在列表不长的情况下请尽量使用这个组件。 将路由传进来的参数保存在组件的变量里。由于传入的参数有2个，所有这个地方使用了2个变量，同时后面做判断的时候也要判断2次。 在组件初始化之后调用接口，将接口返回的数据存入组件的state中。这里注意把state中的变量提前写好，减少不必要的bug。 在最上面添加一个商品图片，然后接着添加价格等信息。 到这里，详情页的简单信息就实现了。后面再添加一个详细的商品信息就可以了。 这里需要注意的是,接口返回的图片有大有小，这里做了一个处理,图片太大的话就缩小一些。 最终效果和正常的电商APP就很相似了。如果有特殊的样式还可以再自己调整。 上面的开发完成之后图片是同时加载的，导致有时候上部分的图片显示延迟，后面优化的时候会优化这种情况。 购买和加入购物车展示的界面有了，下面再加上加入购物车、购买等按钮就可以了。 按钮要求悬浮在界面的最下方，所以要将这几个按钮放在ScrollView的后面。放在里面虽然也可以做到，但是非常不推荐，这样会增加渲染难度。 这里有3个按钮，分别是购物车、立即购买和分享商品。 购买弹出层点击立即购买按钮不会直接跳转到下单页，这里会弹出一个简单的选择数量的页面。在RN中如果需要使用这样的一个层就需要用Modal组件来做。Modal在RN中是一个单独的view层，默认覆盖在所有的页面上面。 这里设置Modal不使用默认的动画、全完透明，给onRequestClose添加一个默认的方法，不然会在手机上报错。 首先给Modal加一个内容层。这一层的主要作用是自己做遮罩的样式。这里是一个半透明的黑色遮罩。内部加一层点击区域，效果等于再点击黑色透明层的时候能够关掉弹出层。123456 &lt;View style=&#123;SpecificationsStyle.warp&#125;&gt; &lt;TouchableOpacity activeOpacity=&#123;0.9&#125; style=&#123;&#123; width: px(750), flex: 1 &#125;&#125; onPress=&#123;() =&gt; this.setState(&#123; priceBoxStatus: false &#125;)&#125;&gt;&lt;/TouchableOpacity&gt;&lt;/View&gt; 接下来开始写商品简略信息，包括商品小图、价格。 下面再加一层用来放选择商品数量和购买按钮。 最后把几个事件实现一下。123456789101112131415161718192021222324252627282930313233343536373839//购买方法 openbuy() &#123; this.setState(&#123; priceBoxStatus: true &#125;) &#125; //数量减少 reduce() &#123; if (this.state.buyNumber == 1) return; let buyNumber = Number(this.state.buyNumber) || 2; if (isNaN(buyNumber)) buyNumber = 2; this.setState(&#123; buyNumber: --buyNumber &#125;) &#125; //改数量 changeNumber(num) &#123; num = Number(num); if (isNaN(num)) num = 1; if (num &gt; this.state.limitStock) &#123; num = 1 toast(`库存不足`); &#125; this.setState(&#123; buyNumber: num &#125;); &#125; //增加数量 plus() &#123; if (this.state.isBuyLimit == 1 &amp;&amp; this.state.buyNumber &gt;= this.state.buyLimitNum) &#123; toast(`该商品为限购商品,$&#123;this.state.buyLimitMsg&#125;`); return; &#125; if (this.state.buyNumber &gt;= this.state.limitStock) &#123; toast(`库存仅剩$&#123;this.state.limitStock&#125;件`); return; &#125; let qty = this.state.buyNumber || 1; if (isNaN(qty)) qty = 1; this.setState(&#123; buyNumber: ++qty &#125;) &#125; 最终效果如图。点击立即购买按钮即可弹出这一个弹出层。弹出层可以选择数量，默认保持数量为1，受库存以及最大可选择的数量影响。也可以直接点击按钮跳转到购买页。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"03.基础-首页模板和商品列表","slug":"03-基础-首页模板和商品列表","date":"2018-03-14T14:39:00.000Z","updated":"2018-03-14T14:39:49.655Z","comments":true,"path":"2018/03/14/03-基础-首页模板和商品列表/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/03-基础-首页模板和商品列表/","excerpt":"","text":"知识点：1.给首页添加banner2.给首页添加运营模板3.获取接口的商品4.给顶部加一个搜索条 从这章开始我们正式开始案例的开发。git仓库的地址会放到下一章显示，需要的同学可以直接去git上看每一次提交的代码。 本文先从最早的代码形式开始一步一步的讲下去，开始开发的app会在某些情况下很卡，后面会将优化需要做的东西讲出来。这里先从简单的实现app界面开始讲，如果你觉得手机反应慢，请看后面的优化部分。 首页容器修改首页index.js文件,创建一个容器,用来放置后面要添加的各种组件。 Banner和快捷入口这里的Banner用到了一个轮播图组件。根目录下执行npm i --save react-native-swiper安装新的组件。 创建一个组件，这个组件用来放Banner和快捷入口。 这里创建state中变量，banners用来存储banner列表，quicks用来存储快捷入口的列表。 请求远程接口，将返回的数据放入state中。 将banner渲染再页面上。这里有一个小技巧，如果只有一张图片就不再使用轮播图。 接下来就是快捷入口，由于快捷入口用到了gif图。所以这里添加一个第三方的组件react-native-fast-image。在线的项目使用的是官方推荐的设置方法，让RN的image组件支持的gif。 执行npm i --save react-native-fast-image，然后使用link命令将组件加入到原生代码里。react-native link react-native-fast-image，执行完毕重新运行模拟器react-native run-ios。 将state中的数据渲染在banner的下面。这里用到了几个组件和一个新的图片，需要单独添加。ImageBackground是RN在0.47之后的版本加入的组件，它可以将一个图片当做背景来使用。这里推荐在0.50之后的版本中使用。 刷新模拟器看看效果。一个简单的banner+入口的界面就显示出来了。是不是非常简单！ 自定义模板从入口下面开始就是一个自定义的模板。这里使用现成的接口，现成的设计来做模板。运营人员会在后端传入图片并设置跳转链接。app根据设计好的样式渲染模板结果。目前有8个模板在使用，后面可能会添加更多。这里先不管后面的新模板。 在home下新建一个floor_modules.js文件。自定义模板单独放在这里处理。这里由于代码比较长就不贴出来了，有想看具体情况的可以去git仓库看。 到目前为止使用还是View组件。这个组件是不支持滑动的，要想列表可以滑动，需要将渲染结果放在专门的列表组件中才行。这里不适用ScrollView的原因是，FlatList可以在滚动的时候隐藏屏幕外的无用节点。可以提高列表性能，尤其是列表非常长的时候。 把刚才写的2个组件放到Flatlist中的header组件中ListHeaderComponent。 使用numColumns设置列表为双列。 使用refreshing传入下拉刷新使用到的变量。 使用onRefresh在下拉刷新的时候重新获取列表数据 使用onEndReached在滑动到列表底部的时候加载下一页 使用ListHeaderComponent渲染列表的头 使用renderItem渲染列表项。 使用ListFooterComponent设置底部的文字，一般可以给加载下一页展示加载的状态、文字。 使用onScroll在滑动的时候触发自己的事件。这里使用scrollEventThrottle控制触发的频率，内部的数字就是1000毫秒内触发的次数，数字越大触发越少。 使用keyExtractor设置列表每个项的key。在列表判断列表项的时候会使用这个返回的id作为key。注意，这里返回的值不能重复。 使用data设置商品的项，必须是数组。 商品列表首先给上面的2个组件添加一个名字，然后在刷新方法里调用他们的刷新方法。这样就可以做到在下拉刷新的时候同时可以刷新前面2个组件。 添加一个请求数据的方法并在组件初始化结束之后调用方法。这里使用await来达到同步等待请求结果的效果。注意，必须使用try来包裹这个方法。否则在返回错误信息的时候会发生app奔溃的效果。 这里设置了一个start变量来存储页码。这里注意一下，只有需要改变UI的变量才需要放到state里面，其他的尽量放到组件自身上面或者其他地方。否在在改变一些无意义的数据的时候也会触发界面刷新。 这里把加载下一页单独写成一个方法了。有的手机在初始化列表的时候不仅会调用一次获取第一页的方法，同时也会调用一次下一页的方法。 新建商品列表组件GoodItem，修改Flatlist组件，把GoodItem放到内容渲染方法里。 这里将数组序号也传入组件，目的是给商品列表的每一项添加一个不一样的样式。这里设置的样式在安卓和ios上会有不同的效果 通过取余方法即可完成每行有2中不同的样式。这在双列的列表中非常的常用。 首页列表中的这个大块头部组件和列表中的非常多得商品项会暴露出很多问题。后面会把这一块优化，以达到和原生一样的效果。 头部组件初步开发已经完成了。但是我们还需要在这个的基础上再加上头部组件，这个组件负责显示用的一些信息和一个假的搜索条。这样才是一个完整的APP该有的样子。 添加一个SearchHeader组件，用来做商品列表页的顶部。1234567//顶部搜索条组件class SearchHeader extends React.Component&#123; render()&#123; //这里先不去管具体的内容 return &lt;View&gt;&lt;/View&gt; &#125;&#125; 将组件放在最外层，同时使用绝对定位将顶部浮动在所有组件的最前面。这里先不讲动画，看着难受的同学可以先把浮动的组件改成普通的组件。 123456789101112131415161718const styles = StyleSheet.create(&#123; headerView: &#123; position: \"absolute\", left: 0, right: 0, top: 0, zIndex: 100, &#125;, pageView: &#123; flex: 1, width: deviceWidth, &#125;, loading: &#123; textAlign: 'center', fontSize: px(28), color: \"#ccc\" &#125;,&#125;) 顶部添加一个头像显示组件，中间添加一个输入框。这里的输入框没有实际的功能，主要是为了跳转到真正的搜索页的。 到这里基本就开发完了。将它们组合在一起然后刷新页面。 完成到这里就完成了基础的首页开发。一个简单的首页就呈现在外面的面前。如果懂打包的同学已经可以马上打一个apk文件了。这里稍微注意一下，模拟器使用的是ios，打包最方便的还是安卓，但是ios和安卓在某些情况下会有一些区别。比如样式上会根据手机的不同有一些不一样的效果，有些组件甚至只支持ios。 在浏览的时候也会看到滑动会有一些生涩，点击跳转也没有做。顶部最好有一些动画等等。这些在后面都会有涉及。图中就是在说列表太长导致更新很慢，同时还提醒开发者使用PureComponent来优化性能。后面会教大家怎样使用purComponent和shouldComponentUpdate来优化性能。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"02.基础-封装自己的库","slug":"02-基础-封装自己的库","date":"2018-03-14T14:38:00.000Z","updated":"2018-03-14T14:38:48.692Z","comments":true,"path":"2018/03/14/02-基础-封装自己的库/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/02-基础-封装自己的库/","excerpt":"","text":"知识点：1.封装一个自己的日志，代替原生的console2.封装一个自己的请求库，代替原生的fetch3.自适应方法，兼容各种手机屏幕4.封装一个本地存储5.集成toast弹出提示6.让iOS支持http地址7.安卓需要证书才能编译 在正式开始之前，我们先封装几个要用到的库。 自定义本地日志自定义日志的一个好处就是省的每次都要手动注释console。而且还可以同时将日志存在本地，或者发到日志服务器。一个方法就一举多得了。 在src目录下新建一个utils文件夹。我们封装一个日志输出类。开发模式下使用console.log命令。正式情况下记录在变量中，方便在手机上查看日志。 新建一个log.js文件。路径为根目录/src/utils/log.js。 新建一个数组变量logs，用来临时存放日志信息。 将日志分成信息、警告和错误3种，分别给出3个可调用的方法。同时给第一个参数加一个好看的颜色。 在index中引入日志组件，写几个方法看看调用的结果。 这里稍微定义一下日志的要求。参数0，字符串。参数1，对象。参数2，字符串。 自定义请求RN默认提供了fetch方法去请求远程数据。我们再封装一次，将这个方法将会针对现有的项目做封装，在使用请求的时候能够更适合、更方便。这里使用header保存了一些临时的变量，算是一个小小的全局缓存吧。 创建request.js文件，目录：根目录/src/utils/request.js。 将请求header里的信息单独出来，每次请求都需要带上这个共享header数据。 创建一个Request类,并将这个类对外公开。这里讲请求初始化一次，以后用到别的请求的时候也可以单独实例化一次。123456/** * 请求库 */class Request &#123;&#125;export default new Request(); 每次请求都将header中的内容带入请求中，单独检测httpcode和后端返回的code值。这里可以直接做权限检测，在需要的时候跳转到登录页。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 请求库 */class Request &#123; /** * 检测返回状态码 * @param &#123;*&#125; status * @param &#123;*&#125; res */ async _checkStatus(status, res, url) &#123; if (status !== 200) &#123; logWarm('请求失败参数', await res.text(), url, headers); throw new Error('网络连接失败，请检查网络'); &#125; &#125; /** * 检查后端返回的状态码 * @param &#123;*&#125; status */ _checkAppStatus(json, url) &#123; if (json.status != 0) &#123; logWarm('返回状态报错', json, url); throw new Error(`$&#123;json.errorMsg&#125;`); &#125; &#125; /** * 内部实现网络请求 * @param &#123;*&#125; url * @param &#123;*&#125; options */ async _request(url, options, type) &#123; url = url.indexOf('http') == 0 ? url : url.indexOf('/api') == 0 ? domain + url : baseUrl + url; let res = await fetch(url, options); this._checkStatus(res.status, res, url) if (type === 'json') return await this._jsonFactory(res, url, options) return await this._jsonFactory(res, url, options) &#125; /** * 处理json数据 * @param &#123;*&#125; res * @param &#123;*&#125; url */ async _jsonFactory(res, url, options) &#123; let json; let txt = ''; try &#123; txt = await res.text(); &#125; catch (e) &#123; log('未拿到返回字符串', &#123; url: url, txt: txt &#125;); throw new Error('数据格式错误'); &#125; try &#123; json = JSON.parse(txt); &#125; catch (e) &#123; logErr('返回数据格式错误', &#123; url: url, txt: txt &#125;); throw new Error('数据格式错误'); &#125; this._checkAppStatus(json, url) log(\"请求返回\", json, url, options); return json.data; &#125; /** * get请求 * @param &#123;*&#125; url */ async get(url, data) &#123; if (data) data = urlEncoded(data); if (url.indexOf('?') &lt; 0 &amp;&amp; data) url += '?' + data; return this._request(url, &#123; method: 'GET', headers: headers, timeout: 10000 &#125;, 'json') &#125; /** * post请求 * @param &#123;*&#125; url * @param &#123;*&#125; data */ async post(url, data) &#123; return this._request(url, &#123; method: 'POST', headers: Object.assign(headers, &#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125;), timeout: 10000, body: urlEncoded(data) &#125;, 'json') &#125;&#125; 调用一次远程端口并查看日志输出。这里调用的也是案例中要使用到的获取banner的接口。这个接口不需要用户权限，后面还会遇到需要用户权限的接口。 自适应方法这里推荐一种自适应的方法。同时也是前端在开发移动端页面的时候常用的方法。将手机屏幕宽度默认为750像素，然后将所有的宽高按照这个比例去缩放。这要求设计出的设计稿也要宽度是750。 在utils下新建一个px.js文件。按照出入的大小根据当前屏幕的宽度获取到缩放的比例并返回结果。 在首页引入px方法，查看使用px之后的效果。 可以看到使用px将500像素缩放之后的效果和最开始设置的纯数字200效果是一致的。这里使用的是ios模拟器，真实的屏幕宽是375，按照750宽去算的话会把传入的参数统统除以2。 封装本地存储RN提供的AsyncStorage可以根据key存储相应的字符串。我们这里改进一下，让它可以存储所有类型的字段。利用的是将传入的参数改造成对象，然后使用JSON的方法将对象转化成一个可以存储的字符串。 在utils下新建一个Storage.js。 将传入的对象转化为字符串并存入AsyncStorage。123456789101112131415161718192021222324252627282930313233343536373839'use strict';import &#123; AsyncStorage &#125; from 'react-native';/** * 获取存储的数据 * @param &#123;*&#125; key */exports.getItem = async (key) =&gt; &#123; let item = await AsyncStorage.getItem(key); if (!item) &#123; return null; &#125; return JSON.parse(item).v || null;&#125;/** * 存入数据 * @param &#123;*&#125; key * @param &#123;*&#125; value */exports.setItem = (key, value) =&gt; AsyncStorage.setItem(key, JSON.stringify(&#123; v: value&#125;));/** * 删除已经存在的数据 * @param &#123;*&#125; key */exports.removeItem = (key) =&gt; AsyncStorage.removeItem(key);/** * 清除所有 */exports.clear = () =&gt; AsyncStorage.clear();/** * 获取所有的key */exports.getAllKeys = () =&gt; AsyncStorage.getAllKeys(); 在首页使用setItem存入数据,然后第二次进入页面再使用getItem获取数据。 这里用到了componentDidMount这个方法。这个方法是在组件生命周期中的初始化完成之后执行的。 添加弹出toast之前公司使用的是自己开发的提示方法，这个方法需要改变原生代码，非常的不方便。这里推荐使用第三方的开源组件react-native-root-toast。只需要安装一下就好了。 执行命令，安装toast。npm i --save react-native-root-toast。 在utils目录下新建toast.js文件。添加toast的默认方法并填入默认参数。这里设置显示时间为1000毫秒，背景颜色是一个半透明的黑色。这里也是为了方便调用，如果需要多种效果的就定义多个吧。 在首页引入toast并看看实际的效果。 让iOS支持http协议苹果之前推荐使用https协议,现在默认是不支持http的。如果需要支持http需要单独设置。案例中的项目也用到了http，所以需要修改info.plist文件，让iOS可以访问http的地址。 使用xcode选择打开其他项目。 打开项目下的iOS文件夹，选择项目文件并打开。 选择info.plist文件，再右边选择第一行并点击+号添加一项。 选择App Transport Security Setting这一项，会弹出提示。点击确定即可自动刷新。 在上面添加的新配置中添加一个新的配置Allow Arbitrary Loads，同时设置为YES。 改完配置还需要编译一次。点击左上角的三角形或者菜单中product下的build选项。 这里我使用的是xcode修改配置文件，如果你发现配置文件没有变化，也可以自己改info.plist文件的内容。 编译安卓客户端使用android studio打开根项目下的android目录。打开build.gradle文件。这个就是项目的gradle配置文件，通常使用这个文件对整个项目进行描述。 经过一定时间的等待，IDE就会初始化整个项目。如果有一些需要下载的文件也会在这个时间通知下载。 点击菜单build/gennerate signed apk。这个就是编译一个可以安装在安卓手机上的安装包。也可以通过点击make project来看看项目是否可以编译通过。 点击next，IDE会提示需要选择一个证书。这里可以选择一个已有的并输入密码，也可以通过点击create new来创建一个。后面一直点击next就可以了，IDE会在生成apk之后弹出通知。 选择创建一个新的证书。根据提示填入相应的内容，之后点击ok即可生成。记得选择remember password，下次直接填入密码。 经过一整机器躁动之后，IDE弹出编译结果。点击蓝色字可以快速打开apk的地址。 将apk文件发送到手机上安装即可。一个你自己开发的app就安装好了。 这里要注意，在打包之前要把RN打包生成的bundle文件放入android文件下的assets目录中。否则安卓会因为找不到启动文件而报错。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"01.基础-项目初始化","slug":"01-基础-项目初始化","date":"2018-03-14T14:12:00.000Z","updated":"2018-03-14T14:39:05.931Z","comments":true,"path":"2018/03/14/01-基础-项目初始化/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/01-基础-项目初始化/","excerpt":"","text":"知识点：1.快速创建RN项目2.添加使用路由功能3.不要在RN中使用的功能 从这里开始，我们将一步一步的创建一个可以真正的使用的app。第一部分讲述开发一个app的大致过程，第二部分将开始优化性能、开发效率等，第三部分教大家添加热更新、支付、分享这些功能。大多数第三方组件可以很方便的link到项目里，部分需要手动导入甚至主动开发一些东西，这里也会在用到的时候讲出来。 创建项目的前提条件·使用react-native创建一个新的项目请确保你的电脑上已经满足下面的这些条件。 nodejs。RN的所有库都是从npm上安装的。请确保你的电脑上已经安装了npm。可以使用npm -v来查看当前是否安装了npm。当前项目使用的node版本是8.9.3，npm的版本是5.5.3。 react-native-cli。这个通常用作RN的初始化和启动模拟器等，是用npm可以安装到电脑上。 python。RN里面有些脚本是使用python写的。请确保电脑上已经安装了python2.7以上的版本。 jdk1.8。安卓项目需要使用jdk1.8，请在电脑上安装好jdk1.8。安装的教程可以方便从网上搜索到。 Android Studio。调试以及编译安卓代码需要使用到。请在安装Android Studio之后安装好Android SDK以及模拟器。模拟器可以使用市面上的安卓模拟器，它们普遍比自带的模拟器要快。闲麻烦的同学可以直接连接手机调试。在安装好IED之后请下载好需要使用到的androidSDK。下载SDK需要科学上网或者把下载地址替换成国内的几个下载源。 git。后面的项目会加入到git中，使用git做版本管理的好处不言而喻。 Xcode（仅ios项目中）。安装了Xcode才能使用iOS模拟器。ios模拟器下的开发速度要明显优于安卓下，后面的开发过程大多数也是在ios模拟器中进行的。在模拟器中的表现都差不多，有些不一样的效果可以在看到的时候单独调试。 Watchman（仅mac系统用到）。Watchman用来监听文件变动等。mac下必须安装Watchman。 vscode。文中演示项目使用的编辑器是vscode。这里也推荐使用vscode开发前端项目。 创建项目我们先在本地创建一个可运行的项目，同时这个项目会加入到git的版本管理中。 执行react-native init anxintao --version 0.53.0。图中1代表之前安装的react-native-cli的命令。图中2代表初始化命令。图中3代表项目的名称，这里是anxintao。图中4代表指定RN的版本号，这个参数不传默认使用最新版。图中5代表RN具体使用的版本号。 使用vscode打开项目，在项目根目录下执行命令启动初始化之后的项目，mac下推荐react-native run-ios，window下推荐react-native run-android启动默认的项目。如果能启动说明项目初始化完成，否则说明项目的某些东西没有安装好。这里推荐把启动的命令写入到package.json文件中。比如:输入npm run ios即可代替原来的react-native run-ios，输入命令的速度快了不少。也可以给vscode安装一个启动RN的插件，不过效果跟输命令差不多，具体要看个人习惯了。 到这里就说明项目创建成功了。这个项目现在还很简单，它的原生部分只有一个简单的空壳。这个空壳仅仅是初始化了一个RN的activity，所有的js都是运行在根视图上的。 这里注意一下，新建的项目提示了按键可以刷新页面或者调出菜单。这显示的是ios模拟器，按键为command R刷新和command D调出菜单。 添加路由一个完整的项目不能没有路由。这里我们使用React Navigation。 在写文章的时候已经有一个路由组件react-native-navigation热度超过了react-navigation。它更多的使用的是原生的路由切换，效果更好。想用的同学可以去尝试一下。 安装路由。在根目录下执行npm install --save react-navigation。 在根目录下新建src目录。所有页面放入这个文件夹下。 新建一个首页，给后面的路由调用。页面路径为:根目录/src/home/index.js 12345678910111213141516'use strict';import React from 'react';import &#123; StyleSheet, View, Text&#125; from 'react-native';export default class extends React.Component &#123; render() &#123; return &lt;View style=&#123;&#123; marginTop: 200 &#125;&#125;&gt; &lt;Text&gt;这是首页&lt;/Text&gt; &lt;/View&gt; &#125;&#125; 修改根目录下的index.js。添加整个项目的路由。 1234import &#123; AppRegistry &#125; from 'react-native';import Pages from './src';//启动AppRegistry.registerComponent('anxintao', () =&gt; Pages); 5.在src目录下新建index.js文件。在这个文件里添加路由。我们从简单的一个页面开始。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354'use strict';import React from 'react';import &#123; StyleSheet&#125; from 'react-native';//添加路由组件import Navigation from 'react-navigation';//添加展示用的首页import Home from './home/index'//创建路由const Pages = Navigation.StackNavigator(&#123; 'Home': &#123; screen: Home &#125;&#125;, &#123; //这里做了一个页面跳转的动画 transitionConfig: () =&gt; (&#123; screenInterpolator: sceneProps =&gt; &#123; const &#123; layout, position, scene &#125; = sceneProps; const &#123; index &#125; = scene; //设置页面跳转的动画 const translateX = position.interpolate(&#123; inputRange: [index - 1, index, index + 1], outputRange: [layout.initWidth, 0, 0] &#125;); const opacity = position.interpolate(&#123; inputRange: [index - 1, index - 0.99, index, index + 0.99, index + 1], outputRange: [0, 1, 1, 0.3, 0] &#125;); return &#123; opacity, transform: [&#123; translateX &#125;] &#125;; &#125; &#125;), navigationOptions: &#123; header: null &#125;&#125;);//创建一个自己的容器,方便以后对路由做一些处理export default class extends React.Component&#123; constructor(props) &#123; super(props); &#125; render() &#123; return &lt;Pages onNavigationStateChange=&#123;this.listenChange.bind(this)&#125;&gt;&lt;/Pages&gt;; &#125; //监听路由的跳转 listenChange(state1, state2, action) &#123; &#125;&#125; 6.添加完成之后删除掉初始化项目之后的App.js。这个时候在模拟器中使用快捷键command+R即可刷新刷新页面。7.至此就完成了简单的路由设置。之后只需要添加页面并在路由中注册即可使用。 路由升级版简单的路由并不能起到很好的作用，我们还是创建一个更实用的路由吧。比如带3个tab切换的首页，这也是大多数app使用套路。 添加4个tab切换页。我们假定未来需要4个切换页，分别是首页、分类页、购物车、个人中心。在home下分别创建他们。 修改路由所在的index文件。引入下面要用到的几个组件和页面 添加新加入的页面123456789101112import React from 'react';import &#123; StyleSheet, Image&#125; from 'react-native';//添加路由组件import Navigation from 'react-navigation';//添加展示用的首页import Home from './home/index'import Products from './home/products'import Shop_Cart from './home/shop_cart'import My from './home/my' 创建底部的样式123456789101112131415//创建tab页的顶部样式const styles = StyleSheet.create(&#123; tab: &#123; height: 40, backgroundColor: '#fbfafc', borderTopColor: '#efefef' &#125;, tabIcon: &#123; width: 20, height: 20 &#125;, tabLabel: &#123; marginBottom: 4 &#125;&#125;) 创建一个tab路由，为了简单这里只展示2个页面的。具体的代码可以去git仓库查看。1234567891011121314151617181920212223242526272829303132333435363738394041//创建首页的tab页const Tabs = Navigation.TabNavigator(&#123; 'Home': &#123; screen: Home, navigationOptions: (&#123; navigation, screenProps &#125;) =&gt; &#123; return &#123; tabBarLabel: '首页', tabBarIcon: (opt) =&gt; &#123; if (opt.focused) return &lt;Image source=&#123;&#123; uri: require('./images/tab-home-active') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; return &lt;Image source=&#123;&#123; uri: require('./images/tab-home') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; &#125; &#125; &#125; &#125;, 'Products': &#123; screen: Products, navigationOptions: (&#123; navigation, screenProps &#125;) =&gt; &#123; return &#123; tabBarLabel: '产品分类', tabBarIcon: (opt) =&gt; &#123; if (opt.focused) return &lt;Image source=&#123;&#123; uri: require('./images/tab-products-active') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; return &lt;Image source=&#123;&#123; uri: require('./images/tab-products') &#125;&#125; style=&#123;styles.tabIcon&#125;&gt;&lt;/Image&gt;; &#125; &#125; &#125; &#125;,&#125;, &#123; //设置tab使用的组件 tabBarComponent: Navigation.TabBarBottom, //点击哪个才加载哪个tab里的页面 lazy: true, //设置tab放在界面的底部 tabBarPosition: 'bottom', //设置tab里面的样式 tabBarOptions: &#123; style: styles.tab, labelStyle: styles.tabLabel, activeTintColor: '#d0648f' &#125;&#125;); 替换Pages里的第一个页面为刚才创建的Tab路由。由于默认加载第一个，所以需要将第一个设置成tab页。123'Tabs': &#123; screen: Tabs &#125; 3.现在再刷新模拟器,就会发现底部的Tab切换已经好了。点击可以切换不同的页面。 4.这里我将图片转化成base64的方式再引入到图片组件中。好处是打包之后会变成一个整体。坏处是打包之后的bundle文件会变大，做增量更新也比较麻烦。 不推荐使用的东西 投影。安卓不支持投影，在开发的时候如果没有必要就使用别的方式代替吧。比如使用图片代替投影。 边框色。在长列表中尽量不要使用边框色，在某些安卓手机下会闪退。 使用了圆角的情况再使用背景色。ios手机会出现边框颜色异常或者异常色块。去掉背景即可。 过于深层次的结构 过于频繁的刷新state","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]},{"title":"00.为什么我选择react-native","slug":"00-为什么我选择react-native","date":"2018-03-14T14:10:00.000Z","updated":"2018-03-14T14:15:33.879Z","comments":true,"path":"2018/03/14/00-为什么我选择react-native/","link":"","permalink":"http://www.guofangchao.com/2018/03/14/00-为什么我选择react-native/","excerpt":"","text":"在所有的技术选型之前都有一个为什么。 为什么我选择了React-native？选择这个技术到底给我带来了什么样的技术福利？如果你正在考虑RN，或者还在研究选择什么样的技术实现自家的APP。不妨看看我的课程，说不定你就有了不一样的感受。 注：react-native以下会简称RN。 我注意的优点选择RN之前我也看过了其他的几种技术，早一点的时候我也使用过其他的技术做APP。比如HBuilder的框架，非常的方便、非常的好用、什么都不需要管。但是开发完之后发现性能很差，做一个稍微复杂点的项目就非常上火。后来切了原生，但是使用java做开发也有非常多得问题，开发效率很低。 后来我选择了RN，它使用js更新虚拟dom，通过一个桥接器将需要更新的结果通知到UI层，让native执行UI的改变。简单来说，就是用js做驱动开发一个类原生的APP。所有的渲染都是和原生一样的，一下子就讲原生开发和js开发连接起来。通过这么一个模式，将传统的java或者oc开发转变成了简单易懂的前端js开发。这是移动开发的一大进步，避免了一个APP多个平台多套代码的尴尬，同时提升了开发效率，将移动开发带入了一个新的层面。 性能相似很多人说RN的性能比不上原生的APP。这个说法是要看具体的场景下的。 在一般的应用场景下RN的表现和原生APP是没有太大的差别的。一个APP也不会是到处都是复杂的交互效果。一些简单的点缀动画再加上列表图片等才是一个APP最常见的内容。这种情况下它们之间的表现是一样的。 RN本身只是使用js处理了UI渲染之前的一些逻辑，在最终的渲染上其实使用的还是原生的逻辑。尤其是渲染完成之后更是和原生的没有半点区别。 我们的案例是一个电商项目，主要渲染逻辑是首页的自定义模板、无限加载的列表等。目前最大的性能瓶颈其实是在事件的优化上，优化之后用户已经感知不到和原生的区别了。我们会在后面的部分提到性能优化，将一个粗糙的app通过简单的方法提高10倍性能，再通过另外一个稍微复杂的方法减低内存占用。 开发效率高通常情况开发一款APP需要发布在安卓和iOS两个平台，导致的结果就是一个APP两个团队两套代码。界面几乎一样，为什么不能使用一套代码呢？之前也有大神使用各种手段达成这个目标，但是并不是很理想。 由于使用熟悉的react和jsx的模式，开发者只需要有前端知识就可以很迅速的上手一个RN项目。如果再学一些实战的例子，稍微复杂一些的项目也难不倒各位前端开发者。 debug超级方便，一边开发一边看效果再也不是梦。 快速热更新RN生成的js文件，只要不涉及原生功能的增减，已经发布的APP完全不需要重新安装即可完成新版功能的上线。用户只需打开APP就能体验到最新的APP，省去了下载重装的各种麻烦。把app的更新做到了和网页更新一样的方便快捷。 使用RN就能达到既有原生的所有能力，又有类似浏览器上的快速更新能力。同时还可以接入各种定制好的网页，将APP的自由度提高到一个非常高的地步。 大公司背书RN的开发者是facebook，背靠大树好乘凉，社区更疯狂。FB本身也在尝试使用RN技术开发自己的APP，RN一定会越来越完善。截止写这篇文章的时候RN已经更新到了0.53.0。 RN本身也是开源的，所有的源代码都是可以看到的。社区的讨论也是比较热烈的。现在可能中文文档还比较少，未来随着开发者的努力，这些坑都会填起来的。 其实最开始的时候也没有想很多，仅仅是冲着RN可以快速开发，上线快体验好。经过了这么长时间的开发，我更加喜欢RN的这种开发方式，项目中也填了各种各样的坑。后面就用一个实际的例子来展示RN是怎样开发的吧。 RN的缺点升级快RN本身其实还处于测试版，开发组经常会升级RN，解决一些遗留或者隐藏的bug。在这个的过程中就导致了RN本身升级非常快，开发者在使用RN开发APP的过程中应该尽量提高自己的版本，不需要一直是最新的，只要能够跟的上FB的节奏即可。 自己搞定的问题也是可以合并入RN的源代码里的。不要一味的等RN更新，有些问题自己解决更方便。建议会Android或者ios同学自己动手。 动画难这里的难指的是复杂的动画在开发中很难去优化。尤其是开发者懂前端但是不懂原生的情况下。好在常见的APP也不需要多么复杂的动画。一般使用位移变换就足够了，太复杂的动画建议使用RN的svg组件来做。 webview难用RN自带的webview跟浏览器有一定的差别。APP经常要打开一些网页，可能在开发的时候一切正常，但是到了RN里面就会有一些奇怪的问题，主要还是受到系统浏览器的影响，会有一些兼容方面的问题。这种情况下不如微信使用自己研发的浏览器，可以畅快的使用ES6之类的新技术。 需要原生支持简单的东西和界面的展现已经完全放手给了开发者。但是还是有一些功能只能原生去实现，如果原生部分的开发者对RN不太了解可能会给APP带来不可预知的bug。好在大多数开源看只需要执行link命令就可以把原生部分也安装好。 技术都会有优点和缺点。选择合适的技术才能给项目带来长久的生命力。 其他技术weex核心思想上，这两家其实并没有什么区别。weex也可以算是站在RN的肩膀上起步的。目前活跃度不高，大多数是在观望中。 开发框架weex使用vue。熟悉vue的开发者可能会更熟悉。 RN使用react。都是facebook出品，框架融合上会更方便一些。 它们都是组件化开发，都输数据绑定，都有虚拟dom。社区同样活跃，使用人数也都非常多。 学习成本react的jsx初期会比较难上手，css的写法也跟前端的样式写法不一样。weex使用模板的形式，直接html+css开发。上手会稍微简单一些。 异步weex只支持callback的形式。RN支持promise的形式。 这些都是可以解决的。不是什么问题。 社区RN开源早，有facebook支持。社区的组件库已经比较丰富，社区活跃度比较高。weex开源晚，社区活跃不高，以阿里系比较多。 FlutterFlutter 是Google推出的一个跨平台（Android 和 iOS）移动开发框架，使用的是 Dart 语言。 Flutter 的目标是用来创建高性能、高稳定性、高帧率、低延迟的 Android 和 iOS 应用。并且开发出来的应用在不同的平台用起来跟原生应用具有一样的体验。不同的平台的原生体验应该得到保留，让该应用看起来同整个系统更加协调。不同平台的滚动操作、字体、图标 等特殊的特性 应该和该平台上的其他应用保持一致，让用户感觉就像操作原生应用一样。比如，返回图标 Android 和 iOS 是不一样的；滚动内容滚动到底的反馈也是不一样的。 兼容Flutter不使用系统提供的组件，自己实现了一套渲染机制，所以在性能优化、跨平台方面表现优秀。实际体验上，性能比RN要高不少。 RN最终调用的还是系统的组件，虽然FB已经很努力了，但是在某些时候还是会有兼容性需要处理。 组件Flutter 内置了对Material Design的支持，给开发者提供了丰富的 UI 控件库选择。同时所有的组件都有扩展，保持了很高的灵活性。 RN通过react也做到了组件式开发，跟Flutter相比，多了一个桥接器的转换，性能上肯定不如Flutter。 开发语言Flutter使用Dart实现。Dart号称要完全取代js，不过目前离这个目标还非常远。初期上手还是有一些难度的。 RN使用js开发，做过前端的都非常熟悉，上手很容易。 Flutter现在还在实验阶段，不排除google使用别的框架替换它的可能性。Dart语言也处于成长阶段，只有google的浏览器在支持。或许在Flutter持续发展到一个阶段之后，才会有很多支持者。 在写文章的时候google放出了第一个测试版，感兴趣的同学可以下载下来玩玩。 相比于其他几种技术，RN是目前社区最活跃，开发效率最高的一种选择。选择RN也是需要在一个比较短的时间内能够完成APP的开发。尤其现在前端开发者可以非常容易的从网页开发转到APP开发上。对于我们包含APP、微信、小程序这样的三个平台更是需要RN这样的技术，一个团队就可以维护项目的持续增长。 如果你需要RN来开发自己的项目，那就看下去吧。我们将从简单的界面开发，数据更新等开始逐步深入。后面涉及到性能优化、自定义原生部分等。","categories":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://www.guofangchao.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"big-front-end","permalink":"http://www.guofangchao.com/categories/big-front-end/"}]}]}